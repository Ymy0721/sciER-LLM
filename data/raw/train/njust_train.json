[
    {
    "id": "2020.acl-main.71",
    "result":     [
            {
        "value":         {
          "start": 644,
          "end": 660,
          "text": "Boltzmann machine",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 822,
          "end": 838,
          "text": "Boltzmann machine",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 2615,
          "end": 2645,
          "text": "variational autoencoder ( VAE )",
          "labels": ["Method"]
        },
        "id": 68
      },
            {
        "value":         {
          "start": 2748,
          "end": 2751,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 2833,
          "end": 2835,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 2988,
          "end": 2991,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3062,
          "end": 3065,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3082,
          "end": 3114,
          "text": "straight-through ( ST ) technique",
          "labels": ["Method"]
        },
        "id": 85
      },
            {
        "value":         {
          "start": 3225,
          "end": 3228,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3325,
          "end": 3328,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 3411,
          "end": 3418,
          "text": "Doc2hash",
          "labels": ["Method"]
        },
        "id": 91
      },
            {
        "value":         {
          "start": 3481,
          "end": 3484,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3668,
          "end": 3671,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3702,
          "end": 3705,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 3709,
          "end": 3712,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 3718,
          "end": 3725,
          "text": "Doc2hash",
          "labels": ["Method"]
        },
        "id": 91
      },
            {
        "value":         {
          "start": 4629,
          "end": 4652,
          "text": "Boltzmann-machine ( BM )",
          "labels": ["Method"]
        },
        "id": 75
      },
            {
        "value":         {
          "start": 4929,
          "end": 4930,
          "text": "BM",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 5108,
          "end": 5109,
          "text": "BM",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 5360,
          "end": 5377,
          "text": "Boltzmann machines",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 7012,
          "end": 7031,
          "text": "deep neural networks",
          "labels": ["Method"]
        },
        "id": 78
      },
            {
        "value":         {
          "start": 7350,
          "end": 7353,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 7424,
          "end": 7427,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 7433,
          "end": 7436,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 8035,
          "end": 8038,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 8220,
          "end": 8250,
          "text": "multi-layer perceptrons ( MLP )",
          "labels": ["Method"]
        },
        "id": 1520
      },
            {
        "value":         {
          "start": 8283,
          "end": 8286,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 8292,
          "end": 8295,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 8485,
          "end": 8487,
          "text": "MLP",
          "labels": ["Method"]
        },
        "id": 1521
      },
            {
        "value":         {
          "start": 8579,
          "end": 8581,
          "text": "MLP",
          "labels": ["Method"]
        },
        "id": 1521
      },
            {
        "value":         {
          "start": 9375,
          "end": 9399,
          "text": "backpropagation algorithm",
          "labels": ["Method"]
        },
        "id": 81
      },
            {
        "value":         {
          "start": 9994,
          "end": 10010,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 10301,
          "end": 10317,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 10521,
          "end": 10537,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 11517,
          "end": 11532,
          "text": "Boltzmannmachine",
          "labels": ["Method"]
        },
        "id": 83
      },
            {
        "value":         {
          "start": 11586,
          "end": 11602,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 11763,
          "end": 11779,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 12250,
          "end": 12266,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 13099,
          "end": 13115,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 13924,
          "end": 13940,
          "text": "Boltzmann-machine",
          "labels": ["Method"]
        },
        "id": 84
      },
            {
        "value":         {
          "start": 14325,
          "end": 14339,
          "text": "backpropagation",
          "labels": ["Method"]
        },
        "id": 88
      },
            {
        "value":         {
          "start": 14687,
          "end": 14719,
          "text": "straight-through ( ST ) technique",
          "labels": ["Method"]
        },
        "id": 85
      },
            {
        "value":         {
          "start": 14898,
          "end": 14909,
          "text": "ST technique",
          "labels": ["Method"]
        },
        "id": 90
      },
            {
        "value":         {
          "start": 15028,
          "end": 15042,
          "text": "backpropagation",
          "labels": ["Method"]
        },
        "id": 88
      },
            {
        "value":         {
          "start": 15268,
          "end": 15279,
          "text": "MCMC methods",
          "labels": ["Method"]
        },
        "id": 86
      },
            {
        "value":         {
          "start": 17584,
          "end": 17592,
          "text": "ST method",
          "labels": ["Method"]
        },
        "id": 87
      },
            {
        "value":         {
          "start": 17671,
          "end": 17685,
          "text": "backpropagation",
          "labels": ["Method"]
        },
        "id": 88
      },
            {
        "value":         {
          "start": 18939,
          "end": 18954,
          "text": "Semantic Hashing",
          "labels": ["Method"]
        },
        "id": 90
      },
            {
        "value":         {
          "start": 19058,
          "end": 19083,
          "text": "Locality-Sensitive Hashing",
          "labels": ["Method"]
        },
        "id": 89
      },
            {
        "value":         {
          "start": 20475,
          "end": 20477,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 20491,
          "end": 20494,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 20653,
          "end": 20668,
          "text": "semantic hashing",
          "labels": ["Method"]
        },
        "id": 90
      },
            {
        "value":         {
          "start": 20826,
          "end": 20829,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 20995,
          "end": 21006,
          "text": "ST technique",
          "labels": ["Method"]
        },
        "id": 90
      },
            {
        "value":         {
          "start": 21169,
          "end": 21172,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 21433,
          "end": 21446,
          "text": "Gumbel-Softmax",
          "labels": ["Method"]
        },
        "id": 90
      },
            {
        "value":         {
          "start": 21513,
          "end": 21520,
          "text": "Doc2hash",
          "labels": ["Method"]
        },
        "id": 91
      },
            {
        "value":         {
          "start": 21562,
          "end": 21573,
          "text": "ST estimator",
          "labels": ["Method"]
        },
        "id": 91
      },
            {
        "value":         {
          "start": 21578,
          "end": 21581,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 22076,
          "end": 22087,
          "text": "Reuters21578",
          "labels": ["Dataset"]
        },
        "id": 92
      },
            {
        "value":         {
          "start": 22151,
          "end": 22162,
          "text": "20Newsgroups",
          "labels": ["Dataset"]
        },
        "id": 108
      },
            {
        "value":         {
          "start": 22236,
          "end": 22238,
          "text": "TMC",
          "labels": ["Dataset"]
        },
        "id": 107
      },
            {
        "value":         {
          "start": 22417,
          "end": 22420,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 22426,
          "end": 22429,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 22460,
          "end": 22486,
          "text": "feed-forward neural network",
          "labels": ["Method"]
        },
        "id": 95
      },
            {
        "value":         {
          "start": 22594,
          "end": 22599,
          "text": "TF-IDF",
          "labels": ["Method"]
        },
        "id": 1135
      },
            {
        "value":         {
          "start": 22911,
          "end": 22924,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 23478,
          "end": 23511,
          "text": "Locality Sensitive Hashing ( LSH )",
          "labels": ["Method"]
        },
        "id": 98
      },
            {
        "value":         {
          "start": 23540,
          "end": 23584,
          "text": "Stack Restricted Boltzmann Machines ( S-RBM )",
          "labels": ["Method"]
        },
        "id": 99
      },
            {
        "value":         {
          "start": 23624,
          "end": 23647,
          "text": "Spectral Hashing ( SpH )",
          "labels": ["Method"]
        },
        "id": 100
      },
            {
        "value":         {
          "start": 23676,
          "end": 23702,
          "text": "Self-Taught Hashing ( STH )",
          "labels": ["Method"]
        },
        "id": 101
      },
            {
        "value":         {
          "start": 23731,
          "end": 23772,
          "text": "Variational Deep Semantic Hashing ( VDSH )",
          "labels": ["Method"]
        },
        "id": 102
      },
            {
        "value":         {
          "start": 23807,
          "end": 23857,
          "text": "Neural Architecture for Generative Semantic Hashing",
          "labels": ["Method"]
        },
        "id": 103
      },
            {
        "value":         {
          "start": 23898,
          "end": 23959,
          "text": "Semantic Hashing model with a Bernoulli Mixture prior ( BMSH )",
          "labels": ["Method"]
        },
        "id": 104
      },
            {
        "value":         {
          "start": 24073,
          "end": 24081,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24455,
          "end": 24463,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24485,
          "end": 24494,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 24627,
          "end": 24636,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 24650,
          "end": 24652,
          "text": "TMC",
          "labels": ["Dataset"]
        },
        "id": 107
      },
            {
        "value":         {
          "start": 24656,
          "end": 24662,
          "text": "Reuters",
          "labels": ["Dataset"]
        },
        "id": 1528
      },
            {
        "value":         {
          "start": 24668,
          "end": 24679,
          "text": "20Newsgroups",
          "labels": ["Dataset"]
        },
        "id": 108
      },
            {
        "value":         {
          "start": 24815,
          "end": 24818,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 24974,
          "end": 24990,
          "text": "Boltzmann machine",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 25269,
          "end": 25272,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 25299,
          "end": 25302,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 25505,
          "end": 25508,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 25542,
          "end": 25545,
          "text": "RBSH",
          "labels": ["Method"]
        },
        "id": 108
      },
            {
        "value":         {
          "start": 25605,
          "end": 25608,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 26336,
          "end": 26339,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 26343,
          "end": 26346,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 26352,
          "end": 26355,
          "text": "BMSH",
          "labels": ["Method"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 27314,
          "end": 27324,
          "text": "TMC dataset",
          "labels": ["Dataset"]
        },
        "id": 109
      },
            {
        "value":         {
          "start": 27439,
          "end": 27450,
          "text": "vanilla NASH",
          "labels": ["Method"]
        },
        "id": 111
      },
            {
        "value":         {
          "start": 27631,
          "end": 27642,
          "text": "vanilla NASH",
          "labels": ["Method"]
        },
        "id": 111
      },
            {
        "value":         {
          "start": 27860,
          "end": 27863,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 27867,
          "end": 27870,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 27898,
          "end": 27918,
          "text": "20Newsgroups datasets",
          "labels": ["Dataset"]
        },
        "id": 111
      },
            {
        "value":         {
          "start": 27977,
          "end": 27990,
          "text": "UMAP technique",
          "labels": ["Method"]
        },
        "id": 112
      },
            {
        "value":         {
          "start": 28144,
          "end": 28147,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 28231,
          "end": 28234,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 28299,
          "end": 28302,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 28341,
          "end": 28344,
          "text": "VDSH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 29224,
          "end": 29227,
          "text": "NASH",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 29371,
          "end": 29380,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 30192,
          "end": 30201,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 30423,
          "end": 30431,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 30772,
          "end": 30788,
          "text": "Boltzmann machine",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 30929,
          "end": 30930,
          "text": "BM",
          "labels": ["Method"]
        },
        "id": 113
      },
            {
        "value":         {
          "start": 31171,
          "end": 31188,
          "text": "Boltzmann machines",
          "labels": ["Method"]
        },
        "id": 113
      }
    ],
    "data": {"text": "Generative Semantic Hashing Enhanced via Boltzmann Machines Abstract Generative semantic hashing is a promising technique for large-scale information retrieval thanks to its fast retrieval speed and small memory footprint. For the tractability of training, existing generative-hashing methods mostly assume a factorized form for the posterior distribution, enforcing independence among the bits of hash codes. From the perspectives of both model representation and code space size, independence is always not the best assumption. In this paper , to introduce correlations among the bits of hash codes , we propose to employ the distribution of Boltzmann machine as the variational posterior . To address the intractability issue of training , we first develop an approximate method to reparameterize the distribution of a Boltzmann machine by augmenting it as a hierarchical concatenation of a Gaussian-like distribution and a Bernoulli distribution . Based on that, an asymptotically-exact lower bound is further derived for the evidence lower bound ( ELBO ). With these novel techniques, the entire model can be optimized efficiently. Extensive experimental results demonstrate that by effectively modeling correlations among different bits within a hash code, our model can achieve significant performance gains. 1 Introduction Similarity search, also known as nearest-neighbor search, aims to find items that are similar to a query from a large dataset. It plays an important role in modern information retrieval systems and has been used in various applications, ranging from plagiarism analysis ( Stein et al., 2007 ) to content-based multimedia retrieval ( Lew et al., 2006 ), etc. However, looking for nearest neighbors in the Euclidean space is often computationally prohibitive for large-scale datasets ( calculating cosine similarity with high-dimensional vectors is computationally-expensive ). Semantic hashing circumvents this problem by representing semantically similar documents with compact and binary codes. Accordingly, similar documents can be retrieved by evaluating the hamming distances of their hash codes much more efficiently. To obtain similarity-preserving hash codes, extensive efforts have been made to learn hash functions that can preserve the similarity information of original documents in the binary embedding space ( Shen et al., 2015; Liu et al., 2016 ). Existing methods often require the availability of label information, which is often expensive to obtain in practice. To avoid the use of labels, generative semantic hashing methods have been developed. Specifically , the variational autoencoder ( VAE ) is first employed for semantic hashing in ( Chaidaroon and Fang , 2017 ) , and their model is termed VDSH . As a two-step process , the continuous document representations obtained from VAE are directly converted into binary hash codes . To resolve the two-step training problem , Bernoulli priors are leveraged as the prior distribution in NASH ( Shen et al . , 2018 ) , replacing the continuous Gaussian prior in VDSH . By utilizing straight-through ( ST ) technique ( Bengio et al . , 2013 ) , their model can be trained in an end-to-end manner , while keeping the merits of VDSH . Recently , to further improve the quality of hash codes , mixture priors are investigated in BMSH ( Dong et al . , 2019 ) , while more accurate gradient estimators are studied in Doc2hash ( Zhang and Zhu , 2019 ) , both under a similar framework as NASH . Due to the training-tractability issue , the aforementioned generative hashing methods all assume a factorized variational form for the posterior , e.g . , independent Gaussian in VDSH and independent Bernoulli in NASH , BMSH and Doc2hash . This assumption prevents the models from capturing dependencies among the bits of hash codes. Although uncorrelated bits are sometimes preferred in hashing, as reported in ( Zhang and Li, 2014 ), this may not apply to generative semantic hashing. This is due to the fact that the independent assumption could severely limit a model’s ability to yield meaningful representations and thereby produce high-quality hash codes. Moreover, as the code length increases ( to e.g. 128 bits ), the number of possible codes ( or simply the code space ) will be too large for a dataset with limited number of data points. As a result, we advocate that correlations among bits of a hash code should be considered properly to restrict the embedding space, and thus enable a model to work effectively under a broad range of code lengths. To introduce correlations among bits of hash codes , we propose to adopt the Boltzmann-machine ( BM ) distribution ( Ackley et al . , 1985 ) as a variational posterior to capture various complex correlations . One issue with this setting, relative to existing efficient training methods, is the inefficiency brought in training. To address this issue , we first prove that the BM distribution can be augmented as a hierarchical concatenation of a Gaussian-like distribution and a Bernoulli distribution . Using this result , we then show that samples from BM distributions can be well reparameterized easily . To enable efficient learning , an asymptotically-exact lower bound of the standard evidence lower bound ( ELBO ) is further developed to deal with the notorious problem of the normalization term in Boltzmann machines . With the proposed reparameterization and the new lower bound, our model can be trained efficiently as the previous generative hashing models that preserve no bit correlations. Extensive experiments are conducted to evaluate the performance of the proposed model. It is observed that on all three public datasets considered, the proposed model achieves the best performance among all comparable models. In particular, thanks to the introduced correlations, we observe the performance of the proposed model does not deteriorate as the code length increases. This is surprising and somewhat contrary to what has been observed in other generative hashing models. 2 Preliminaries Generative Semantic Hashing. In the context of generative semantic hashing, each document is represented by a sequence of words x = {w1, w2, · · · , w|x|}, where wi is the i-th word and is denoted by a |V |-dimensional one-hot vector; |x| and |V | denotes the document size ( number of words ) and the vocabulary size, respectively. Each document x is modeled by a joint probability: where s is a latent variable representing the document’s hash code. With the probability pθ( x, s ) trained on a set of documents, the hash code for a document x can be derived directly from the posterior distribution pθ( s|x ). In existing works, the likelihood function, or the decoder takes a form where E ∈ Rm×|V | is the matrix connecting the latent code s and the one-hot representation of words; and ej is the one-hot vector with the only ‘1’ locating at the i-th position. Documents could be modelled better by using more expressive likelihood functions , e.g . , deep neural networks , but as explained in ( Shen et al . , 2018 ) , they are more likely to destroy the crucial distance-keeping property for semantic hashing . Thus, the simple form of ( 2 ) is often preferred in generative hashing. As for the prior distribution p ( s ) , it is often chosen as the standard Gaussian distribution as in VDSH ( Chaidaroon and Fang , 2017 ) , or the Bernoulli distribution as in NASH and BMSH ( Shen et al . , 2018 ; Dong et al . , 2019 ) . Inference. Probabilistic models can be trained by maximizing the log-likelihood log pθ( x ) with pθ( x ) = ∫ s pθ( x, s )ds. However, due to the intractability of calculating pθ( x ), we instead optimize its evidence lower bound ( ELBO ), i.e., where qφ( s|x ) is the proposed variational posterior parameterized by φ. It can be shown that log pθ( x ) ≥ L holds for any qφ( s|x ) , and that if qφ( s|x ) is closer to the true posterior pθ( s|x ), the bound L will be tighter. Training then reduces to maximizing the lower bound L w.r.t. θ and φ. In VDSH ( Chaidaroon and Fang , 2017 ) , qφ ( s | x ) takes the form of an independent Gaussian distribution : where µφ ( x ) and σφ ( x ) are two vector-valued functions parameterized by multi-layer perceptrons ( MLP ) with parameters φ . Later , in NASH and BMSH ( Shen et al . , 2018 ; Dong et al . , 2019 ) , qφ ( s | x ) is defined as an independent Bernoulli distribution , i.e . , where gφ ( x ) is also vector-valued function parameterized by a MLP . The value at each dimension represents the probability of being 1 at that position. The MLP used to parameterize the posterior qφ ( s | x ) is also referred to as the encoder network . One key requirement for efficient end-to-end training of generative hashing method is the availability of reparameterization for the variational distribution qφ( s|x ). For example, when qφ( s|x ) is a Gaussian distribution as in ( 4 ), a sample s from it can be efficiently reparameterized as with \u000f ∼ N ( 0, I ). When qφ( s|x ) is a Bernoulli distribution as in ( 5 ), a sample from it can be reparameterized as where \u000f ∈ Rm with elements \u000fi ∼ uniform( 0, 1 ). With these reparameterization tricks, the lower bound in ( 3 ) can be estimated by the sample s as L ≈ log pθ( x|sφ )p( sφ ) where s has been denoted as sφ to explicitly indicate its dependence on φ. To train these hashing models , the backpropagation algorithm can be employed to estimate the gradient of ( 8 ) w.r.t . θ and φ easily . However, it is worth noting that in order to use the reparameterization trick, all existing methods assumed a factorized form for the proposed posterior qφ( s|x ), as shown in ( 4 ) and ( 5 ). This suggests that the binary bits in hash codes are independent of each other, which is not the best setting in generative semantic hashing. 3 Correlation-Enhanced Generative Semantic Hashing In this section , we present a scalable and efficient approach to introducing correlations into the bits of hash codes , by using a Boltzmann-machine distribution as the variational posterior with approximate reparameterization . 3.1 Boltzmann Machine as the Variational Posterior Many probability distributions defined over binary variables s ∈ {0, 1}m are able to capture the dependencies. Among them , the most famous one should be the Boltzmann-machine distribution ( Ackley et al . , 1985 ) , which takes the following form : where Σ ∈ Rm × m and µ ∈ Rm are the distribution parameters ; and Z , ∑ s e 1 2 sTΣs + µT s is the normalization constant . The Boltzmann-machine distribution can be adopted to model correlations among the bits of a hash code . Specifically, by restricting the posterior to the Boltzmann form and substituting it into the lower bound of ( 3 ), we can write the lower bound as: where Eφ( s ) , −12sTΣφ( x )s − µTφ ( x )s; and Σφ( x ) and µφ( x ) are functions parameterized by the encoder network with parameters φ and x as input. One problem with such modeling is that the expectation term Eqφ( s|x )[·] in ( 11 ) cannot be expressed in a closed form due to the complexity of qφ( s|x ). Consequently, one cannot directly optimize the lower bound L w.r.t. θ and φ. 3.2 Reparameterization An alternative way is to approximate the expectation term by using the reparameterized form of a sample s from qφ( s|x ), as was done in the previous uncorrelated generative hashing models ( see ( 6 ) and ( 7 ) ). Compared to existing simple variational distributions , there is no existing work on how to reparameterize the complicated Boltzmannmachine distribution . To this end , we first show that the Boltzmann-machine distribution can be equivalently written as the composition of an approximate correlated Gaussian distribution and a Bernoulli distribution . Proposition 1. A Boltzmann-machine distribution b ( s ) = 1Z e 1 2 sTΣs + µT s with Σ 0 can be equivalently expressed as the composition of two distributions , that is , where p ( r ) = 1Z ∏ m i = 1 ( e ri + 1 ) · N ( r ; µ , Σ ) ; p ( s | r ) = ∏ mi = 1 p ( si | ri ) with si and ri denoting the i-th element of s and r ; and p ( si | ri ) , Bernoulli ( σ ( ri ) ) with σ ( · ) being the sigmoid function . Proof. See Appendix A.1 for details. Based on Proposition 1 , we can see that a sample from the Boltzmann-machine distribution qφ ( s | x ) in ( 10 ) can be sampled hierarchically as where and σ ( · ) is applied to its argument element-wise . From the expression of qφ( r|x ), we can see that for small values of ri, the influence of ( eri + 1 ) on the overall distribution is negligible, and thus qφ( r|x ) can be well approximated by the Gaussian distribution N ( r;µφ( x ),Σφ( x ) ). For relatively large ri, the term ( eri + 1 ) will only influence the distribution mean, roughly shifting the Gaussian distribution N ( r;µφ( x ),Σφ( x ) ) by an amount approximately equal to its variance. For problems of interest in this paper, the variances of posterior distribution are often small, hence it is reasonable to approximate samples from qφ( r|x ) by those from N ( r;µφ( x ),Σφ( x ) ). With this approximation , we can now draw samples from Boltzmann-machine distribution qφ ( s | x ) in ( 10 ) approximately by the two steps below For the Gaussian sample r ∼ N ( r ; µφ ( x ) , Σφ ( x ) ) , similar to ( 6 ) , it can be reparameterized as where Lφ ( x ) is the Cholesky decomposition matrix of Σφ ( x ) with Σφ ( x ) = Lφ ( x ) LTφ ( x ) ; and  ∈ Rm with  ∼ N ( 0 , I ) . It should be noted that in practice, we can define the function Lφ( x ) in advance and then obtain Σφ( x ) as Σφ( x ) = Lφ( x )LTφ ( x ), thus the Cholesky decomposition is not needed. Given the Gaussian sample r, similar to the reparameterization of Bernoulli variables in ( 7 ), we can reparameterize the Bernoulli sample s ∼ Bernoulli( σ( r ) ) as s = sign( σ( r )−u )+12 , where u ∈ Rm with each element ui ∼ uniform( 0, 1 ). By combining the above reparameterizations , a sample from the Boltzmann-machine distribution qφ ( s | x ) can then be approximately reparameterized as where the subscript φ is to explicitly indicate that the sample s is expressed in terms of φ . With the reparameterization sφ, the expectation term in ( 11 ) can be approximated as log pθ( x|sφ )p( sφ ) e −Eφ( sφ ) . Consequently , the gradients of this term w.r.t . both θ and φ can be evaluated efficiently by backpropagation , with the only difficulty lying at the non-differentiable function sign ( · ) of sφ in ( 18 ) . Many works have been devoted to estimate the gradient involving discrete random variables ( Bengio et al., 2013; Jang et al., 2017; Maddison et al., 2017; Tucker et al., 2017; Grathwohl et al., 2018; Yin and Zhou, 2019 ). Here , we adopt the simple straight-through ( ST ) technique ( Bengio et al . , 2013 ) , which has been found performing well in many applications . By simply treating the hard threshold function sign ( · ) as the identity function , the ST technique estimates the gradient as . Then , the gradient of the first term in ELBO L w.r.t . φ can be computed efficiently by backpropagation . 3.3 An Asymptotically-Exact Lower Bound To optimize the ELBO in ( 11 ), we still need to calculate the gradient of logZφ, which is known to be notoriously difficult. A common way is to estimate the gradient ∂ logZφ ∂ φ by MCMC methods ( Tieleman , 2008 ; Desjardins et al . , 2010 ; Su et al . , 2017a , b ) , which are computationally expensive and often of high variance . By noticing a special form of the ELBO ( 11 ), we develop a lower bound for the ELBO L, where the logZφ term can be conveniently cancelled out. Specifically, we introduce another probability distribution h( s ) and lower bound the original ELBO: Since KL( · ) ≥ 0, we have L˜( θ, φ ) ≤ L holds for all h( s ), i.e., L˜ is a lower bound of L, and equals to the ELBO L when h( s ) = qφ( s|x ). For the choice of h( s ), it should be able to reduce the gap between L˜ and L as much as possible, while ensuring that the optimization is tractable. Balancing on the two sides, a mixture distribution is used where k denotes the number of components; p( s|r( i ) ) is the multivariate Bernoulli distribution and r( i ) is the i-th sample drawn from qφ( r|x ) as defined in ( 14 ). By substituting hk( s ) into ( 20 ) and taking the expectation w.r.t. r( i ), we have where qφ( r( 1··· ,k )|x ) = ∏k i=1 qφ( r ( i )|x ). It can be proved that the bound L˜k gradually approaches the ELBO L as k increases, and finally equals to it as k →∞. Specifically, we have Proposition 2. For any integer k, the lower bound L˜k of the ELBO satisfies the conditions: 1 ) L˜k+1 ≥ L˜k; 2 ) limk→∞ L˜k = L. Proof. See Appendix A.2 for details. By substituting L in ( 11 ) and hk( s ) in ( 21 ) into ( 22 ), the bound can be further written as where the logZφ term is cancelled out since it appears in both terms but has opposite signs. For the first term in ( 23 ), as discussed at the end of Section 3.1, it can be approximated as log pθ( x|sφ )p( sφ ) e −Eφ( sφ ) . For the second term, each sample r( i ) for i = 1, · · · , k can be approximately reparameterized like that in ( 17 ). Given the r( i ) for i = 1, · · · , k, samples from hk( s ) can also be reparameterized in a similar way as that for Bernoulli distributions in ( 7 ). Thus, samples drawn from r( 1···k ) ∼ qφ( r( 1···k )|x ) and s ∼ hk( s ) are also reparameterizable, as detailed in Appendix A.3. By denoting this reparametrized sample as s˜φ, we can approximate the second term in ( 23 ) as log hk( s˜φ ) e −Eφ( s˜φ ) . Thus the lower bound ( 23 ) becomes . With the discrete gradient estimation techniques like the ST method , the gradient of L ˜ k w.r.t . θ and φ can then be evaluated efficiently by backpropagation . Proposition 2 indicates that the exact L˜k gets closer to the ELBO as k increases, so better bound can be expected for the approximated L˜k as well when k increases. In practice, a moderate value of k is found to be sufficient to deliver a good performance. 3.4 Low-Rank Perturbation for the Covariance Matrix In the reparameterization of a Gaussian sample, rφ = µφ( x ) + Lφ( x ) · \u000f in ( 17 ), a m × m matrix Lφ( x ) is required, with m denoting the length of hash codes. The elements of Lφ( x ) are often designed as the outputs of neural networks parameterized by φ. Therefore, if m is large, the number of neural network outputs will be too large. To overcome this issue, a more parameter-efficient strategy called Low-Rank Perturbation is employed, which restricts covariance matrix to the form where D is a diagonal matrix with positive entries and U = [u1, u2, · · ·uv] is a low-rank perturbation matrix with ui ∈ Rm and v \u001c m. Under this low-rank perturbed Σ, the Gaussian samples can be reparameterized as where \u000f1 ∼ N ( 0, Im ) and \u000f2 ∼ N ( 0, Iv ). We can simply replace ( 17 ) with the above expression in any place that uses r. In this way, the number of neural network outputs can be dramatically reduced from m2 to mv. 4 Related Work Semantic Hashing ( Salakhutdinov and Hinton , 2009 ) is a promising technique for fast approximate similarity search . Locality-Sensitive Hashing , one of the most popular hashing methods ( Datar et al . , 2004 ) , projects documents into low-dimensional hash codes in a randomized manner . However, the method does not leverage any information of data, and thus generally performs much worse than those data-dependent methods. Among the datadependent methods, one of the mainstream methods is supervised hashing, which learns a function that could output similar hash codes for semantically similar documents by making effective use of the label information ( Shen et al., 2015; Liu et al., 2016 ). Different from supervised methods, unsupervised hashing pays more attention to the intrinsic structure of data, without making use of the labels. Spectral hashing ( Weiss et al., 2009 ), for instance, learns balanced and uncorrelated hash codes by seeking to preserve a global similarity structure of documents. Self-taught hashing ( Zhang et al., 2010 ), on the other hand, focuses more on preserving local similarities among documents and presents a two-stage training procedure to obtain such hash codes. In contrast, to generate high-quality hash codes, iterative quantization ( Gong et al., 2013 ) aims to minimize the quantization error, while maximizing the variance of each bit at the same time. Among the unsupervised hashing methods, the idea of generative semantic hashing has gained much interest in recent years. Under the VAE framework , VDSH ( Chaidaroon and Fang , 2017 ) was proposed to first learn continuous the documents ’ latent representations , which are then cast into binary codes . While semantic hashing is achieved with generative models nicely , the twostage training procedure is problematic and is prone to result in local optima . To address this issue , NASH ( Shen et al . , 2018 ) went one step further and presented an integrated framework to enable the end-to-end training by using the discrete Bernoulli prior and the ST technique , which is able to estimate the gradient of functions with discrete variables . Since then , various directions have been explored to improve the performance of NASH . ( Dong et al., 2019 ) proposed to employ the mixture priors to improve the model’s capability to distinguish documents from different categories, and thereby improving the quality of hash codes. On the other hand , a more accurate gradient estimator called Gumbel-Softmax ( Jang et al . , 2017 ; Maddison et al . , 2017 ) is explored in Doc2hash ( Zhang and Zhu , 2019 ) to replace the ST estimator in NASH . More recently, to better model the similarities between different documents, ( Hansen et al., 2019 ) investigated the combination of generative models and ranking schemes to generate hash codes. Different from the aforementioned generative semantic hashing methods, in this paper, we focus on how to incorporate correlations into the bits of hash codes. 5 Experiments 5.1 Experimental Setup Datasets. Following previous works , we evaluate our model on three public benchmark datasets : i ) Reuters21578 , which consists of 10788 documents with 90 categories ; ii ) 20Newsgroups , which contains 18828 newsgroup posts from 20 different topics ; iii ) TMC , which is a collection of 21519 documents categorized into 22 classes . Training Details. For the conveniences of comparisons , we use the same network architecture as that in NASH and BMSH . Specifically , a 2 - layer feed-forward neural network with 500 hidden units and a ReLU activation function is used as an inference network , which receives the TF-IDF of a document as input and outputs the mean and covariance matrix of the Gaussian random variables r . During training, the dropout ( Srivastava et al., 2014 ) is used to alleviate the overfitting issue, with the keeping probability selected from {0.8, 0.9} based on the performance on the validation set. The Adam optimizer ( Kingma and Ba , 2014 ) is used to train our model , with the learning rate set to 0.001 initially and then decayed for every 10000 iterations . For all experiments on different datasets and lengths of hash codes, the rank v of matrix U is set to 10 and the number of component k in the distribution hk( s ) is set to 10 consistently, although a systematic ablation study is conducted in Section 5.5 to investigate their impacts on the final performances. Baselines. The following unsupervised semantic hashing baselines are adopted for comparisons : Locality Sensitive Hashing ( LSH ) ( Datar et al . , 2004 ) , Stack Restricted Boltzmann Machines ( S-RBM ) ( Salakhutdinov and Hinton , 2009 ) , Spectral Hashing ( SpH ) ( Weiss et al . , 2009 ) , Self-Taught Hashing ( STH ) ( Zhang et al . , 2010 ) , Variational Deep Semantic Hashing ( VDSH ) ( Chaidaroon and Fang , 2017 ) , Neural Architecture for Generative Semantic Hashing ( NASH ) ( Shen et al . , 2018 ) , and Semantic Hashing model with a Bernoulli Mixture prior ( BMSH ) ( Dong et al . , 2019 ) . Evaluation Metrics. The performance of our proposed approach is measured by retrieval precision i.e . , the ratio of the number of relevant documents to that of retrieved documents . A retrieved document is said to be relevant if its label is the same as that of the query one. Specifically , during the evaluating phase , we first pick out top 100 most similar documents for each query document according to the hamming distances of their hash codes , from which the precision is calculated . The precisions averaged over all query documents are reported as the final performance . 5.2 Results of Generative Semantic Hashing The retrieval precisions on datasets TMC , Reuters and 20Newsgroups are reported in Tables 1 , 2 and 3 , respectively , under different lengths of hash codes . Compared to the generative hashing method NASH without considering correlations , we can see that the proposed method , which introduces correlations among bits by simply employing the distribution of Boltzmann machine as the posterior , performs significantly better on all the three datasets considered . This strongly corroborates the benefits of taking correlations into account when learning the hash codes. From the tables , we can also observe that the proposed model even outperforms the BMSH , an enhanced variant of NASH that employs more complicated mixture distributions as a prior . Since only the simplest prior is used in the proposed model , larger performance gains can be expected if mixture priors are used as in BMSH . Notably , a recent work named RBSH is proposed in ( Hansen et al . , 2019 ) , which improves NASH by specifically ranking the documents according to their similarities . However, since it employs a different data preprocessing technique as the existing works, we cannot include its results for a direct comparison here. Nevertheless, we trained our model on their preprocessed datasets and find that our method still outperforms it. For details about the results, please refer to Appendix A.4. Moreover, when examining the retrieval performance of hash codes under different lengths, it is observed that the performance of our proposed method never deteriorates as the code length increases, while other models start to perform poorly after the length of codes reaching a certain level. For the most comparable methods like VDSH , NASH and BMSH , it can be seen that the performance of 128 bits is generally much worse than that of 64 bits . This phenomenon is illustrated more clearly in Figure 1. This may attribute to the reason that for hash codes without correlations, the number of codes will increase exponentially as the code length increases. Because the code space is too large, the probability of assigning similar items to nearby binary codes may decrease significantly. But for the proposed model, since the bits of hash codes are correlated to each other, the effective number of codes can be determined by the strength of correlations among bits, effectively restricting the size of code space. Therefore, even though the code length increases continually, the performance of our proposed model does not deteriorate. 5.3 Empirical Study of Computational Efficiency To show the computational efficiency of our proposed method , we also report the average running time per epoch in GPU on TMC dataset , which is of the largest among the considered ones , in Table 4 . As a benchmark , the average training time of vanilla NASH is 2.553s per epoch . It can be seen that because of to the use of low-rank parameterization of the covariance matrix , the proposed model can be trained almost as efficiently as vanilla NASH , but deliver a much better performance . 5.4 Hash Codes Visualization To further investigate the capability of different models in generating semantic-preserving binary codes , we project the hash codes produced by VDSH , NASH and our proposed model on 20Newsgroups datasets onto a two-dimensional plane by using the widely adopted UMAP technique ( McInnes et al . , 2018 ) and then visualize them on the twodimensional planes , as shown in Figure 2 . It can be seen that the hash codes produced by VDSH are quite mixed for documents from different categories , while those produced by NASH are more distinguishable , consistent with the hypothesis that NASH is able to produce better codes than VDSH thanks to the end-to-end training . From the figure, we can further observe that the hash codes produced by our proposed method are the most distinguishable among all three methods considered, corroborating the benefits of introducing correlations among the bits of hash codes. 5.5 Analyses on the Impacts of v and k Ranks v. Low-rank perturbed covariance matrix enables the proposed model to trade-off between complexity and performance. That is, larger v allows the model to capture more dependencies among latent variables, but the required computational complexity also increases. To investigate its impacts, we evaluate the performance of the 64bit hash codes obtained from the proposed model under different values of v, with the other key parameter k fixed to 10. The result is listed in the left half of Table 5. Notably , the proposed model with v = 0 is equivalent to NASH since there is not any correlation between the binary random variables . It can be seen that as the number of ranks increases , the retrieval precisions also increase , justifying the hypothesis that employing the posteriors with correlations can increase the model ’ s representational capacity and thereby improves the hash codes ’ quality in turn . It is worth noting that the most significant performance improvement is observed between the models with v = 0 and v = 1, and then as the value of v continues to increase, the improvement becomes relatively small. This indicates that it is feasible to set the v to a relatively small value to save computational resources while retaining competitive performance. The number of mixture components k. As stated in Section 3.3, increasing the number of components k in the mixture distribution hk( s ) will reduce the gap between the lower bound L˜k and the ELBO L. To investigate the impacts of k , the retrieval precisions of the proposed model are evaluated under different values of k , while setting the other key parameter v = 10 . It can be seen from the right half of Table 5 that as the number of components k increases , the retrieval precision also increases gradually , suggesting that a tighter lower bound L ˜ k can always indicate better hash codes . Hence, if more mixture components are used, better hash codes can be expected. Due to the sake of complexity, only 10 components are used at most in the experiments. 6 Conclusion In this paper , by employing the distribution of Boltzmann machine as the posterior , we show that correlations can be efficiently introduced into the bits . To facilitate training , we first show that the BM distribution can be augmented as a hierarchical concatenation of a Gaussian-like distribution and a Bernoulli distribution . Then , an asymptoticallyexact lower bound of ELBO is further developed to tackle the tricky normalization term in Boltzmann machines . Significant performance gains are observed in the experiments after introducing correlations into the bits of hash codes. "}
  },
    {
    "id": "2020.acl-main.9",
    "result":     [
            {
        "value":         {
          "start": 437,
          "end": 456,
          "text": "attention mechanisms",
          "labels": ["Method"]
        },
        "id": 1335
      },
            {
        "value":         {
          "start": 1201,
          "end": 1204,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 1236,
          "end": 1240,
          "text": "XLNet",
          "labels": ["Method"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 1425,
          "end": 1441,
          "text": "English Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 1446,
          "end": 1456,
          "text": "BooksCorpus",
          "labels": ["Dataset"]
        },
        "id": 117
      },
            {
        "value":         {
          "start": 2054,
          "end": 2057,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2515,
          "end": 2518,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2927,
          "end": 2932,
          "text": "Reddit",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 2938,
          "end": 2944,
          "text": "Twitter",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 8490,
          "end": 8493,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8556,
          "end": 8564,
          "text": "WordPiece",
          "labels": ["Method"]
        },
        "id": 121
      },
            {
        "value":         {
          "start": 9082,
          "end": 9085,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 9091,
          "end": 9099,
          "text": "WordPiece",
          "labels": ["Method"]
        },
        "id": 121
      },
            {
        "value":         {
          "start": 12764,
          "end": 12771,
          "text": "BERTBASE",
          "labels": ["Method"]
        },
        "id": 121
      },
            {
        "value":         {
          "start": 12811,
          "end": 12817,
          "text": "Twitter",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 12846,
          "end": 12851,
          "text": "Reddit",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 13909,
          "end": 13922,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 15287,
          "end": 15315,
          "text": "reinforcement learning ( RL )",
          "labels": ["Method"]
        },
        "id": 122
      },
            {
        "value":         {
          "start": 15417,
          "end": 15418,
          "text": "RL",
          "labels": ["Method"]
        },
        "id": 123
      },
            {
        "value":         {
          "start": 15727,
          "end": 15738,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 15996,
          "end": 16007,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 16123,
          "end": 16134,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 16213,
          "end": 16217,
          "text": "DSTC7",
          "labels": ["Dataset"]
        },
        "id": 127
      },
            {
        "value":         {
          "start": 16283,
          "end": 16294,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 16853,
          "end": 16872,
          "text": "Sequence to sequence",
          "labels": ["Method"]
        },
        "id": 128
      },
            {
        "value":         {
          "start": 16879,
          "end": 16887,
          "text": "attention",
          "labels": ["Method"]
        },
        "id": 129
      },
            {
        "value":         {
          "start": 16891,
          "end": 16897,
          "text": "Seq2Seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 16978,
          "end": 16989,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 16995,
          "end": 17006,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 17010,
          "end": 17021,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 17154,
          "end": 17165,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 17256,
          "end": 17283,
          "text": "Lost in Conversation ( LIC )",
          "labels": ["Method"]
        },
        "id": 130
      },
            {
        "value":         {
          "start": 17345,
          "end": 17347,
          "text": "LIC",
          "labels": ["Method"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 17442,
          "end": 17444,
          "text": "GPT",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 17494,
          "end": 17505,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 17574,
          "end": 17579,
          "text": "iVAEMI",
          "labels": ["Method"]
        },
        "id": 148
      },
            {
        "value":         {
          "start": 17686,
          "end": 17697,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 18144,
          "end": 18147,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18257,
          "end": 18272,
          "text": "Distinct - 1 / 2",
          "labels": ["Metric"]
        },
        "id": 133
      },
            {
        "value":         {
          "start": 18452,
          "end": 18457,
          "text": "Recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 18461,
          "end": 18469,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18473,
          "end": 18474,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18573,
          "end": 18584,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 18592,
          "end": 18597,
          "text": "MSCOCO",
          "labels": ["Tool"]
        },
        "id": 136
      },
            {
        "value":         {
          "start": 18747,
          "end": 18750,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18754,
          "end": 18760,
          "text": "ME-TEOR",
          "labels": ["Metric"]
        },
        "id": 137
      },
            {
        "value":         {
          "start": 18764,
          "end": 18770,
          "text": "ROUGH-L",
          "labels": ["Metric"]
        },
        "id": 138
      },
            {
        "value":         {
          "start": 18776,
          "end": 18780,
          "text": "CIDEr",
          "labels": ["Metric"]
        },
        "id": 139
      },
            {
        "value":         {
          "start": 19009,
          "end": 19015,
          "text": "fluency",
          "labels": ["Metric"]
        },
        "id": 150
      },
            {
        "value":         {
          "start": 19019,
          "end": 19027,
          "text": "coherence",
          "labels": ["Metric"]
        },
        "id": 143
      },
            {
        "value":         {
          "start": 19031,
          "end": 19045,
          "text": "informativeness",
          "labels": ["Metric"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 19140,
          "end": 19146,
          "text": "Fluency",
          "labels": ["Metric"]
        },
        "id": 150
      },
            {
        "value":         {
          "start": 19226,
          "end": 19234,
          "text": "Coherence",
          "labels": ["Metric"]
        },
        "id": 143
      },
            {
        "value":         {
          "start": 19387,
          "end": 19401,
          "text": "Informativeness",
          "labels": ["Metric"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 19722,
          "end": 19737,
          "text": "Fleiss ’ s kappa",
          "labels": ["Metric"]
        },
        "id": 143
      },
            {
        "value":         {
          "start": 19770,
          "end": 19781,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 19787,
          "end": 19798,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 19943,
          "end": 19954,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 19960,
          "end": 19971,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 20424,
          "end": 20435,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 20441,
          "end": 20452,
          "text": "Daily Dialog",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 20470,
          "end": 20476,
          "text": "fluency",
          "labels": ["Metric"]
        },
        "id": 150
      },
            {
        "value":         {
          "start": 20573,
          "end": 20587,
          "text": "informativeness",
          "labels": ["Metric"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 21101,
          "end": 21103,
          "text": "LIC",
          "labels": ["Method"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 21179,
          "end": 21185,
          "text": "Seq2Seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 21191,
          "end": 21196,
          "text": "iVAEMI",
          "labels": ["Method"]
        },
        "id": 148
      },
            {
        "value":         {
          "start": 21230,
          "end": 21241,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 21579,
          "end": 21590,
          "text": "DSTC7 - AVSD",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 22461,
          "end": 22472,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 22871,
          "end": 22874,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22879,
          "end": 22885,
          "text": "GPT - 2",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 22917,
          "end": 22928,
          "text": "Persona-Chat",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 22948,
          "end": 22954,
          "text": "Twitter",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 22960,
          "end": 22965,
          "text": "Reddit",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 23642,
          "end": 23648,
          "text": "Twitter",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 23654,
          "end": 23659,
          "text": "Reddit",
          "labels": ["Dataset"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 24286,
          "end": 24305,
          "text": "attention mechanisms",
          "labels": ["Method"]
        },
        "id": 1335
      },
            {
        "value":         {
          "start": 24309,
          "end": 24311,
          "text": "GPT",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 24344,
          "end": 24350,
          "text": "GPT - 2",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 24564,
          "end": 24567,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24599,
          "end": 24603,
          "text": "XLNet",
          "labels": ["Method"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 24750,
          "end": 24771,
          "text": "unified language model",
          "labels": ["Method"]
        },
        "id": 144
      },
            {
        "value":         {
          "start": 24773,
          "end": 24777,
          "text": "UniLM",
          "labels": ["Method"]
        },
        "id": 145
      },
            {
        "value":         {
          "start": 24876,
          "end": 24889,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 25056,
          "end": 25058,
          "text": "GPT",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 25063,
          "end": 25069,
          "text": "GPT - 2",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 25471,
          "end": 25474,
          "text": "CVAE",
          "labels": ["Method"]
        },
        "id": 146
      },
            {
        "value":         {
          "start": 25635,
          "end": 25637,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 25741,
          "end": 25749,
          "text": "DialogWAE",
          "labels": ["Method"]
        },
        "id": 147
      },
            {
        "value":         {
          "start": 25806,
          "end": 25811,
          "text": "iVAEMI",
          "labels": ["Method"]
        },
        "id": 148
      },
            {
        "value":         {
          "start": 25839,
          "end": 25849,
          "text": "SpaceFusion",
          "labels": ["Method"]
        },
        "id": 148
      },
            {
        "value":         {
          "start": 26079,
          "end": 26081,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 26551,
          "end": 26559,
          "text": "diversity",
          "labels": ["Metric"]
        },
        "id": 149
      },
            {
        "value":         {
          "start": 26565,
          "end": 26571,
          "text": "fluency",
          "labels": ["Metric"]
        },
        "id": 150
      }
    ],
    "data": {"text": "PLATO: Pre-trained Dialogue Generation Model with Discrete Latent Variable Abstract Pre-training models have been proved effective for a wide range of natural language processing tasks. Inspired by this, we propose a novel dialogue generation pre-training framework to support various kinds of conversations, including chit-chat, knowledge grounded dialogues, and conversational question answering. In this framework , we adopt flexible attention mechanisms to fully leverage the bi-directional context and the uni-directional characteristic of language generation . We also introduce discrete latent variables to tackle the inherent one-to-many mapping problem in response generation. Two reciprocal tasks of response generation and latent act recognition are designed and carried out simultaneously within a shared network. Comprehensive experiments on three publicly available datasets verify the effectiveness and superiority of the proposed framework. 1 Introduction Dialogue generation is a challenging task due to the limited corpus of human conversations, complex background knowledge, and diverse relationships between utterances. Recently , pre-trained large-scale language models , such as BERT ( Devlin et al . , 2019 ) and XLNet ( Yang et al . , 2019 ) , have achieved prominent success in natural language processing . Such models are usually constructed based on a massive scale of general text corpora , like English Wikipedia or BooksCorpus ( Zhu et al . , 2015 ) , where distributed representations can be learned automatically from the raw text . With these representations being fine-tuned, breakthroughs have been continuously reported for various downstream tasks, especially those on natural language understanding, such as question answering, natural language inference, and so on. This pre-training and fine-tuning paradigm also sheds light on the tasks of natural language generation, like dialogue generation. However , the previous study demonstrates that there are some deficiencies in performance while directly fine-tuning BERT on small conversation datasets ( Rashkin et al . , 2019 ; Wolf et al . , 2019 ) . Possible reasons are three-fold : 1 ) the underlying linguistic patterns in human conversations can be highly different from those in general text , which suggests a potentially large gap in knowledge or data distribution ; 2 ) the training mode of uni-directional dialogue generation is also distinct from that of bi-directional natural language understating as applied in BERT ; 3 ) unlike most of the general NLP tasks , there exists a one-to-many relationship in dialogue generation , where the dialogue context may correspond to multiple appropriate replies . In this paper, we propose a new method to tackle the above challenges, aiming to obtain a high-quality pre-training model for dialogue generation. First of all , to reduce the gap between data distributions , large-scale Reddit and Twitter conversations are utilized to further pre-train the generation model ( upon the basis of language models pre-trained with general text ) . Secondly, to mitigate the difference in training mode, a flexible paradigm integrating uni- and bi-directional processing is employed in this work, which is inspired by the latest unified language modeling ( Dong et al., 2019 ). Thirdly, a discrete latent variable is introduced to model the one-to-many relationship among utterances in conversations. Each value of the latent variable corresponds to the particular conversational intent of one response, which is referred as latent speech act. Distinct with those controllable dialogue generation based on explicit labels ( including emotion, keywords, domain codes, and so on ) ( Huang et al., 2018; Keskar et al., 2019 ), our latent variable gets exempted from the restriction of human annotations and can be learned automatically from the corpus in an unsupervised way. In the pre-training of dialogue generation, response generation and latent act recognition are carried out simultaneously within a shared network. Based on the context and latent variable, the generation task tries to maximize the likelihood of the target response. Meanwhile, the recognition task aims to estimate the latent variable w.r.t. the given context and target response. Apparently, the accurate recognition of the latent variable is a crucial factor in boosting the quality of response generation. We conducted experiments on three different kinds of conversation tasks: chit-chat, knowledge grounded conversation, and conversational question answering. Experimental results verify the effectiveness and superiority of our pre-trained model as compared with the other state-of-the-art methods. Our pre-trained models and source code have been released at GitHub, hoping to facilitate further research progress in dialogue generation.1 2 Dialogue Generation Pre-training Given a piece of context, there exist multiple appropriate responses, leading to diverse conversation flows. It is widely recognized that the capability of modeling one-to-many relationship is crucial for the dialogue generation system ( Zhao et al., 2017; Chen et al., 2019 ). To this end, we propose to encode discrete latent variables into transformer blocks for one-to-many relationship modeling, where two reciprocal tasks of response generation and latent act recognition are collaboratively carried out. 2.1 Model Architecture In our model, there are three elements: dialogue context c, response r and latent variable z. The dialogue context c consists of several history utterances. ( For knowledge grounded conversation, it is conventional to concatenate background knowledge into the context as well ( Wolf et al., 2019 )? ) The response r is one piece of appropriate reply towards the given context. The latent variable z is one K-way categorical variable z ∈ [1,K], with each value corresponding to a particular latent speech act in the response. The probabilistic relationships among these elements are elaborated with the graphical model in Figure 1. Given a context c, there are multi-ple latent speech acts which can be taken as response intents ( represented by the latent variable z ). Conditioned on the context and one selected latent speech act, the response is generated as p( r|c, z ) ( gray lines ). Given a pair of context and response, the underlying latent speech act can be estimated as p( z|c, r ) ( dashed blue lines ). As such, our pretraining of dialogue generation contains the following two tasks – response generation and latent act recognition. We propose a unified infrastructure for the joint learning of both tasks, shown as Figure 2. The backbone of our infrastructure is inspired by the transformer blocks in ( Dong et al., 2019 ), which supports both bi-directional encoding and uni-directional decoding flexibly via specific selfattention masks. Both response generation and latent act recognition are carried out under the unified network with shared parameters. Their detailed implementations are described as follows. Given the context c and a specific speech act z, the response generation can be estimated as where T is the length of the target response r and r<t denotes previously generated words. Since the response generation is a uni-directional decoding process, each token in the response only attends to those before it, shown as dashed orange lines in Figure 2. The latent act recognition task is included to identify the corresponding value of z for the given context and the target response in the training data. The latent act recognition shares network parameters with response generation, but has a separate self-attention mask for bi-directional encoding. As shown in Figure 2, with a special mask symbol [M] as input, it keeps collecting information from the context and target response ( red lines ). In this way, the corresponding speech act for the target response can be recognized as z ∼ p( z|c, r ), where p( z|c, r ) is the estimated posterior distribution over discrete latent values. 2.2 Input Representation For multi-turn conversation modeling, elaborate designs have been made on the input representation in this work. For each token, its input embedding is the sum of corresponding token, role, turn and position embeddings. One visual example is shown in Figure 3 and details are described in the following. The input is the concatenation of latent variable, dialogue context and response. Following the pre-processing of BERT ( Devlin et al . , 2019 ) , the input text is tokenized with WordPiece ( Wu et al . , 2016 ) . A special end-of-utterance [EOU] token is appended to the end of each utterance for separation. Another begin-of-utterance [BOU] token is added at the beginning of the response, whose final hidden state ( i.e., output of the last transformer block ) is used to predict next token during generation. Given that z is one K-way categorical variable, its token embedding E[z] is mapped from the latent embedding space Ez ∈ RK×D. For the rest tokens in the vocabulary , they are initialized using BERT ’ s WordPiece embeddings . Role embeddings are employed to differentiate the characters evolved in the conversation. The role embedding EA is added for the response, as well as dialogue utterances generated by the same character in the context. And role embedding EB is used for the other character. ( For knowledge grounded conversation,EC is used as the role embedding of background knowledge? ) In the interactive conversation, there are multi-turn utterances and we employ relative order in the assignment of turn embeddings. The turn embedding for the response is set to E[0], and the turn embedding of its last utterance is E[−1], and etc. Our utilization of relative turn embeddings instead of absolute ones enables the model to assign turn embedding E[0] to the response consistently and makes response generation exempt from the disturbance of its round number within the dialogue. Position embeddings are added according to the token position in each utterance. Note that for the special token of latent variable, its corresponding role, turn and position embeddings are all set to empty. 2.3 Pre-training Objectives We employ three loss functions in dialogue generation pre-training: negative log-likelihood ( NLL ) loss, bag-of-words ( BOW ) loss and response selection ( RS ) loss. Brief illustration is shown in the last column of Figure 2 and detailed descriptions will be provided in this section. 2.3.1 Response Generation In our model, the response is generated conditioned on the latent variable and the context. The widely adopted NLL loss is embraced in the pre-training: where z is the latent speech act of this training pair ( c, r ), sampled from the probability distribution p( z|c, r ). The posterior distribution over latent values is estimated through the task of latent act recognition: where h[M ] ∈ RD is the final hidden state of the special mask, W1 ∈ RK×D and b1 ∈ RK denote the weight matrices of one fully-connected layer. Besides the classical NLL loss, the bag-of-words loss ( Zhao et al., 2017 ) is also employed to facilitate the training process of latent discrete variables: where V refers to the whole vocabulary. The function f tries to predict the words within the target response in a non-autoregressive way: where hz is the final hidden state of the latent variable and |V | is the vocabulary size. frt denotes the estimated probability of word rt. As compared with NLL loss, the BOW loss discards the order of words and forces the latent variable to capture the global information of the target response. 2.3.2 Response Selection Response selection helps distinguish whether the response is relevant with the dialogue context and consistent with the background knowledge. Meanwhile, its score can be regarded as an indicator of coherence during inference, helping to select the most coherent one from multiple candidate responses. Particularly, the training of response selection is carried out together with the bi-directional encoding of latent act recognition. The positive training samples come from the dialogue context and corresponding target response ( c, r ), with label lr = 1. And the negative samples are created by randomly selecting responses from the corpus ( c, r− ), with label lr− = 0. The binary cross-entropy loss of response selection is defined as follows: The above probability is estimated through one fully-connected layer, with the final hidden state of the special mask fed as input: To sum up, the total objective of our pre-training model is to minimize the integrated loss: 2.4 Pre-training Procedure Our pre-training model contains 12 transformer blocks , with network parameters initialized using BERTBASE . Large-scale conversation datasets – Twitter ( Cho et al . , 2014 ) and Reddit ( Zhou et al . , 2018 ; Galley et al . , 2019 ) are employed for pretraining , which results in 8.3 million training samples in total . For each training sample of context and target response ( c, r ), it needs to pass through the network twice to accomplish the tasks of latent act recognition and response generation. And the pre-training steps are summarized as follows: 1 ) Latent Act Recognition – Given a pair of context and target response, estimate the posterior distribution p( z|c, r ) – Randomly select r− and calculate LRS 2 ) Response Generation – With the sampled latent value z ∼ p( z|c, r ), calculate LNLL and LBOW 3 ) Optimization – Sum up to obtain L, and update network parameters with back-propagation The hyper-parameters used in pre-training are listed as follows. The maximum sequence length of context and response is set to 256 and 50, respectively. The number of transformer blocks in our model L is 12 and the hidden embedding dimension D is 768. The batch size is set to 64 and K is set to 20 for the discrete latent variable. Adam optimizer ( Kingma and Ba , 2015 ) is employed for optimization with a learning rate of 5e - 5 . The pretraining of dialogue generation was carried out on 8 Nvidia Telsa V100 32G GPU cards for 3.5M steps, taking about two weeks to reach convergence. 2.5 Fine-tuning and Inference Our pre-trained model is flexible enough to support various kinds of dialogues, including chit-chat, knowledge grounded conversation, conversational question answering, etc. The fine-tuning on small conversation datasets can be carried out by following the training objectives defined in Equation ( 8 ). As the fine-tuning process reaches convergence, the response towards the given context can be obtained through the following inference procedure: 1 ) Candidate Response Generation – Conditioned on each latent value z ∈ [1,K], generate corresponding candidate response r. 2 ) Response Selection – Calculate the probability for each response p( lr = 1|c, r ) and select the one with highest coherence value as the final response. It is worth noting that the above fine-tuning and inference procedures are set up for the dialogue generation without any specific objectives. If there exists a specific objective within the conversation , such as letting both participants know more about each other ( Bao et al . , 2019 ) , the fine-tuning can proceed to maximize the pre-defined rewards with reinforcement learning ( RL ) . Under such circumstances , our latent discrete variable can be naturally treated as action within RL , and thus the response selection can be straightforwardly solved by selecting the action that results in the maximum reward . 3 Experiments 3.1 Settings 3.1.1 Datasets To evaluate the performance of our proposed method, comprehensive experiments have been carried out on three publicly available datasets. Persona-Chat ( Zhang et al . , 2018 ) is a knowledge grounded conversation dataset . It provides both manually annotated conversations and corresponding persona profiles ( background knowledge ), where two participants chat naturally and try to get to know each other. Daily Dialog ( Li et al . , 2017 ) is a chit-chat dataset , which contains high-quality human conversations about daily life . DSTC7 - AVSD ( Alamri et al . , 2019 ) , short for Audio Visual Scene-aware Dialog of the DSTC7 challenge , is a conversational question answering dataset . In DSTC7 - AVSD , the system need to generate an answer given dialogue context and background knowledge . There are two available options of knowledge utilization: 1 ) using singlemodal information of text only, including video’s caption and summary; 2 ) relying on multi-modal information, including text, audio and visual features. The single-modal option is adopted by our method in the experiments. The descriptions and statistics of these datasets are summarized in Table 1. 3.1.2 Compared Methods The following models have been compared in the experiments. Baseline. Sequence to sequence with attention ( Seq2Seq ) ( Vinyals and Le , 2015 ) is employed as the baseline for the experiments on Persona-Chat and Daily Dialog . DSTC7 - AVSD has provided a baseline system , which is built upon hierarchical recurrent encoders with multi-modal features . State of the art. Persona-Chat was also utilized in the ConvAI2 challenge ( Dinan et al . , 2019a ) , where the team of Lost in Conversation ( LIC ) ( Golovanov et al . , 2019 ) obtains the best performance . LIC is also one transformer based generation method and fine-tuned upon the pre-trained model of GPT ( Radford et al . , 2018 ) . For the dataset of Daily Dialog , its best results are reported by the recently developed method – iVAEMI ( Fang et al . , 2019 ) , which generates diverse responses with sample-based latent representation . In DSTC7 - AVSD , the team of CMU ( Sanabria et al . , 2019 ) obtains the best performance across all the evaluation metrics . Our method. To better analyze the effects of our latent discrete variable, we also compare to the version without latent variable ( Our w/o Latent ).2 3.1.3 Evaluation Metrics Both automatic and human evaluations are employed to assess the performance of compared methods. In automatic evaluation, the following metrics are included: BLEU ( Chen and Cherry , 2014 ) measures the n-gram overlap between generated response and the target response . Distinct - 1 / 2 ( Li et al . , 2016 ) measures the generation diversity , which is defined as the number of distinct uni - or bi-grams divided by the total amount of generated words . Knowledge Recall / Precision / F1 ( Dinan et al . , 2019b ) measures the degree of informativeness w.r.t. background knowledge. In DSTC7 - AVSD , the MSCOCO platform ( Chen et al . , 2015 ) is employed for evaluation . It compares the generated response with six ground truth responses , using metrics of BLEU , ME-TEOR , ROUGH-L and CIDEr . In human evaluation, we randomly select 100 dialogue contexts and generate responses with compared methods. Three crowd-sourcing workers are asked to score the response quality on a scale of [ 0 , 1 , 2 ] from four aspects – fluency , coherence , informativeness and overall . The higher score, the better. Details about the criteria are given as follows. Fluency measures whether the generated sentence is smooth and grammatically correct . Coherence evaluates whether the generated response is relevant with the dialogue context and consistent with the expressed information or background knowledge . Informativeness assesses whether the response is informative or not . Overall represents the general evaluation, where 0 indicates a bad response, 1 refers to a normal response and 2 stands for a good response. After collecting the assessments from annotators, the response’s final score is determined via majority voting. The average Fleiss ’ s kappa ( Fleiss and Cohen , 1973 ) on Persona-Chat and Daily Dialog is 0.515 and 0.480 respectively , indicating annotators have reached moderate agreement . 3.2 Experimental Results The experimental results on Persona-Chat and Daily Dialog with automatic and human evaluations are summarized in Table 2 . As suggested in the empirical study ( Liu et al., 2016 ), the correlation between automatic metrics and human judgments is weak in open-domain dialogue generation. In the automatic evaluation, experimental results demonstrate that no method can consistently outperform the others. During human evaluations , our method achieves better performance consistently across all the metrics on Persona-Chat and Daily Dialog . The scores of fluency almost approach the upper bound , revealing that our generated responses are very fluent . The informativeness assessments indicate that the information in our generated responses is significantly richer , as compared with the baseline methods . Our responses are coherent with the context and favored most by crowd-sourcing workers. The ablation study with our method and our w/o latent also suggests that through the incorporation of discrete latent variables, remarkable improvements can be achieved for dialogue generation. In addition , it can be observed that the generation quality of transformed-based approaches ( LIC and our method ) is significantly better than that of RNN-based methods ( Seq2Seq and iVAEMI ) . The experimental results on DSTC7 - AVSD with automatic evaluation are provided in Table 3 . In the experiments, our response selection is strengthened with an extra ranking step, which learns to rank the candidates according to automatic scores and selects the top one as the final answer. The results in Table 3 demonstrate that our method has brought a new breakthrough for DSTC7 - AVSD . Additionally, the upper bound of our method is also reported, under the ideal scenario that the optimal candidate answer can be selected.4 The incredible results validate the great potential of our approach. 3.3 Discussions 3.3.1 Case Analysis To further dissect the quality of our pre-trained model, several examples of generated responses are provided in Table 4. For each piece of context, our model can produce multiple responses by assigning distinct values to the latent variable and five candidate responses are selected for display in the table. It shows that our pre-trained model is able to generate diverse and appropriate responses. More examples on the conversational datasets are provided in the Appendix. 3.3.2 Comparison of Pre-trained Models To further analyze the effectiveness of our pretrained model , more ablation studies have been conducted on Persona-Chat . Distinct pre-trained models are included for comparison. To be fair, their transformer layers are all set to 12. There are three different sizes of training dialogues: 1k, 5k and 9k ( all training data ). The training configurations and experimental results measured with perplexity are summarized in Table 5. There are three groups of pre-trained models : group 1 applies direct fine-tuning of BERT or GPT - 2 ( Radford et al . , 2019 ) on Persona-Chat ; group 2 employs Twitter and Reddit for further training upon the basis of pretrained language models ; group 3 carries out the training process with latent variable . ( Model 2.2 is our w/o latent one and model 3.1 is our method? ) These results demonstrate that our method outperforms the other pre-trained models consistently with lower perplexity across different training sets. Several interesting conclusions can be also drawn from these results. Firstly, the comparison between model 1.2 and model 1.3 encourages the adoption of flexible attention mechanism to fully leverage the bi-directional context information.6 Secondly , the superiority of group 2 over group 1 mainly comes from the employment of Twitter and Reddit , which are closer to human conversations than general text . Thirdly, the comparison between model 2.2 and model 3.1 reflects that the incorporation of discrete latent variable is able to boost the quality of response generation, whose effects have also been verified in Table 2. 4 Related Work Related work involves pre-trained language models and one-to-many modeling in dialogue generation. Pre-trained Language Models. Pre-trained language models, which are trained on massive general text, have brought many breakthroughs on various NLP tasks. These models can be roughly divided into two categories according to their attention mechanisms . GPT ( Radford et al . , 2018 ) and GPT - 2 ( Radford et al . , 2019 ) are representative unidirectional language models , where one token is only allowed to attend its previous tokens and the objective is to maximize left-to-right generation likelihood . BERT ( Devlin et al . , 2019 ) and XLNet ( Yang et al . , 2019 ) are bi-directional language models , where bi-directional context attention is enabled for token prediction . The latest unified language model UniLM ( Dong et al . , 2019 ) is able to support both uni - and bi-directional attention with flexible self-attention mask designs . Recently , some attempts ( Golovanov et al . , 2019 ; Wolf et al . , 2019 ; Zhang et al . , 2019 ) have been made to adapt generative language models GPT or GPT - 2 for dialogue generation . Whereas the special issues of conversations, such as impacts from background knowledge and problems of one-to-many relationship, are not fully considered and tackled in these adaptations. One-to-many Modeling. Given one piece of context, there exists multiple appropriate responses, which is know as the one-to-many mapping problem. To model this one-to-many relationship , CVAE ( Zhao et al . , 2017 ) employs Gaussian distribution to capture the discourse-level variations of responses . To alleviate the issue of posterior collapse in VAE , some extension approaches are further developed , including conditional Wasserstein auto-encoder of DialogWAE ( Gu et al . , 2019 ) and implicit feature learning of iVAEMI ( Fang et al . , 2019 ) . SpaceFusion ( Gao et al . , 2019 ) aims to jointly optimize diversity and relevance in the latent space , which are roughly matched by the distance and direction from the predicted response vector . Besides the continuous representation in VAE , discrete categorical variables are also utilized for interpretable generation ( Zhao et al . , 2018 ) . Additionally, multiple mapping modules as latent mechanisms are introduced for diverse generation ( Chen et al., 2019 ), where accurate optimization is carried out via posterior mapping selection. However , due to the small scale of annotated conversation data and limited capacity of generation network , it remains challenging for these methods to balance the diversity and fluency during response generation . 5 Conclusion A novel pre-training model for dialogue generation is introduced in this paper, incorporated with latent discrete variables for one-to-many relationship modeling. To pre-train our model, two reciprocal tasks of response generation and latent recognition are carried out simultaneously on large-scale conversation datasets. Our pre-trained model is flexible enough to handle various down-stream tasks of dialogue generation. Extensive and intensive experiments have been carried out on three different kinds of publicly available datasets. And the results demonstrate that our model obtains significant improvements over the other state-of-the-art methods. Our work can be potentially improved with more fine-grained latent variables. In the future, we will also explore to boost the latent selection policy with reinforcement learning and extend our pre-training to support dialogue generation in other languages. "}
  },
    {
    "id": "P01-1002",
    "result":     [
            {
        "value":         {
          "start": 5900,
          "end": 5925,
          "text": "audio stream mixture model",
          "labels": ["Method"]
        },
        "id": 150
      },
            {
        "value":         {
          "start": 7938,
          "end": 7966,
          "text": "hidden Markov models ( HMMs )",
          "labels": ["Method"]
        },
        "id": 151
      },
            {
        "value":         {
          "start": 9826,
          "end": 9828,
          "text": "LDC",
          "labels": ["Dataset"]
        },
        "id": 298
      },
            {
        "value":         {
          "start": 11667,
          "end": 11683,
          "text": "Porters algorithm",
          "labels": ["Method"]
        },
        "id": 153
      },
            {
        "value":         {
          "start": 14191,
          "end": 14196,
          "text": "TF IDF",
          "labels": ["Method"]
        },
        "id": 154
      },
            {
        "value":         {
          "start": 15286,
          "end": 15315,
          "text": "mean average precision ( MAP )",
          "labels": ["Metric"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 19140,
          "end": 19142,
          "text": "MAP",
          "labels": ["Metric"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 19618,
          "end": 19639,
          "text": "Mean average precision",
          "labels": ["Metric"]
        },
        "id": 158
      },
            {
        "value":         {
          "start": 20069,
          "end": 20090,
          "text": "mean average precision",
          "labels": ["Metric"]
        },
        "id": 158
      }
    ],
    "data": {"text": "Processing Broadcast Audio for Information Access Abstract This paper addresses recent progress in speaker-independent , large vocabulary , continuous speech recognition , which has opened up a wide range of near and mid-term applications . One rapidly expanding application area is the processing of broadcast audio for information access . At LIMSI , broadcast news transcription systems have been developed for English , French , German , Mandarin and Portuguese , and systems for other languages are under development . Audio indexation must take into account the specificities of audio data , such as needing to deal with the continuous data stream and an imperfect word transcription . Some near-term applications areas are audio data mining , selective dissemination of information and media monitoring . 1 Introduction A major advance in speech processing technology is the ability of todays systems to deal with nonhomogeneous data as is exemplified by broadcast data . With the rapid expansion of different media sources , there is a pressing need for automatic processing of such audio streams . Broadcast audio is challenging as it contains segments of various acoustic and linguistic natures , which require appropriate modeling . A special section in the Communications of the ACM devoted to News on Demand ( Maybury , 2000 ) includes contributions from many of the sites carrying out active research in this area . Via speech recognition , spoken document retrieval ( SDR ) can support random access to relevant portions of audio documents , reducing the time needed to identify recordings in large multimedia databases . The TREC ( Text REtrieval Conference ) SDR evaluation showed that only small differences in information retrieval performance are observed for automatic and manual transcriptions ( Garofolo et al. , 2000 ) . Large vocabulary continuous speech recognition ( LVCSR ) is a key technology that can be used to enable content-based information access in audio and video documents . Since most of the linguistic information is encoded in the audio channel of video data , which once transcribed can be accessed using text-based tools . This research has been carried out in a multilingual environment in the context of several recent and ongoing European projects . We highlight recent progress in LVCSR and describe some of our work in developing a system for processing broadcast audio for information access . The system has two main components , the speech transcription component and the information retrieval component . Versions of the LIMSI broadcast news transcription system have been developed in American English , French , German , Mandarin and Portuguese . 2 Progress in LVCSR Substantial advances in speech recognition technology have been achieved during the last decade . Only a few years ago speech recognition was primarily associated with small vocabulary isolated word recognition and with speaker-dependent ( often also domain-specific ) dictation systems . The same core technology serves as the basis for a range of applications such as voice-interactive database access or limited-domain dictation , as well as more demanding tasks such as the transcription of broadcast data . With the exception of the inherent variability of telephone channels , for most applications it is reasonable to assume that the speech is produced in relatively stable environmental and in some cases is spoken with the purpose of being recognized by the machine . The ability of systems to deal with nonhomogeneous data as is found in broadcast audio ( changing speakers , languages , backgrounds , topics ) has been enabled by advances in a variety of areas including techniques for robust signal processing and normalization ; improved training techniques which can take advantage of very large audio and textual corpora ; algorithms for audio segmentation ; unsupervised acoustic model adaptation ; efficient decoding with long span language models ; ability to use much larger vocabularies than in the past - 64 k words or more is common to reduce errors due to out-of-vocabulary words . With the rapid expansion of different media sources for information dissemination including via the internet , there is a pressing need for automatic processing of the audio data stream . The vast majority of audio and video documents that are produced and broadcast do not have associated annotations for indexation and retrieval purposes , and since most of todays annotation methods require substantial manual intervention , and the cost is too large to treat the ever increasing volume of documents . Broadcast audio is challenging to process as it contains segments of various acoustic and linguistic natures , which require appropriate modeling . Transcribing such data requires significantly higher processing power than what is needed to transcribe read speech data in a controlled environment , such as for speaker adapted dictation . Although it is usually assumed that processing time is not a major issue since computer power has been increasing continuously , it is also known that the amount of data appearing on information channels is increasing at a close rate . Therefore processing time is an important factor in making a speech transcription system viable for audio data mining and other related applications . Transcription word error rates of about 20 % have been reported for unrestricted broadcast news data in several languages . As shown in Figure 1 the LIMSI broadcast news transcription system for automatic indexation consists of an audio partitioner and a speech recognizer . 3 Audio partitioning The goal of audio partitioning is to divide the acoustic signal into homogeneous segments , labeling and structuring the acoustic content of the data , and identifying and removing non-speech segments . The LIMSI BN audio partitioner relies on an audio stream mixture model ( Gauvain et al . , 1998 ) . While it is possible to transcribe the continuous stream of audio data without any prior segmentation , partitioning offers several advantages over this straight-forward solution . First , in addition to the transcription of what was said , other interesting information can be extracted such as the division into speaker turns and the speaker identities , and background acoustic conditions . This information can be used both directly and indirectly for indexation and retrieval purposes . Second , by clustering segments from the same speaker , acoustic model adaptation can be carried out on a per cluster basis , as opposed to on a single segment basis , thus providing more adaptation data . Third , prior segmentation can avoid problems caused by linguistic discontinuity at speaker changes . Fourth , by using acoustic models trained on particular acoustic conditions ( such as wide-band or telephone band ) , overall performance can be significantly improved . Finally , eliminating non-speech segments substantially reduces the computation time . The result of the partitioning process is a set of speech segments usually corresponding to speaker turns with speaker , gender and telephone/wide-band labels ( see Figure 2 ) . 4 Transcription of Broadcast News For each speech segment , the word recognizer determines the sequence of words in the segment , associating start and end times and an optional confidence measure with each word . The LIMSI system , in common with most of todays state-ofthe-art systems , makes use of statistical models of speech generation . From this point of view , message generation is represented by a language model which provides an estimate of the probability of any given word string , and the encoding of the message in the acoustic signal is represented by a probability density function . The speakerindependent 65k word , continuous speech recognizer makes use of 4 - gram statistics for language modeling and of continuous density hidden Markov models ( HMMs ) with Gaussian mixtures for acoustic modeling . Each word is represented by one or more sequences of context-dependent phone models as determined by its pronunciation . The acoustic and language models are trained on large , representative corpora for each task and language . Processing time is an important factor in making a speech transcription system viable for automatic indexation of radio and television broadcasts . For many applications there are limitations on the response time and the available computational resources , which in turn can significantly affect the design of the acoustic and language models . Word recognition is carried out in one or more decoding passes with more accurate acoustic and language models used in successive passes . A 4-gram single pass dynamic network decoder has been developed ( Gauvain and Lamel , 2000 ) which can achieve faster than real-time decoding with a word error under 30 % , running in less than 100 Mb of memory on widely available platforms such Pentium III or Alpha machines . 5 Multilinguality A characteristic of the broadcast news domain is that , at least for what concerns major news events , similar topics are simultaneously covered in different emissions and in different countries and languages . Automatic processing carried out on contemporaneous data sources in different languages can serve for multi-lingual indexation and retrieval . Multilinguality is thus of particular interest for media watch applications , where news may first break in another country or language . At LIMSI broadcast news transcription systems have been developed for the American English , French , German , Mandarin and Portuguese languages . The Mandarin language was chosen because it is quite different from the other languages ( tone and syllable-based ) , and Mandarin resources are available via the LDC as well as reference performance results . Our system and other state-of-the-art systems can transcribe unrestricted American English broadcast news data with word error rates under 20 % . Our transcription systems for French and German have comparable error rates for news broadcasts ( Adda-Decker et al. , 2000 ) . The character error rate for Mandarin is also about 20 % ( Chen et al. , 2000 ) . Based on our experience , it appears that with appropriately trained models , recognizer performance is more dependent upon the type and source of data , than on the language . For example , documentaries are particularly challenging to transcribe , as the audio quality is often not very high , and there is a large proportion of voice over . 6 Spoken Document Retrieval The automatically generated partition and word transcription can be used for indexation and information retrieval purposes . Techniques commonly applied to automatic text indexation can be applied to the automatic transcriptions of the broadcast news radio and TV documents . These techniques are based on document term frequencies , where the terms are obtained after standard text processing , such as text normalization , tokenization , stopping and stemming . Most of these preprocessing steps are the same as those used to prepare the texts for training the speech recognizer language models . While this offers advantages for speech recognition , it can lead to IR errors . For better IR results , some words sequences corresponding to acronymns , multiword namedentities ( e.g. Los Angeles ) , and words preceded by some particular prefixes ( anti , co , bi , counter ) are rewritten as a single word . Stemming is used to reduce the number of lexical items for a given word sense . The stemming lexicon contains about 32000 entries and was constructed using Porters algorithm ( Porter80 , 1980 ) on the most frequent words in the collection , and then manually corrected . The information retrieval system relies on a un broadcasted on April 11 , 1998 at 4 pm . The output includes the partitioning and transcription results . To improve readability , word time stamps are given only for the first 6 words . Non speech segments have been removed and the following information is provided for each speech segment : signal bandwidth ( telephone or wideband ) , speaker gender , and speaker identity ( within the show ) . it is a day of final farewells in alabama the first funerals for victims of this weeks tornadoes are being held today along with causing massive property damage the twisters killed thirty three people in alabama five in georgia and one each in mississippi and north carolina the national weather service says the tornado that hit jefferson county in alabama had winds of more than two hundred sixty miles per hour authorities speculated was the most powerful tornado ever to hit the southeast twisters destroyed two churches to fire stations and a school parishioners were in one church when the tornado struck / segment segment type = wideband gender = female spkr = 2 stime = 88.37 etime = 104.86 at one point when the table came onto my back i thought yes this is it im ready ready protects protect the children because the children screaming the children were screaming they were screaming in prayer that were screaming god help us / segment segment type = wideband gender = female spkr = 1 stime = 104.86 etime = 132.37 vice president al gore toured the area yesterday he called it the worst tornado devastation hes ever seen we will have a complete look at the weather across the u. s. in our extended weather forecast in six minutes / segment ... segment type = wideband gender = male spkr = 19 stime = 1635.60 etime = 1645.71 so if their computing systems dont tackle this problem well we have a potential business disruption and either erroneous deliveries or misdeliveries or whatever savvy businesses are preparing now so the january first two thousand would just be another day on the town not a day when fast food and everything else slows down rick lockridge c.n.n. igram model per story . The score of a story is obtained by summing the query term weights which are simply the log probabilities of the terms given the story model once interpolated with a general English model . This term weighting has been shown to perform as well as the popular TF IDF weighting scheme ( Hiemstra and Wessel , 1998 ; Miller et al . , 1998 ; Ng , 1999 ; Spark Jones et al . , 1998 ) . The text of the query may or may not include the index terms associated with relevant documents . One way to cope with this problem is to use query expansion ( Blind Relevance Feedback , BRF ( Walker and de Vere , 1990 ) ) based on terms present in retrieved contemporary texts . The system was evaluated in the TREC SDR track , with known story boundaries . The SDR data collection contains 557 hours of broadcast news from the period of February through June 1998 . This data includes 21750 stories and a set of 50 queries with the associated relevance judgments ( Garofolo et al. , 2000 ) . In order to assess the effect of the recognition time on the information retrieval results we transcribed the 557 hours of broadcast news data using two decoder configurations : a single pass 1.4 xRT system and a three pass 10xRT system . The word error rates are measured on a 10h test subset ( Garofolo et al. , 2000 ) . The information retrieval results are given in terms of mean average precision ( MAP ) , as is done for the TREC benchmarks in Table 1 with and without query expansion . For comparison , results are also given for manually produced closed captions . With query expansion comparable IR results are obtained using the closed captions and the 10xRT transcriptions , and a moderate degradation ( 4 % absolute ) is observed using the 1.4 xRT transcriptions . 7 Locating Story Boundaries The broadcast news transcription system also provides non-lexical information along with the word transcription . This information is available in the partition of the audio track , which identifies speaker turns . It is interesting to see whether or not such information can be used to help locate story boundaries , since in the general case these are not known . Statistics were made on 100 hours of radio and television broadcast news with manual transcriptions including the speaker identities . Of the 2096 sections manually marked as reports ( considered stories ) , 40 % start without a manually annotated speaker change . This means that using only speaker change information for detecting document boundaries would miss 40 % of the boundaries . With automatically detected speaker changes , the number of missed boundaries would certainly increase . At the same time , 11,160 of the 12,439 speaker turns occur in the middle of a document , resulting in a false alarm rate of almost 90 % . A more detailed analysis shows that about 50 % of the sections involve a single speaker , but that the distribution of the number of speaker turns per section falls off very gradually ( see Figure 3 ) . False alarms are not as harmful as missed detections , since it may be possible to merge adjacent turns into a single document in subsequent processing . These results show that even perfect speaker turn boundaries can not be used as the primary cue for locating document boundaries . They can , however , be used to refine the placement of a document boundary located near a speaker change . We also investigated using simple statistics on the durations of the documents . A histogram of the 2096 sections is shown in Figure 4 . One third of the sections are shorter than 30 seconds . The histogram has a bimodal distribution with a sharp peak around 20 seconds , and a smaller , flat peak around 2 minutes . Very short documents are typical of headlines which are uttered by single speaker , whereas longer documents are more likely to contain data from multiple talkers . This distribution led us to consider using a multi-scale segmentation of the audio stream into documents . Similar statistics were measured on the larger corpus ( Figure 4 bottom ) . As proposed in ( Abberley et al. , 1999 ; Johnson et al. , 1999 ) , we segment the audio stream into overlapping documents of a fixed duration . As a result of optimization , we chose a 30 second window duration with a 15 second overlap . Since there are many stories significantly shorter than 30s in broadcast shows ( see Figure 4 ) we conjunctured that it may be of interest to use a double windowing system in order to better target short stories ( Gauvain et al. , 2000 ) . The window size of the smaller window was selected to be 10 seconds . So for each query , we independently retrieved two sets of documents , one set for each window size . Then for each document set , document recombination is done by merging overlapping documents until no further merges are possible . The score of a combined document is set to maximum score of any one of the components . For each document derived from the 30s windows , we produce a time stamp located at the center point of the document . However , if any smaller documents are embedded in this document , we take the center of the best scoring document . This way we try to take advantage of both window sizes . The MAP using a single 30s window and the double windowing strategy are shown in Table 2 . For comparison , the IR results using the manual story segmentation and the speaker turns located by the audio partitioner are also given . All conditions use the same word hypotheses obtained with a speech recognizer which had no knowledge about the story boundaries . manual segmentation ( NIST ) 59.6 % audio partitioner 33.3 % single window ( 30s ) 50.0 % double window 52.3 % Table 2 : Mean average precision with manual and automatically determined story boundaries . The document collection contains 557 hours of broadcast news from the period of February through June 1998 . ( 21750 stories , 50 queries with the associated relevance judgments . ) From these results we can clearly see the interest of using a search engine specifically designed to retrieve stories in the audio stream . Using an a priori acoustic segmentation , the mean average precision is significantly reduced compared to a perfect manual segmentation , whereas the window-based search engine results are much closer . Note that in the manual segmentation all non-story segments such as advertising have been removed . This reduces the risk of having out-oftopic hits and explains part of the difference between this condition and the other conditions . The problem of locating story boundaries is being further pursued in the context of the ALERT project , where one of the goals is to identify documents given topic profiles . This project is investigating the combined use of audio and video segmentation to more accurately locate document boundaries in the continuous data stream . 8 Recent Research Projects The work presented in this paper has benefited from a variety of research projects both at the European and National levels . These collaborative efforts have enabled access to real-world data allowing us to develop algorithms and models wellsuited for near-term applications . The European project LE-4 OLIVE : A Multilingual Indexing Tool for Broadcast Material Based on Speech Recognition ( http://twentyone.tpd.tno.nl/ olive / ) addressed methods to automate the disclosure of the information content of broadcast data thus allowing content-based indexation . Speech recognition was used to produce a time-linked transcript of the audio channel of a broadcast , which was then used to produce a concept index for retrieval . Broadcast news transcription systems for French and German were developed . The French data come from a variety of television news shows and radio stations . The German data consist of TV news and documentaries from ARTE . OLIVE also developed tools for users to query the database , as well as cross-lingual access based on off-line machine translation of the archived documents , and online query translation . The European project IST ALERT : Alert system for selective dissemination ( http://www.fb9ti.uni-duisburg.de/alert ) aims to associate stateof-the-art speech recognition with audio and video segmentation and automatic topic indexing to develop an automatic media monitoring demonstrator and evaluate it in the context of real world applications . The targeted languages are French , German and Portuguese . Major mediamonitoring companies in Europe are participating in this project . Two other related FP5 IST projects are : CORETEX : Improving Core Speech Recognition Technology and ECHO : European CHronicles Online . CORETEX ( http://coretex.itc.it/ ) , aims at improving core speech recognition technologies , which are central to most applications involving voice technology . In particular the project addresses the development of generic speech recognition technology and methods to rapidly port technology to new domains and languages with limited supervision , and to produce enriched symbolic speech transcriptions . The ECHO project ( http://pc-erato2.iei.pi.cnr.it/echo ) aims to develop an infrastructure for access to historical films belonging to large national audiovisual archives . The project will integrate state-of-theart language technologies for indexing , searching and retrieval , cross-language retrieval capabilities and automatic film summary creation . 9 Conclusions This paper has described some of the ongoing research activites at LIMSI in automatic transcription and indexation of broadcast data . Much of this research , which is at the forefront of todays technology , is carried out with partners with real needs for advanced audio processing technologies . Automatic speech recognition is a key technology for audio and video indexing . Most of the linguistic information is encoded in the audio channel of video data , which once transcribed can be accessed using text-based tools . This is in contrast to the image data for which no common description language is widely adpoted . A variety of near-term applications are possible such as audio data mining , selective dissemination of information ( News-on-Demand ) , media monitoring , content-based audio and video retrieval . It appears that with word error rates on the order of 20 % , comparable IR results to those obtained on text data can be achieved . Even with higher word error rates obtained by running a faster transcription system or by transcribing compressed audio data ( Barras et al. , 2000 ; J.M. Van Thong et al. , 2000 ) ( such as that can be loaded over the Internet ) , the IR performance remains quite good . "}
  },
    {
    "id": "P01-1008",
    "result":     [
            {
        "value":         {
          "start": 1126,
          "end": 1132,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 3470,
          "end": 3486,
          "text": "Canadian Hansards",
          "labels": ["Dataset"]
        },
        "id": 161
      },
            {
        "value":         {
          "start": 3595,
          "end": 3625,
          "text": "unsupervised learning algorithm",
          "labels": ["Method"]
        },
        "id": 160
      },
            {
        "value":         {
          "start": 6373,
          "end": 6379,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 6611,
          "end": 6617,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 8654,
          "end": 8670,
          "text": "Canadian Hansards",
          "labels": ["Dataset"]
        },
        "id": 161
      },
            {
        "value":         {
          "start": 11376,
          "end": 11383,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 11779,
          "end": 11783,
          "text": "CELEX",
          "labels": ["Dataset"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 14525,
          "end": 14543,
          "text": "DLCoTrain algorithm",
          "labels": ["Method"]
        },
        "id": 162
      },
            {
        "value":         {
          "start": 16185,
          "end": 16199,
          "text": "lexical n-grams",
          "labels": ["Method"]
        },
        "id": 163
      },
            {
        "value":         {
          "start": 16203,
          "end": 16212,
          "text": "POS-ngrams",
          "labels": ["Method"]
        },
        "id": 164
      },
            {
        "value":         {
          "start": 16218,
          "end": 16237,
          "text": "parse tree fragments",
          "labels": ["Method"]
        },
        "id": 165
      },
            {
        "value":         {
          "start": 16265,
          "end": 16274,
          "text": "parse tree",
          "labels": ["Method"]
        },
        "id": 166
      },
            {
        "value":         {
          "start": 18271,
          "end": 18273,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22848,
          "end": 22864,
          "text": "Kappa coefficient",
          "labels": ["Metric"]
        },
        "id": 168
      },
            {
        "value":         {
          "start": 23404,
          "end": 23409,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23673,
          "end": 23679,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 23757,
          "end": 23763,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 23815,
          "end": 23820,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23846,
          "end": 23853,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 24168,
          "end": 24176,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24182,
          "end": 24187,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 25137,
          "end": 25145,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25218,
          "end": 25226,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 26095,
          "end": 26101,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 26376,
          "end": 26382,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 26623,
          "end": 26629,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      }
    ],
    "data": {"text": "Extracting Paraphrases from a Parallel Corpus Abstract While paraphrasing is critical both for interpretation and generation of natural language , current systems use manual or semi-automatic methods to collect paraphrases . We present an unsupervised learning algorithm for identification of paraphrases from a corpus of multiple English translations of the same source text . Our approach yields phrasal and single word lexical paraphrases as well as syntactic paraphrases . 1 Introduction Paraphrases are alternative ways to convey the same information . A method for the automatic acquisition of paraphrases has both practical and linguistic interest . From a practical point of view , diversity in expression presents a major challenge for many NLP applications . In multidocument summarization , identification of paraphrasing is required to find repetitive information in the input documents . In generation , paraphrasing is employed to create more varied and fluent text . Most current applications use manually collected paraphrases tailored to a specific application , or utilize existing lexical resources such as WordNet ( Miller et al . , 1990 ) to identify paraphrases . However , the process of manually collecting paraphrases is time consuming , and moreover , the collection is not reusable in other applications . Existing resources only include lexical paraphrases ; they do not include phrasal or syntactically based paraphrases . From a linguistic point of view , questions concern the operative definition of paraphrases : what types of lexical relations and syntactic mechanisms can produce paraphrases ? Many linguists ( Halliday , 1985 ; de Beaugrande and Dressler , 1981 ) agree that paraphrases retain approximate conceptual equivalence , and are not limited only to synonymy relations . But the extent of interchangeability between phrases which form paraphrases is an open question ( Dras , 1999 ) . A corpus-based approach can provide insights on this question by revealing paraphrases that people use . This paper presents a corpus-based method for automatic extraction of paraphrases . We use a large collection of multiple parallel English translations of novels1 . This corpus provides many instances of paraphrasing , because translations preserve the meaning of the original source , but may use different words to convey the meaning . An example of parallel translations is shown in Figure 1 . It contains two pairs of paraphrases : ( burst into tears , cried ) and ( comfort , console ) . Emma burst into tears and he tried to comfort her , saying things to make her smile . Emma cried , and he tried to console her , adorning his words with puns . Our method for paraphrase extraction builds upon methodology developed in Machine Translation ( MT ) . In MT , pairs of translated sentences from a bilingual corpus are aligned , and occurrence patterns of words in two languages in the text are extracted and matched using correlation measures . However , our parallel corpus is far from the clean parallel corpora used in MT. The rendition of a literary text into another language not only includes the translation , but also restructuring of the translation to fit the appropriate literary style . This process introduces differences in the translations which are an intrinsic part of the creative process . This results in greater differences across translations than the differences in typical MT parallel corpora , such as the Canadian Hansards . We will return to this point later in Section 3 . Based on the specifics of our corpus , we developed an unsupervised learning algorithm for paraphrase extraction . During the preprocessing stage , the corresponding sentences are aligned . We base our method for paraphrasing extraction on the assumption that phrases in aligned sentences which appear in similar contexts are paraphrases . To automatically infer which contexts are good predictors of paraphrases , contexts surrounding identical words in aligned sentences are extracted and filtered according to their predictive power . Then , these contexts are used to extract new paraphrases . In addition to learning lexical paraphrases , the method also learns syntactic paraphrases , by generalizing syntactic patterns of the extracted paraphrases . Extracted paraphrases are then applied to the corpus , and used to learn new context rules . This iterative algorithm continues until no new paraphrases are discovered . A novel feature of our approach is the ability to extract multiple kinds of paraphrases : Identification of lexical paraphrases . In contrast to earlier work on similarity , our approach allows identification of multi-word paraphrases , in addition to single words , a challenging issue for corpus-based techniques . Extraction of morpho-syntactic paraphrasing rules . Our approach yields a set of paraphrasing patterns by extrapolating the syntactic and morphological structure of extracted paraphrases . This process relies on morphological information and a part-of-speech tagging . Many of the rules identified by the algorithm match those that have been described as productive paraphrases in the linguistic literature . In the following sections , we provide an overview of existing work on paraphrasing , then we describe data used in this work , and detail our paraphrase extraction technique . We present results of our evaluation , and conclude with a discussion of our results . 2 Related Work on Paraphrasing Many NLP applications are required to deal with the unlimited variety of human language in expressing the same information . So far , three major approaches of collecting paraphrases have emerged : manual collection , utilization of existing lexical resources and corpus-based extraction of similar words . Manual collection of paraphrases is usually used in generation ( Iordanskaja et al. , 1991 ; Robin , 1994 ) . Paraphrasing is an inevitable part of any generation task , because a semantic concept can be realized in many different ways . Knowledge of possible concept verbalizations can help to generate a text which best fits existing syntactic and pragmatic constraints . Traditionally , alternative verbalizations are derived from a manual corpus analysis , and are , therefore , application specific . The second approach utilization of existing lexical resources , such as WordNet overcomes the scalability problem associated with an application specific collection of paraphrases . Lexical resources are used in statistical generation , summarization and question-answering . The question here is what type of WordNet relations can be considered as paraphrases . In some applications , only synonyms are considered as paraphrases ( Langkilde and Knight , 1998 ) ; in others , looser definitions are used ( Barzilay and Elhadad , 1997 ) . These definitions are valid in the context of particular applications ; however , in general , the correspondence between paraphrasing and types of lexical relations is not clear . The same question arises with automatically constructed thesauri ( Pereira et al. , 1993 ; Lin , 1998 ) . While the extracted pairs are indeed similar , they are not paraphrases . For example , while dog and cat are recognized as the most similar concepts by the method described in ( Lin , 1998 ) , it is hard to imagine a context in which these words would be interchangeable . The first attempt to derive paraphrasing rules from corpora was undertaken by ( Jacquemin et al. , 1997 ) , who investigated morphological and syntactic variants of technical terms . While these rules achieve high accuracy in identifying term paraphrases , the techniques used have not been extended to other types of paraphrasing yet . Statistical techniques were also successfully used by ( Lapata , 2001 ) to identify paraphrases of adjective-noun phrases . In contrast , our method is not limited to a particular paraphrase type . 3 The Data The corpus we use for identification of paraphrases is a collection of multiple English translations from a foreign source text . Specifically , we use literary texts written by foreign authors . Many classical texts have been translated more than once , and these translations are available on-line . In our experiments we used 5 books , among them , Flauberts Madame Bovary , Andersens Fairy Tales and Vernes Twenty Thousand Leagues Under the Sea . Some of the translations were created during different time periods and in different countries . In total , our corpus contains 11 translations 2 . At first glance , our corpus seems quite similar to parallel corpora used by researchers in MT , such as the Canadian Hansards . The major distinction lies in the degree of proximity between the translations . Analyzing multiple translations of the literary texts , critics ( e.g. ( Wechsler , 1998 ) ) have observed that translations are never identical , and each translator creates his own interpretations of the text . Clauses such as adorning his words with puns and saying things to make her smile from the sentences in Figure 1 are examples of distinct translations . Therefore , a complete match between words of related sentences is impossible . This characteristic of our corpus is similar to problems with noisy and comparable corpora ( Veronis , 2000 ) , and it prevents us from using methods developed in the MT community based on clean parallel corpora , such as ( Brown et al. , 1993 ) . Another distinction between our corpus and parallel MT corpora is the irregularity of word matchings : in MT , no words in the source language are kept as is in the target language translation ; for example , an English translation of 2Free of copyright restrictions part of our corpus ( 9 translations ) is available at http://www.cs.columbia.edu/regina / par . a French source does not contain untranslated French fragments . In contrast , in our corpus the same word is usually used in both translations , and only sometimes its paraphrases are used , which means that wordparaphrase pairs will have lower co-occurrence rates than wordtranslation pairs in MT. For example , consider occurrences of the word boy in two translations of Madame Bovary E. Marx-Avelings translation and Etexts translation . The first text contains 55 occurrences of boy , which correspond to 38 occurrences of boy and 17 occurrences of its paraphrases ( son , young fellow and youngster ) . This rules out using word translation methods based only on word co-occurrence counts . On the other hand , the big advantage of our corpus comes from the fact that parallel translations share many words , which helps the matching process . We describe below a method of paraphrase extraction , exploiting these features of our corpus . 4 Preprocessing During the preprocessing stage , we perform sentence alignment . Sentences which are translations of the same source sentence contain a number of identical words , which serve as a strong clue to the matching process . Alignment is performed using dynamic programming ( Gale and Church , 1991 ) with a weight function based on the number of common words in a sentence pair . This simple method achieves good results for our corpus , because 42 % of the words in corresponding sentences are identical words on average . Alignment produces 44,562 pairs of sentences with 1,798,526 words . To evaluate the accuracy of the alignment process , we analyzed 127 sentence pairs from the algorithms output . 120 ( 94.5 % ) alignments were identified as correct alignments . We then use a part-of-speech tagger and chunker ( Mikheev , 1997 ) to identify noun and verb phrases in the sentences . These phrases become the atomic units of the algorithm . We also record for each token its derivational root , using the CELEX ( Baayen et al . , 1993 ) database . 5 Method for Paraphrase Extraction Given the aforementioned differences between translations , our method builds on similarity in the local context , rather than on global alignment . Consider the two sentences in Figure 2 . Analyzing the contexts surrounding ? marked blanks in both sentences , one expects that they should have the same meaning , because they have the same premodifier empty and relate to the same preposition in ( in fact , the first ? stands for sky , and the second for heavens ) . Generalizing from this example , we hypothesize that if the contexts surrounding two phrases look similar enough , then these two phrases are likely to be paraphrases . The definition of the context depends on how similar the translations are . Once we know which contexts are good paraphrase predictors , we can extract paraphrase patterns from our corpus . Examples of such contexts are verb-object relations and noun-modifier relations , which were traditionally used in word similarity tasks from non-parallel corpora ( Pereira et al. , 1993 ; Hatzivassiloglou and McKeown , 1993 ) . However , in our case , more indirect relations can also be clues for paraphrasing , because we know a priori that input sentences convey the same information . For example , in sentences from Figure 3 , the verbs ringing and sounding do not share identical subject nouns , but the modifier of both subjects Evening is identical . Can we conclude that identical modifiers of the subject imply verb similarity ? To address this question , we need a way to identify contexts that are good predictors for paraphrasing in a corpus . To find good contexts , we can analyze all contexts surrounding identical words in the pairs of aligned sentences , and use these contexts to learn new paraphrases . This provides a basis for a bootstrapping mechanism . Starting with identical words in aligned sentences as a seed , we can incrementally learn the good contexts , and in turn use them to learn new paraphrases . Identical words play two roles in this process : first , they are used to learn context rules ; second , identical words are used in application of these rules , because the rules contain information about the equality of words in context . This method of co-training has been previously applied to a variety of natural language tasks , such as word sense disambiguation ( Yarowsky , 1995 ) , lexicon construction for information extraction ( Riloff and Jones , 1999 ) , and named entity classification ( Collins and Singer , 1999 ) . In our case , the co-training process creates a binary classifier , which predicts whether a given pair of phrases makes a paraphrase or not . Our model is based on the DLCoTrain algorithm proposed by ( Collins and Singer , 1999 ) , which applies a co-training procedure to decision list classifiers for two independent sets of features . In our case , one set of features describes the paraphrase pair itself , and another set of features corresponds to contexts in which paraphrases occur . These features and their computation are described below . 5.1 Feature Extraction Our paraphrase features include lexical and syntactic descriptions of the paraphrase pair . The lexical feature set consists of the sequence of tokens for each phrase in the paraphrase pair ; the syntactic feature set consists of a sequence of part-of-speech tags where equal words and words with the same root are marked . For example , the value of the syntactic feature for the pair ( the vast chimney , the chimney ) is ( DT JJ NN , DT NN ) , where indices indicate word equalities . We believe that this feature can be useful for two reasons : first , we expect that some syntactic categories can not be paraphrased in another syntactic category . For example , a determiner is unlikely to be a paraphrase of a verb . Second , this description is able to capture regularities in phrase level paraphrasing . In fact , a similar representation was used by ( Jacquemin et al. , 1997 ) to describe term variations . The contextual feature is a combination of the left and right syntactic contexts surrounding actual known paraphrases . There are a numAnd finally , dazzlingly white , it shone high above them in the empty ? . It appeared white and dazzling in the empty ? . ber of context representations that can be considered as possible candidates : lexical n-grams , POS-ngrams and parse tree fragments . The natural choice is a parse tree ; however , existing parsers perform poorly in our domain3 . Partof-speech tags provide the required level of abstraction , and can be accurately computed for our data . The left ( right ) context is a sequence of part-of-speech tags of words , occurring on the left ( right ) of the paraphrase . As in the case of syntactic paraphrase features , tags of identical words are marked . For example , when , the contextual feature for the paraphrase pair ( comfort , console ) from Figure 1 sentences is left = VB TO , ( tried to ) , left = VB TO , ( tried to ) , right = PRP$ , , ( her , ) right context $ = PRP$ , , ( her , ) . In the next section , we describe how the classifiers for contextual and paraphrasing features are co-trained . 5.2 The co-training algorithm Our co-training algorithm has three stages : initialization , training of the contextual classifier and training of the paraphrasing classifiers . Initialization Words which appear in both sentences of an aligned pair are used to create the initial seed rules . Using identical words , we create a set of positive paraphrasing examples , such as word = tried , word = tried . However , training of the classifier demands negative examples as well ; in our case it requires pairs of words in aligned sentences which are not paraphrases of each other . To find negative examples , we match identical words in the alignment against all different words in the aligned sentence , assuming that identical words can match only each other , and not any other word in the aligned sentences . For example , tried from the first sentence in Figure 1 does not correspond to any other word in the second sentence but tried . Based on this observation , we can derive negative examples such as word = tried , word = Emma and word = tried , word = console . Given a pair of identical words from two sentences of length and , the algorithm produces one positive ex3To the best of our knowledge all existing statistical parsers are trained on WSJ or similar type of corpora . In the experiments we conducted , their performance significantly degraded on our corpus literary texts . ample and negative examples . Training of the contextual classifier Using this initial seed , we record contexts around positive and negative paraphrasing examples . From all the extracted contexts we must identify the ones which are strong predictors of their category . Following ( Collins and Singer , 1999 ) , filtering is based on the strength of the context and its frequency . The strength of positive context is defined as , where is the number of times context surrounds positive examples ( paraphrase pairs ) and is the frequency of the context . Strength of the negative context is defined in a symmetrical manner . For the positive and the negative categories we select rules ( in our experiments ) with the highest frequency and strength higher than the predefined threshold of 95 % . Examples of selected context rules are shown in Figure 4 . The parameter of the contextual classifier is a context length . In our experiments we found that a maximal context length of three produces best results . We also observed that for some rules a shorter context works better . Therefore , when recording contexts around positive and negative examples , we record all the contexts with length smaller or equal to the maximal length . Because our corpus consists of translations of several books , created by different translators , we expect that the similarity between translations varies from one book to another . This implies that contextual rules should be specific to a particular pair of translations . Therefore , we train the contextual classifier for each pair of translations separately . Training of the paraphrasing classifier Context rules extracted in the previous stage are then applied to the corpus to derive a new set of pairs of positive and negative paraphrasing examples . Applications of the rule performed by searching sentence pairs for subsequences which match the left and right parts of the contextual rule , and are less than tokens apart . For example , applying the first rule from Figure 4 to sentences from Figure 1 yields the paraphrasing pair ( comfort , console ) . Note that in the original seed set , the left and right contexts were separated by one token . This stretch in rule application allows us to extract multi-word paraphrases . For each extracted example , paraphrasing rules are recorded and filtered in a similar manner as contextual rules . Examples of lexical and syntactic paraphrasing rules are shown in Figure 5 and in Figure 6 . After extracted lexical and syntactic paraphrases are applied to the corpus , the contextual classifier is retrained . New paraphrases not only add more positive and negative instances to the contextual classifier , but also revise contextual rules for known instances based on new paraphrase information . ( countless , lots of ) ( repulsion , aversion ) ( undertone , low voice ) ( shrubs , bushes ) ( refuse , say no ) ( dull tone , gloom ) ( sudden appearance , apparition ) Figure 6 : Lexical paraphrases extracted by the algorithm . The iterative process is terminated when no new paraphrases are discovered or the number of iterations exceeds a predefined threshold . 6 The results Our algorithm produced 9483 pairs of lexical paraphrases and 25 morpho-syntactic rules . To evaluate the quality of produced paraphrases , we picked at random 500 paraphrasing pairs from the lexical paraphrases produced by our algorithm . These pairs were used as test data and also to evaluate whether humans agree on paraphrasing judgments . The judges were given a page of guidelines , defining paraphrase as approximate conceptual equivalence . The main dilemma in designing the evaluation is whether to include the context : should the human judge see only a paraphrase pair or should a pair of sentences containing these paraphrases also be given ? In a similar MT task evaluation of word-to-word translation context is usually included ( Melamed , 2001 ) . Although paraphrasing is considered to be context dependent , there is no agreement on the extent . To evaluate the influence of context on paraphrasing judgments , we performed two experiments with and without context . First , the human judge is given a paraphrase pair without context , and after the judge entered his answer , he is given the same pair with its surrounding context . Each context was evaluated by two judges ( other than the authors ) . The agreement was measured using the Kappa coefficient ( Siegel and Castellan , 1988 ) . Complete agreement between judges would correspond to K equals ; if there is no agreement among judges , then K equals . The judges agreement on the paraphrasing judgment without context was which is substantial agreement ( Landis and Koch , 1977 ) . The first judge found 439 ( 87.8 % ) pairs as correct paraphrases , and the second judge 426 ( 85.2 % ) . Judgments with context have even higher agreement ( ) , and judges identified 459 ( 91.8 % ) and 457 ( 91.4 % ) pairs as correct paraphrases . The recall of our method is a more problematic issue . The algorithm can identify paraphrasing relations only between words which occurred in our corpus , which of course does not cover all English tokens . Furthermore , direct comparison with an electronic thesaurus like WordNet is impossible , because it is not known a priori which lexical relations in WordNet can form paraphrases . Thus , we can not evaluate recall . We hand-evaluated the coverage , by asking a human judges to extract paraphrases from 50 sentences , and then counted how many of these paraphrases where predicted by our algorithm . From 70 paraphrases extracted by human judge , 48 ( 69 % ) were identified as paraphrases by our algorithm . In addition to evaluating our system output through precision and recall , we also compared our results with two other methods . The first of these was a machine translation technique for deriving bilingual lexicons ( Melamed , 2001 ) including detection of non-compositional compounds 4 . We did this evaluation on 60 % of the full dataset ; this is the portion of the data which is publicly available . Our system produced 6,826 word pairs from this data and Melamed provided the top 6,826 word pairs resulting from his system on this data . We randomly extracted 500 pairs each from both sets of output . Of the 500 pairs produced by our system , 354 ( 70.8 % ) were single word pairs and 146 ( 29.2 % ) were multi-word paraphrases , while the majority of pairs produced by Melameds system were single word pairs ( 90 % ) . We mixed this output and gave the resulting , randomly ordered 1000 pairs to six evaluators , all of whom were native speakers . Each evaluator provided judgments on 500 pairs without context . Precision for our system was 71.6 % and for Melameds was 52.7 % . This increased precision is a clear advantage of our approach and shows that machine translation techniques can not be used without modification for this task , particularly for producing multi-word paraphrases . There are three caveats that should be noted ; Melameds system was run without changes for this new task of paraphrase extraction and his system does not use chunk segmentation , he ran the system for three days of computation and the result may be improved with more running time since it makes incremental improvements on subsequent rounds , and finally , the agreement between human judges was lower than in our previous experiments . We are currently exploring whether the information produced by the two different systems may be combined to improve the performance of either system alone . Another view on the extracted paraphrases can be derived by comparing them with the WordNet thesaurus . This comparison provides us with quantitative evidence on the types of lexical relations people use to create paraphrases . We selected 112 paraphrasing pairs which occurred at least 20 times in our corpus and such that the words comprising each pair appear in WordNet . The 20 times cutoff was chosen to ensure that the identified pairs are general enough and not idiosyncratic . We use the frequency threshold to select paraphrases which are not tailored to one context . Examples of paraphrases and their WordNet relations are shown in Figure 7 . Only 40 ( 35 % ) paraphrases are synonyms , 36 ( 32 % ) are hyperonyms , 20 ( 18 % ) are siblings in the hyperonym tree , 11 ( 10 % ) are unrelated , and the remaining 5 % are covered by other relations . These figures quantitatively validate our intuition that synonymy is not the only source of paraphrasing . One of the practical implications is that using synonymy relations exclusively to recognize paraphrasing limits system performance . 7 Conclusions and Future work In this paper , we presented a method for corpusbased identification of paraphrases from multiple English translations of the same source text . We showed that a co-training algorithm based on contextual and lexico-syntactic features of paraphrases achieves high performance on our data . The wide range of paraphrases extracted by our algorithm sheds light on the paraphrasing phenomena , which has not been studied from an empirical perspective . Future work will extend this approach to extract paraphrases from comparable corpora , such as multiple reports from different news agencies about the same event or different descriptions of a disease from the medical literature . This extension will require using a more selective alignment technique ( similar to that of ( Hatzivassiloglou et al. , 1999 ) ) . We will also investigate a more powerful representation of contextual features . Fortunately , statistical parsers produce reliable results on news texts , and therefore can be used to improve context representation . This will allow us to extract macro-syntactic paraphrases in addition to local paraphrases which are currently produced by the algorithm . "}
  },
    {
    "id": "P02-1001",
    "result":     [
            {
        "value":         {
          "start": 73,
          "end": 105,
          "text": "Weighted finite-state transducers",
          "labels": ["Method"]
        },
        "id": 170
      },
            {
        "value":         {
          "start": 377,
          "end": 393,
          "text": "parameterized FST",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 1267,
          "end": 1289,
          "text": "finite-state transducer",
          "labels": ["Method"]
        },
        "id": 172
      },
            {
        "value":         {
          "start": 3764,
          "end": 3789,
          "text": "forward-backward algorithm",
          "labels": ["Method"]
        },
        "id": 173
      },
            {
        "value":         {
          "start": 3819,
          "end": 3838,
          "text": "Hidden Markov Models",
          "labels": ["Method"]
        },
        "id": 174
      },
            {
        "value":         {
          "start": 3891,
          "end": 3914,
          "text": "stochastic edit distance",
          "labels": ["Method"]
        },
        "id": 175
      },
            {
        "value":         {
          "start": 4245,
          "end": 4278,
          "text": "parameterized finitestate machines",
          "labels": ["Method"]
        },
        "id": 176
      },
            {
        "value":         {
          "start": 4969,
          "end": 4989,
          "text": "Finite-state machines",
          "labels": ["Method"]
        },
        "id": 177
      },
            {
        "value":         {
          "start": 5027,
          "end": 5030,
          "text": "FSAs",
          "labels": ["Method"]
        },
        "id": 195
      },
            {
        "value":         {
          "start": 5052,
          "end": 5055,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 5188,
          "end": 5190,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 6222,
          "end": 6225,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 6372,
          "end": 6380,
          "text": "FST model",
          "labels": ["Method"]
        },
        "id": 181
      },
            {
        "value":         {
          "start": 6913,
          "end": 6915,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 7198,
          "end": 7210,
          "text": "Markovian FST",
          "labels": ["Method"]
        },
        "id": 182
      },
            {
        "value":         {
          "start": 7608,
          "end": 7611,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 7731,
          "end": 7744,
          "text": "decision trees",
          "labels": ["Method"]
        },
        "id": 226
      },
            {
        "value":         {
          "start": 8064,
          "end": 8082,
          "text": "noisy-channel model",
          "labels": ["Method"]
        },
        "id": 184
      },
            {
        "value":         {
          "start": 8633,
          "end": 8645,
          "text": "weighted FSTs",
          "labels": ["Method"]
        },
        "id": 188
      },
            {
        "value":         {
          "start": 8863,
          "end": 8875,
          "text": "weighted FSAs",
          "labels": ["Method"]
        },
        "id": 189
      },
            {
        "value":         {
          "start": 8894,
          "end": 8898,
          "text": "PCFGs",
          "labels": ["Method"]
        },
        "id": 461
      },
            {
        "value":         {
          "start": 8974,
          "end": 8986,
          "text": "weighted FSTs",
          "labels": ["Method"]
        },
        "id": 188
      },
            {
        "value":         {
          "start": 9038,
          "end": 9042,
          "text": "PCFGs",
          "labels": ["Method"]
        },
        "id": 461
      },
            {
        "value":         {
          "start": 9099,
          "end": 9103,
          "text": "PCFGs",
          "labels": ["Method"]
        },
        "id": 461
      },
            {
        "value":         {
          "start": 9151,
          "end": 9154,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 9242,
          "end": 9244,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 9809,
          "end": 9821,
          "text": "weighted FSAs",
          "labels": ["Method"]
        },
        "id": 189
      },
            {
        "value":         {
          "start": 9972,
          "end": 9974,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 10013,
          "end": 10015,
          "text": "FSA",
          "labels": ["Method"]
        },
        "id": 189
      },
            {
        "value":         {
          "start": 10697,
          "end": 10708,
          "text": "weighted FST",
          "labels": ["Method"]
        },
        "id": 190
      },
            {
        "value":         {
          "start": 10929,
          "end": 10943,
          "text": "maximum-entropy",
          "labels": ["Method"]
        },
        "id": 191
      },
            {
        "value":         {
          "start": 11857,
          "end": 11859,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 11872,
          "end": 11875,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 11948,
          "end": 11964,
          "text": "probabilistic FSA",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 12015,
          "end": 12032,
          "text": "probabilistic FSAs",
          "labels": ["Method"]
        },
        "id": 193
      },
            {
        "value":         {
          "start": 12072,
          "end": 12087,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 12112,
          "end": 12115,
          "text": "FSAs",
          "labels": ["Method"]
        },
        "id": 195
      },
            {
        "value":         {
          "start": 12573,
          "end": 12575,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 12583,
          "end": 12585,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 12688,
          "end": 12690,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 13183,
          "end": 13185,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 13314,
          "end": 13328,
          "text": "Lazy algorithms",
          "labels": ["Method"]
        },
        "id": 195
      },
            {
        "value":         {
          "start": 13895,
          "end": 13897,
          "text": "HMM",
          "labels": ["Method"]
        },
        "id": 202
      },
            {
        "value":         {
          "start": 14129,
          "end": 14157,
          "text": "Maximum-likelihood estimation",
          "labels": ["Method"]
        },
        "id": 197
      },
            {
        "value":         {
          "start": 14211,
          "end": 14238,
          "text": "Maximum-posterior estimation",
          "labels": ["Method"]
        },
        "id": 198
      },
            {
        "value":         {
          "start": 14517,
          "end": 14528,
          "text": "EM algorithm",
          "labels": ["Method"]
        },
        "id": 375
      },
            {
        "value":         {
          "start": 14695,
          "end": 14697,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 14870,
          "end": 14871,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 15419,
          "end": 15421,
          "text": "HMM",
          "labels": ["Method"]
        },
        "id": 202
      },
            {
        "value":         {
          "start": 15429,
          "end": 15431,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 15445,
          "end": 15461,
          "text": "probabilistic FSA",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 15502,
          "end": 15504,
          "text": "HMM",
          "labels": ["Method"]
        },
        "id": 202
      },
            {
        "value":         {
          "start": 15513,
          "end": 15527,
          "text": "conditional FST",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 15545,
          "end": 15547,
          "text": "HMM",
          "labels": ["Method"]
        },
        "id": 202
      },
            {
        "value":         {
          "start": 16315,
          "end": 16327,
          "text": "GEM algorithm",
          "labels": ["Method"]
        },
        "id": 202
      },
            {
        "value":         {
          "start": 16374,
          "end": 16375,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 16385,
          "end": 16411,
          "text": "gradient-based optimization",
          "labels": ["Method"]
        },
        "id": 203
      },
            {
        "value":         {
          "start": 17089,
          "end": 17090,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 17195,
          "end": 17209,
          "text": "conditional FST",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 17921,
          "end": 17937,
          "text": "probabilistic FSA",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 18083,
          "end": 18084,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 18362,
          "end": 18378,
          "text": "parameterized FST",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 19164,
          "end": 19179,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 20768,
          "end": 20789,
          "text": "finite-state framework",
          "labels": ["Method"]
        },
        "id": 204
      },
            {
        "value":         {
          "start": 21163,
          "end": 21185,
          "text": "finite-state algorithms",
          "labels": ["Method"]
        },
        "id": 214
      },
            {
        "value":         {
          "start": 22063,
          "end": 22082,
          "text": "finite-state methods",
          "labels": ["Method"]
        },
        "id": 206
      },
            {
        "value":         {
          "start": 22269,
          "end": 22271,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 22899,
          "end": 22902,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 23401,
          "end": 23403,
          "text": "FST",
          "labels": ["Method"]
        },
        "id": 207
      },
            {
        "value":         {
          "start": 25375,
          "end": 25378,
          "text": "HMMs",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 25485,
          "end": 25509,
          "text": "forwardbackward algorithm",
          "labels": ["Method"]
        },
        "id": 1543
      },
            {
        "value":         {
          "start": 26751,
          "end": 26785,
          "text": "parameterized finite-state machines",
          "labels": ["Method"]
        },
        "id": 209
      },
            {
        "value":         {
          "start": 26857,
          "end": 26868,
          "text": "EM algorithm",
          "labels": ["Method"]
        },
        "id": 375
      },
            {
        "value":         {
          "start": 26874,
          "end": 26877,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      },
            {
        "value":         {
          "start": 26936,
          "end": 26939,
          "text": "HMMs",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 26945,
          "end": 26977,
          "text": "weighted contextual edit distance",
          "labels": ["Method"]
        },
        "id": 210
      },
            {
        "value":         {
          "start": 27016,
          "end": 27033,
          "text": "endto-end training",
          "labels": ["Method"]
        },
        "id": 211
      },
            {
        "value":         {
          "start": 27361,
          "end": 27377,
          "text": "conditional MEMMs",
          "labels": ["Method"]
        },
        "id": 212
      },
            {
        "value":         {
          "start": 27411,
          "end": 27435,
          "text": "conditional random fields",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 27867,
          "end": 27889,
          "text": "finite-state algorithms",
          "labels": ["Method"]
        },
        "id": 214
      },
            {
        "value":         {
          "start": 28362,
          "end": 28380,
          "text": "end-to-end training",
          "labels": ["Method"]
        },
        "id": 214
      },
            {
        "value":         {
          "start": 28433,
          "end": 28461,
          "text": "parameterized synchronous CFG",
          "labels": ["Method"]
        },
        "id": 215
      },
            {
        "value":         {
          "start": 28477,
          "end": 28492,
          "text": "tree transducers",
          "labels": ["Method"]
        },
        "id": 216
      },
            {
        "value":         {
          "start": 28503,
          "end": 28506,
          "text": "FSTs",
          "labels": ["Method"]
        },
        "id": 217
      }
    ],
    "data": {"text": "Parameter Estimation for Probabilistic Finite-State Transducers Abstract Weighted finite-state transducers suffer from the lack of a training algorithm . Training is even harder for transducers that have been assembled via finite-state operations such as composition , minimization , union , concatenation , and closure , as this yields tricky parameter tying . We formulate a parameterized FST paradigm and give training algorithms for it , including a general bookkeeping trick ( expectation semirings ) that cleanly and efficiently computes expectations and gradients . 1 Background and Motivation Rational relations on strings have become widespread in language and speech engineering ( Roche and Schabes , 1997 ) . Despite bounded memory they are well-suited to describe many linguistic and textual processes , either exactly or approximately . A relation is a set of ( input , output ) pairs . Relations are more general than functions because they may pair a given input string with more or fewer than one output string . The class of so-called rational relations admits a nice declarative programming paradigm . Source code describing the relation ( a regular expression ) is compiled into efficient object code ( in the form of a 2 - tape automaton called a finite-state transducer ) . The object code can even be optimized for runtime and code size ( via algorithms such as determinization and minimization of transducers ) . This programming paradigm supports efficient nondeterminism , including parallel processing over infinite sets of input strings , and even allows reverse computation from output to input . Its unusual flexibility for the practiced programmer stems from the many operations under which rational relations are closed . It is common to define further useful operations ( as macros ) , which modify existing relations not by editing their source code but simply by operating on them from outside . A brief version of this work , with some additional material , first appeared as ( Eisner , 2001a ) . A leisurely journal-length version with more details has been prepared and is available . The entire paradigm has been generalized to weighted relations , which assign a weight to each ( input , output ) pair rather than simply including or excluding it . If these weights represent probabilities P ( input , output ) or P ( output | input ) , the weighted relation is called a joint or conditional ( probabilistic ) relation and constitutes a statistical model . Such models can be efficiently restricted , manipulated or combined using rational operations as before . An artificial example will appear in 2 . The availability of toolkits for this weighted case ( Mohri et al. , 1998 ; van Noord and Gerdemann , 2001 ) promises to unify much of statistical NLP . Such tools make it easy to run most current approaches to statistical markup , chunking , normalization , segmentation , alignment , and noisy-channel decoding , ' including classic models for speech recognition ( Pereira and Riley , 1997 ) and machine translation ( Knight and Al-Onaizan , 1998 ) . Moreover , once the models are expressed in the finitestate framework , it is easy to use operators to tweak them , to apply them to speech lattices or other sets , and to combine them with linguistic resources . Unfortunately , there is a stumbling block : Where do the weights come from ? After all , statistical models require supervised or unsupervised training . Currently , finite-state practitioners derive weights using exogenous training methods , then patch them onto transducer arcs . Not only do these methods require additional programming outside the toolkit , but they are limited to particular kinds of models and training regimens . For example , the forward-backward algorithm ( Baum , 1972 ) trains only Hidden Markov Models , while ( Ristad and Yianilos , 1996 ) trains only stochastic edit distance . In short , current finite-state toolkits include no training algorithms , because none exist for the large space of statistical models that the toolkits can in principle describe and run . ` Given output , find input to maximize P ( input , output ) . This paper aims to provide a remedy through a new paradigm , which we call parameterized finitestate machines . It lays out a fully general approach for training the weights of weighted rational relations . First 2 considers how to parameterize such models , so that weights are defined in terms of underlying parameters to be learned . 3 asks what it means to learn these parameters from training data ( what is to be optimized ? ) , and notes the apparently formidable bookkeeping involved . 4 cuts through the difficulty with a surprisingly simple trick . Finally , 5 removes inefficiencies from the basic algorithm , making it suitable for inclusion in an actual toolkit . Such a toolkit could greatly shorten the development cycle in natural language engineering . 2 Transducers and Parameters Finite-state machines , including finite-state automata ( FSAs ) and transducers ( FSTs ) , are a kind of labeled directed multigraph . For ease and brevity , we explain them by example . Fig . 1a shows a probabilistic FST with input alphabet E = { a , b } , output alphabet A = { x , z } , and all states final . It may be regarded as a device for generating a string pair in E * x A * by a random walk from Q. Two paths exist that generate both input aabb and output xz : Each of the paths has probability .0002646 , so the probability of somehow generating the pair ( aabb , xz ) is .0002646 + .0002646 = .0005292 . Abstracting away from the idea of random walks , arc weights need not be probabilities . Still , define a paths weight as the product of its arc weights and the stopping weight of its final state . Thus Fig. 1a defines a weighted relation f where f ( aabb , xz ) = .0005292 . This particular relation does happen to be probabilistic ( see 1 ) . It represents a joint distribution ( since Ex , y f ( x , y ) = 1 ) . Meanwhile , Fig. 1c defines a conditional one ( bx Ey f ( x , y ) = 1 ) . This paper explains how to adjust probability distributions like that of Fig. 1a so as to model training data better . The algorithm improves an FSTs numeric weights while leaving its topology fixed . How many parameters are there to adjust in Fig. 1a ? That is up to the user who built it ! An FST model with few parameters is more constrained , making optimization easier . Some possibilities : generate E if heads , F if tails . E * = ( AE ) ( 1A ) means repeatedly flip an A-weighted coin and keep repeating E as long as it comes up heads . These 4 parameters have global effects on Fig. 1a , thanks to complex parameter tying : arcs b :p ) @ , b : q ) in Fig. 1b get respective probabilities ( 1 A ) and ( 1 ) , which covary with and vary oppositely with . Each of these probabilities in turn affects multiple arcs in the composed FST of Fig . 1a . We offer a theorem that highlights the broad applicability of these modeling techniques . If f ( input , output ) is a weighted regular relation , then the following statements are equivalent : ( 1 ) f is a joint probabilistic relation ; ( 2 ) f can be computed by a Markovian FST that halts with probability 1 ; ( 3 ) f can be expressed as a probabilistic regexp , i.e . , a regexp built up from atomic expressions a : b ( for a E E U { E } , b E A U { E } ) using concatenation , probabilistic union + p , and probabilistic closure * p . For defining conditional relations , a good regexp language is unknown to us , but they can be defined in several other ways : ( 1 ) via FSTs as in Fig . 1c , ( 2 ) by compilation of weighted rewrite rules ( Mohri and Sproat , 1996 ) , ( 3 ) by compilation of decision trees ( Sproat and Riley , 1996 ) , ( 4 ) as a relation that performs contextual left-to-right replacement of input substrings by a smaller conditional relation ( Gerdemann and van Noord , 1999 ) , 5 ( 5 ) by conditionalization of a joint relation as discussed below . A central technique is to define a joint relation as a noisy-channel model , by composing a joint relation with a cascade of one or more conditional relations as in Fig . 1 ( Pereira and Riley , 1997 ; Knight and Graehl , 1998 ) . The general form is illustrated by 3Conceptually , the parameters represent the probabilities of reading another a ( A ) ; reading another b ( ) ; transducing b to p rather than q ( ) ; starting to transduce p to a rather than x ( p ) . P ( v , z ) def = Ew , x , y P ( v | w ) P ( w , x ) P ( y | x ) P ( z | y ) , implemented by composing 4 machines . There are also procedures for defining weighted FSTs that are not probabilistic ( Berstel and Reutenauer , 1988 ) . Arbitrary weights such as 2.7 may be assigned to arcs or sprinkled through a regexp ( to be compiled into E : E/2 .7 ) arcs ) . A more subtle example is weighted FSAs that approximate PCFGs ( Nederhof , 2000 ; Mohri and Nederhof , 2001 ) , or to extend the idea , weighted FSTs that approximate joint or conditional synchronous PCFGs built for translation . These are parameterized by the PCFGs parameters , but add or remove strings of the PCFG to leave an improper probability distribution . Fortunately for those techniques , an FST with positive arc weights can be normalized to make it jointly or conditionally probabilistic : ization , which simply divides each f ( x , y ) by Ex , , y , f ( x ' , y ' ) ( joint case ) or by Ey , f ( x , y ' ) ( conditional case ) . To implement the joint case , just divide stopping weights by the total weight of all paths ( which 4 shows how to find ) , provided this is finite . In the conditional case , let g be a copy of f with the output labels removed , so that g ( x ) finds the desired divisor ; determinize g if possible ( but this fails for some weighted FSAs ) , replace all weights with their reciprocals , and compose the result with f . 9 6 P ( w , x ) defines the source model , and is often an identity FST that requires w = x , really just an FSA . 7We propose also using n-tape automata to generalize to branching noisy channels ( a case of dendroid distributions ) . In Ew , x P ( v | w ) P ( v , | w ) P ( w , x ) P ( y | x ) , the true transcription w can be triply constrained by observing speech y and two errorful transcriptions v , v ' , which independently depend on w. 8A corresponding problem exists in the joint case , but may be easily avoided there by first pruning non-coaccessible states . 9It suffices to make g unambiguous ( one accepting path per string ) , a weaker condition than determinism . When this is not possible ( as in the inverse of Fig . 1b , whose conditionalization can not be realized by any weighted FST ) , one can sometimes succeed by first intersecting g with a smaller regular set in which the input being considered is known to fall . Normalization is particularly important because it enables the use of log-linear ( maximum-entropy ) parameterizations . Here one defines each arc weight , coin weight , or regexp weight in terms of meaningful features associated by hand with that arc , coin , etc. . Each feature has a strength E R > 0 , and a weight is computed as the product of the strengths of its features .10 It is now the strengths that are the learnable parameters . This allows meaningful parameter tying : if certain arcs such asu : i * , * , and a : ae o : e * share a contextual vowel-fronting feature , then their weights rise and fall together with the strength of that feature . The resulting machine must be normalized , either per-state or globally , to obtain a joint or a conditional distribution as desired . Such approaches have been tried recently in restricted cases ( McCallum et al. , 2000 ; Eisner , 2001b ; Lafferty et al. , 2001 ) . Normalization may be postponed and applied instead to the result of combining the FST with other FSTs by composition , union , concatenation , etc . . A simple example is a probabilistic FSA defined by normalizing the intersection of other probabilistic FSAs f1 , f2 , . . . . ( This is in fact a log-linear model in which the component FSAs define the features : string x has log fi ( x ) occurrences of feature i . ) In short , weighted finite-state operators provide a language for specifying a wide variety of parameterized statistical models . Let us turn to their training . 3 Estimation in Parameterized FSTs We are primarily concerned with the following training paradigm , novel in its generality . Let f : E * xA * * R > 0 be a joint probabilistic relation that is computed by a weighted FST . The FST was built by some recipe that used the parameter vector 0 . Changing 0 may require us to rebuild the FST to get updated weights ; this can involve composition , regexp compilation , multiplication of feature strengths , etc . ( Lazy algorithms that compute arcs and states of tion can not be realized by any weighted FST ) , one can sometimes succeed by first intersecting g with a smaller regular set in which the input being considered is known to fall . In the extreme , if each input string is fully observed ( not the case if the input is bound by composition to the output of a one-to-many FST ) , one can succeed by restricting g to each input string in turn ; this amounts to manually dividing f ( x , y ) by g ( x ) . Lazy algorithms that compute arcs and states of f on demand ( Mohri et al . , 1998 ) can pay off here , since only part of f may be needed subsequently . As training data we are given a set of observed ( input , output ) pairs , ( xi , yi ) . These are assumed to be independent random samples from a joint distribution of the form fe ( x , y ) ; the goal is to recover the true 0 . Samples need not be fully observed ( partly supervised training ) : thus xi C E * , yi C A * may be given as regular sets in which input and output were observed to fall . For example , in ordinary HMM training , xi = E * and represents a completely hidden state sequence ( cf . Ristad ( 1998 ) , who allows any regular set ) , while yi is a single string representing a completely observed emission sequence .11 What to optimize ? Maximum-likelihood estimation guesses 0 to be the 0 maximizing Hi f ( xi , yi ) . Maximum-posterior estimation tries to maximize P ( 0 ) Hi f ( xi , yi ) where P ( 0 ) is a prior probability . In a log-linear parameterization , for example , a prior that penalizes feature strengths far from 1 can be used to do feature selection and avoid overfitting ( Chen and Rosenfeld , 1999 ) . The EM algorithm ( Dempster et al . , 1977 ) can maximize these functions . Roughly , the E step guesses hidden information : if ( xi , yi ) was generated from the current f , which FST paths stand a chance of having been the path used ? ( Guessing the path also guesses the exact input and output . ) The M step updates 0 to make those paths more likely . EM alternates these steps and converges to a local optimum . The M steps form depends on the parameterization and the E step serves the M steps needs . Let f be Fig. 1a and suppose ( xi , yi ) = ( a ( a + b ) * , xxz ) . During the E step , we restrict to paths compatible with this observation by computing xi o f o yi , shown in Fig. 2 . To find each paths posterior probability given the observation ( xi , yi ) , just conditionalize : divide its raw probability by the total probability ( Pz 0.1003 ) of all paths in Fig. 2 . 11 To implement an HMM by an FST , compose a probabilistic FSA that generates a state sequence of the HMM with a conditional FST that transduces HMM states to emitted symbols . But that is not the full E step . The M step uses not individual path probabilities ( Fig. 2 has infinitely many ) but expected counts derived from the paths . Crucially , 4 will show how the E step can accumulate these counts effortlessly . We first explain their use by the M step , repeating the presentation of 2 : in Fig. 2 is really to traverse Q a : x Rosenfeld , 1999 ) .12 For globally normalized , joint models , the predicted vector is ecf ( E * , A * ) . If the log-linear probabilities are conditioned on the state and/or the input , the predicted vector is harder to describe ( though usually much easier to compute ) .13 12 IIS is itself iterative ; to avoid nested loops , run only one iteration at each M step , giving a GEM algorithm ( Riezler , 1999 ) . Alternatively , discard EM and use gradient-based optimization . 13For per-state conditional normalization , let Dj , a be the set of arcs from state j with input symbol a E E ; their weights are normalized to sum to 1 . Besides computing c , the E step must count the expected number dj , a of traversals of arcs in each Dj , a . Then the predicted vector given is Ej , a dj , a ( expected feature counts on a randomly chosen arc in Dj , a ) . Per-state joint normalization ( Eisner , 2001b , 8.2 ) is similar but drops the dependence on a . The difficult case is global conditional normalization . It arises , for example , when training a joint model of the form f = ( g o h ) , where h is a conditional It is also possible to use this EM approach for discriminative training , where we wish to maximize Hi P ( yi | xi ) and f ( x , y ) is a conditional FST that defines P ( y | x ) . The trick is to instead train a joint model g o f , where g ( xi ) defines P ( xi ) , thereby maximizing Hi P ( xi ) P ( yi | xi ) . ( Of course , the method of this paper can train such compositions . ) If x1 , ... xn are fully observed , just define each g ( xi ) = 1/n . But by choosing a more general model of g , we can also handle incompletely observed xi : training g o f then forces g and f to cooperatively reconstruct a distribution over the possible inputs and do discriminative training of f given those inputs . ( Any parameters of g may be either frozen before training or optimized along with the parameters of f. ) A final possibility is that each xi is defined by a probabilistic FSA that already supplies a distribution over the inputs ; then we consider xi o f o yi directly , just as in the joint model . Finally , note that EM is not all-purpose . It only maximizes probabilistic objective functions , and even there it is not necessarily as fast as ( say ) conjugate gradient . For this reason , we will also show below how to compute the gradient of f ( xi , yi ) with respect to 0 , for an arbitrary parameterized FST f . We remark without elaboration that this can help optimize task-related objective functions , such as E Ey ( P ( xi , y ) / Ey ' P ( xi , y ) ) error ( y , yi ) . i 4 The E Step: Expectation Semirings It remains to devise appropriate E steps , which looks rather daunting . Each path in Fig. 2 weaves together parameters from other machines , which we must untangle and tally . In the 4-coin parameterization , path observed heads and tails of the 4 coins . This nontrivially works out to ( 4 , 1 , 0,1,1,1,1 , 2 ) . For other parameterizations , the path must instead yield a vector of arc traversal counts or feature counts . Computing a count vector for one path is hard enough , but it is the E steps job to find the expected value of this vectoran average over the infinitely log-linear model of P ( v | u ) for u E E ' * , v E 0 ' * . Then the predicted count vector contributed by h is Ei EuE , P ( u xi , yi ) ech ( u , 0 ' * ) . The term Ei P ( u | xi , yi ) computes the expected count of each u E E ' * . It may be found by a variant of 4 in which path values are regular expressions over E ' * . many paths through Fig. 2 in proportion to their posterior probabilities P ( | xi , yi ) . The results for all ( xi , yi ) are summed and passed to the M step . Abstractly , let us say that each path has not only a probability P ( ) E [ 0 , 1 ] but also a value val ( ) in a vector space V , which counts the arcs , features , or coin flips encountered along path . The value of a path is the sum of the values assigned to its arcs . The E step must return the expected value of the unknown path that generated ( xi , yi ) . For example , if every arc had value 1 , then expected value would be expected path length . Letting H denote the set of paths in xi o fe o yi ( Fig. 2 ) , the expected value is14 The denominator of equation ( 1 ) is the total probability of all accepting paths in xi o f o yi . But while computing this , we will also compute the numerator . The idea is to augment the weight data structure with expectation information , so each weight records a probability and a vector counting the parameters that contributed to that probability . We will enforce an invariant : the weight of any pathset H must be ( & E P ( ) , & E P ( ) val ( ) ) E R > 0 x V , from which ( 1 ) is trivial to compute . Berstel and Reutenauer ( 1988 ) give a sufficiently general finite-state framework to allow this : weights may fall in any set K ( instead of R ) . Multiplication and addition are replaced by binary operations and on K. Thus is used to combine arc weights into a path weight and is used to combine the weights of alternative paths . To sum over infinite sets of cyclic paths we also need a closure operation * , interpreted as k * = ( D' 0 ki . The usual finite-state algorithms work if ( K , , , * ) has the structure of a closed semiring . Ordinary probabilities fall in the semiring ( R > 0 , + , x , * ) .16 Our novel weights fall in a novel If an arc has probability p and value v , we give it the weight ( p , pv ) , so that our invariant ( see above ) holds if H consists of a single length-0 or length-1 path . The above definitions are designed to preserve our invariant as we build up larger paths and pathsets . lets us concatenate ( e.g. ) simple paths 1 , 2 to get a longer path with P ( ) = P ( 1 ) P ( 2 ) and val ( ) = val ( 1 ) + val ( 2 ) . The definition of guarantees that path s weight will be ( P ( ) , P ( ) val ( ) ) . lets us take the union of two disjoint pathsets , and * computes infinite unions . To compute ( 1 ) now , we only need the total weight ti of accepting paths in xi o f o yi ( Fig. 2 ) . This can be computed with finite-state methods : the machine ( exxi ) of o ( yixc ) is aversion that replaces all input : output labels with c : c , so it maps ( E , 6 ) to the same total weight ti . Minimizing it yields a onestate FST from which ti can be read directly ! The other magical property of the expectation semiring is that it automatically keeps track of the tangled parameter counts . For instance , recall that traversing Q a : x ) Q should have the same effect as traversing both the underlying arcs a :p ) and p : x ) . And indeed , if the underlying arcs have values v1 and v2 , then the composed arc @ a : x ) @ gets weight ,1 , p1v1 ) p ( g N2 , p2v2 ) = ( p1p2 , p1p2 ( v1 + v2 ) ) , just as if it had value v1 + v2 . Some concrete examples of values may be useful : Really we are manipulating weighted relations , not FSTs . We may combine FSTs , or determinize or minimize them , with any variant of the semiringweighted algorithms . As long as the resulting FST computes the right weighted relation , the arrangement of its states , arcs , and labels is unimportant . The same semiring may be used to compute gradients . We would like to find f ( xi , yi ) and its gradient with respect to , where f is real-valued but need not be probabilistic . Whatever procedures are used to evaluate f ( xi , yi ) exactly or approximatelyfor example , FST operations to compile f followed by minimization of ( c x xi ) o f o ( yi x c ) can simply be applied over the expectation semiring , replacing each weight p by ( p , Vp ) and replacing the usual arithmetic operations with , , etc . 18 ( 2 ) ( 4 ) preserve the gradient ( ( 2 ) is the derivative product rule ) , so this computation yields ( f ( xi , yi ) , Vf ( xi , yi ) ) . 5 Removing Inefficiencies Now for some important remarks on efficiency : Computing ti is an instance of the well-known algebraic path problem ( Lehmann , 1977 ; Tar an , 1981a ) . Let Ti = xiofoyi . Then ti is the total semiring weight w0n of paths in Ti from initial state 0 to final state n ( assumed WLOG to be unique and unweighted ) . It is wasteful to compute ti as suggested earlier , by minimizing ( cxxi ) of o ( yixE ) , since then the real work is done by an c-closure step ( Mohri , 2002 ) that implements the all-pairs version of algebraic path , whereas all we need is the single-source version . If n and m are the number of states and edges ,19 then both problems are O ( n3 ) in the worst case , but the single-source version can be solved in essentially O ( m ) time for acyclic graphs and other reducible flow graphs ( Tar an , 1981b ) . For a general graph Ti , Tar an ( 1981b ) shows how to partition into hard subgraphs that localize the cyclicity or irreducibility , then run the O ( n3 ) algorithm on each subgraph ( thereby reducing n to as little as 1 ) , and recombine the results . The overhead of partitioning and recombining is essentially only O ( m ) . For speeding up the O ( n3 ) problem on subgraphs , one can use an approximate relaxation technique ( Mohri , 2002 ) . Efficient hardware implementation is also possible via chip-level parallelism ( Rote , 1985 ) . In many cases of interest , Ti is an acyclic graph .20 Then Tar ans method computes w0j for each j in topologically sorted order , thereby finding ti in a linear number of and operations . For HMMs ( footnote 11 ) , Ti is the familiar trellis , and we would like this computation of ti to reduce to the forwardbackward algorithm ( Baum , 1972 ) . But notice that it has no backward pass . In place of pushing cumulative probabilities backward to the arcs , it pushes cumulative arcs ( more generally , values in V ) forward to the probabilities . This is slower because our and are vector operations , and the vectors rapidly lose sparsity as they are added together . We therefore reintroduce a backward pass that lets us avoid and when computing ti ( so they are needed only to construct Ti ) . This speedup also works for cyclic graphs and for any V . Write wjk as ( pjk , vjk ) , and let w1jk = ( p1jk , v1 jk ) denote the weight of the edge from j to k. 19 Then it can be shown that w0n = ( p0n , Ej , k p0jv1jkpkn ) . The forward and backward probabilities , p0j and pkn , can be computed using single-source algebraic path for the simpler semiring ( R , + , x , ) or equivalently , by solving a sparse linear system of equations over R , a much-studied problem at O ( n ) space , O ( nm ) time , and faster approximations ( Greenbaum , 1997 ) . Here , the forward and backward probabilities can be computed in time only O ( m + n log n ) ( Fredman and Tar an , 1987 ) . k-best variants are also possible . 6 Discussion We have exhibited a training algorithm for parameterized finite-state machines . Some specific consequences that we believe to be novel are ( 1 ) an EM algorithm for FSTs with cycles and epsilons ; ( 2 ) training algorithms for HMMs and weighted contextual edit distance that work on incomplete data ; ( 3 ) endto-end training of noisy channel cascades , so that it is not necessary to have separate training data for each machine in the cascade ( cf . Knight and Graehl , 1998 ) , although such data could also be used ; ( 4 ) training of branching noisy channels ( footnote 7 ) ; ( 5 ) discriminative training with incomplete data ; ( 6 ) training of conditional MEMMs ( McCallum et al . , 2000 ) and conditional random fields ( Lafferty et al . , 2001 ) on unbounded sequences . We are particularly interested in the potential for quickly building statistical models that incorporate linguistic and engineering insights . Many models of interest can be constructed in our paradigm , without having to write new code . Bringing diverse models into the same declarative framework also allows one to apply new optimization methods , objective functions , and finite-state algorithms to all of them . To avoid local maxima , one might try deterministic annealing ( Rao and Rose , 2001 ) , or randomized methods , or place a prior on . Another extension is to adjust the machine topology , say by model merging ( Stolcke and Omohundro , 1994 ) . Such techniques build on our parameter estimation method . The key algorithmic ideas of this paper extend from forward-backward-style to inside-outside-style methods . For example , it should be possible to do end-to-end training of a weighted relation defined by an interestingly parameterized synchronous CFG composed with tree transducers and then FSTs . "}
  },
    {
    "id": "P02-1004",
    "result":     [
            {
        "value":         {
          "start": 727,
          "end": 734,
          "text": "Nitrogen",
          "labels": ["Tool"]
        },
        "id": 221
      },
            {
        "value":         {
          "start": 987,
          "end": 1012,
          "text": "word-bigram language model",
          "labels": ["Method"]
        },
        "id": 218
      },
            {
        "value":         {
          "start": 1060,
          "end": 1065,
          "text": "FERGUS",
          "labels": ["Tool"]
        },
        "id": 219
      },
            {
        "value":         {
          "start": 1218,
          "end": 1244,
          "text": "tree-based stochastic model",
          "labels": ["Method"]
        },
        "id": 220
      },
            {
        "value":         {
          "start": 1275,
          "end": 1282,
          "text": "Nitrogen",
          "labels": ["Tool"]
        },
        "id": 221
      },
            {
        "value":         {
          "start": 1544,
          "end": 1551,
          "text": "Nitrogen",
          "labels": ["Tool"]
        },
        "id": 221
      },
            {
        "value":         {
          "start": 1612,
          "end": 1658,
          "text": "Amalgam ( A Machine Learned Generation Module )",
          "labels": ["Tool"]
        },
        "id": 221
      },
            {
        "value":         {
          "start": 1914,
          "end": 1920,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 2681,
          "end": 2688,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 3193,
          "end": 3199,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 3841,
          "end": 3847,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 3977,
          "end": 3983,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 4128,
          "end": 4133,
          "text": "NLPWin",
          "labels": ["Tool"]
        },
        "id": 226
      },
            {
        "value":         {
          "start": 4589,
          "end": 4595,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 4937,
          "end": 4951,
          "text": "WinMine toolkit",
          "labels": ["Tool"]
        },
        "id": 224
      },
            {
        "value":         {
          "start": 5200,
          "end": 5219,
          "text": "decision tree models",
          "labels": ["Method"]
        },
        "id": 225
      },
            {
        "value":         {
          "start": 5224,
          "end": 5230,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 5442,
          "end": 5447,
          "text": "NLPWin",
          "labels": ["Tool"]
        },
        "id": 226
      },
            {
        "value":         {
          "start": 5809,
          "end": 5822,
          "text": "decision trees",
          "labels": ["Method"]
        },
        "id": 226
      },
            {
        "value":         {
          "start": 5996,
          "end": 6003,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8263,
          "end": 8269,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 9440,
          "end": 9458,
          "text": "decision tree model",
          "labels": ["Method"]
        },
        "id": 229
      },
            {
        "value":         {
          "start": 9550,
          "end": 9556,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 10365,
          "end": 10371,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 10549,
          "end": 10556,
          "text": "Accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 10662,
          "end": 10670,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 10674,
          "end": 10679,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 10770,
          "end": 10777,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 12323,
          "end": 12329,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 12979,
          "end": 12985,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 13069,
          "end": 13087,
          "text": "decision tree model",
          "labels": ["Method"]
        },
        "id": 229
      },
            {
        "value":         {
          "start": 13344,
          "end": 13362,
          "text": "decision tree model",
          "labels": ["Method"]
        },
        "id": 229
      },
            {
        "value":         {
          "start": 13408,
          "end": 13416,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 13420,
          "end": 13425,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 13431,
          "end": 13438,
          "text": "Fmeasure",
          "labels": ["Metric"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 15165,
          "end": 15181,
          "text": "Microsoft Encarta",
          "labels": ["Dataset"]
        },
        "id": 228
      },
            {
        "value":         {
          "start": 17404,
          "end": 17411,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17896,
          "end": 17903,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18421,
          "end": 18427,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 20133,
          "end": 20151,
          "text": "decision tree model",
          "labels": ["Method"]
        },
        "id": 229
      },
            {
        "value":         {
          "start": 20248,
          "end": 20256,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20260,
          "end": 20265,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20271,
          "end": 20279,
          "text": "F-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 20923,
          "end": 20930,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21862,
          "end": 21868,
          "text": "WinMine",
          "labels": ["Tool"]
        },
        "id": 230
      },
            {
        "value":         {
          "start": 21960,
          "end": 21966,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 23491,
          "end": 23498,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23572,
          "end": 23578,
          "text": "Amalgam",
          "labels": ["Tool"]
        },
        "id": 231
      }
    ],
    "data": {"text": "Machine-learned contexts for linguistic operations in German sentence realization 1 Introduction The last stage of natural language generation , sentence realization , creates the surface string from an abstract ( typically semantic ) representation . This mapping from abstract representation to surface string can be direct , or it can employ intermediate syntactic representations which significantly constrain the output . Furthermore , the mapping can be performed purely by rules , by application of statistical models , or by a combination of both techniques . Among the systems that use statistical or machine learned techniques in sentence realization , there are various degrees of intermediate syntactic structure . Nitrogen ( Langkilde and Knight , 1998a , 1998b ) produces a large set of alternative surface realizations of an input structure ( which can vary in abstractness ) . This set of candidate surface strings , represented as a word lattice , is then rescored by a word-bigram language model , to produce the bestranked output sentence . FERGUS ( Bangalore and Rambow , 2000 ) , on the other hand , employs a model of syntactic structure during sentence realization . In simple terms , it adds a tree-based stochastic model to the approach taken by the Nitrogen system . This tree-based model chooses a best-ranked XTAG representation for a given dependency structure . Possible linearizations of the XTAG representation are generated and then evaluated by a language model to pick the best possible linearization , as in Nitrogen . In contrast , the sentence realization system code-named Amalgam ( A Machine Learned Generation Module ) ( Corston-Oliver et al . , 2002 ; Gamon et al . , 2002b ) employs a series of linguistic operations which map a semantic representation to a surface syntactic tree via intermediate syntactic representations . The contexts for most of these operations in Amalgam are machine learned . The resulting syntactic tree contains all the necessary information on its leaf nodes from which a surface string can be read . The goal of this paper is to show that it is possible to learn accurately the contexts for linguistically complex operations in sentence realization . We propose that learning the contexts for the application of these linguistic operations can be viewed as per-operation classification problems . This approach combines advantages of a linguistically informed approach to sentence realization with the advantages of a machine Abstract We show that it is possible to learn the contexts for linguistic operations which map a semantic representation to a surface syntactic tree in sentence realization with high accuracy . We cast the problem of learning the contexts for the linguistic operations as classification tasks , and apply straightforward machine learning techniques , such as decision tree learning . The training data consist of linguistic features extracted from syntactic and semantic representations produced by a linguistic analysis system . The target features are extracted from links to surface syntax trees . Our evidence consists of four examples from the German sentence realization system code-named Amalgam : case assignment , assignment of verb position features , extraposition , and syntactic aggregation learning approach . The linguistically informed approach allows us to deal with complex linguistic phenomena , while machine learning automates the discovery of contexts that are linguistically relevant and relevant for the domain of the data . The machine learning approach also facilitates adaptation of the system to a new domain or language . Furthermore , the quantitative nature of the machine learned models permits finer distinctions and ranking among possible solutions . To substantiate our claim , we provide four examples from Amalgam : assignment of case , assignment of verb position features , extraposition , and syntactic aggregation . 2 Overview of Amalgam Amalgam takes as its input a sentence-level semantic graph representation with fixed lexical choices for content words ( the logical form graph of the NLPWin system see ( Heidorn , 2000 ) ) . This representation is first degraphed into a tree , and then gradually augmented by the insertion of function words , assignment of case and verb position features , syntactic labels , etc. , and transformed into a syntactic surface tree . A generative statistical language model establishes linear order in the surface tree ( Ringger et al. , in preparation ) , and a surface string is generated from the leaf nodes . Amalgam consists of eight stages . We label these ML ( machine-learned context ) or RB ( rule-based ) . Stage 1 Pre-processing ( RB ) : Stage 8 Inflectional generation ( RB ) All machine learned components , with the exception of the generative language model for ordering of constituents ( stage 5 ) , are decision tree classifiers built with the WinMine toolkit ( Chickering et al . , 1997 ; Chickering , nd . ) . There are a total of eighteen decision tree classifiers in the system . The complexity of the decision trees varies with the complexity of the modeled task . The number of branching nodes in the decision tree models in Amalgam ranges from 3 to 447 . 3 Data and feature extraction The data for all of the models were drawn from a set of 100,000 sentences from technical software manuals and help files . The sentences are analyzed by the NLPWin system , which provides a syntactic and logical form analysis . Nodes in the logical form representation are linked to the corresponding syntactic nodes , allowing us to learn contexts for the mapping from the semantic representation to a surface syntax tree . The data is split 70/30 for training versus model parameter tuning . For each set of data we built decision trees at several different levels of granularity ( by manipulating the prior probability of tree structures to favor simpler structures ) and selected the model with the maximal accuracy as determined on the parameter tuning set . All models are then tested on data extracted from a separate blind set of 10,000 sentences from the same domain . For both training and test , we only extract features from sentences that have received a complete , spanning parse : 85.14 % of the sentences in the training and parameter tuning set , and 84.59 % in the blind test set fall into that category . Most sentences yield more than one training case . We attempt to standardize as much as possible the set of features to be extracted . We exploit the full set of features and attributes available in the analysis , instead of pre-determining a small set of potentially relevant features ( Gamon et al. , 2002b ) . This allows us to share the majority of code between the individual feature extraction tasks . More importantly , it enables us to discover new linguistically interesting and/or domainspecific generalizations from the data . Typically , we extract the full set of available analysis features of the node under investigation , its parent and its grandparent , with the only restriction being that these features need to be available at the stage where the model is consulted at generation runtime . This provides us with a sufficiently large structural context for the operations . In addition , for some of the models we add a small set of features that we believe to be important for the task at hand , and that can not easily be expressed as a combination of analysis features/attributes on constituents . Most features , such as lexical subcategorization features and semantic features such as [ Definite ] are binary . Other features , such as syntactic label or semantic relation , have as many as 25 values . Training time on a standard 500 MHz PC ranges from one hour to six hours . 4 Assignment of case In German sentence realization , proper assignment of morphological case is essential for fluent and comprehensible output . German is a language with fairly free constituent order , and the identification of functional roles , such as subject versus object , is not determined by position in the sentence , as in English , but by morphological marking of one of the four cases : nominative , accusative , genitive or dative . In Amalgam , case assignment is one of the last steps in the Flesh-out stage ( stage 2 ) . Morphological realization of case can be ambiguous in German ( for example , a feminine singular NP is ambiguous between accusative and nominative case ) . Since the morphological realization of case depends on the gender , number and morphological paradigm of a given NP , we chose to only consider NP nodes with unambiguous case as training data for the model1 . As the target feature for this model is 1 Ideally , we should train the case assignment model on a corpus that is hand-disambiguated for case . In the absence of such a corpus , though , we believe that our approach is linguistically justified . The case of an NP depends solely on the syntactic context it appears in . morphological case , it has four possible values for the four cases in German . 4.1 Features in the case assignment model For each data point , a total of 712 features was extracted . Of the 712 features available to the decision tree building tools , 72 were selected as having predictive value in the model . The selected features fall into the following categories : 4.2 The case assignment model The decision tree model for case assignment has 226 branching nodes , making it one of the most complex models in Amalgam . For each nominal node in the 10,000 sentence test set , we compared the prediction of the model to the Since we want to learn the syntactically determining factors for case , using unambiguously case marked NPs for training seems justified . morphological case compatible with that node . The previously mentioned example of a singular feminine NP , for example , would yield a correct if the model had predicted nominative or accusative case ( because the NP is morphologically ambiguous between accusative and nominative ) , and it would yield an incorrect if the model had predicted genitive or dative . This particular evaluation setup was a necessary compromise because of the absence of a handannotated corpus with disambiguated case in our domain . The caveat here is that downstream models in the Amalgam pipeline that pick up on case as one of their features rely on the absolute accuracy of the assigned case , not the relative accuracy with respect to morphological ambiguity . Accuracy numbers for each of the four case assignments are given in Table 1 . Note that it is impossible to give precision / recall numbers , without a hand-disambiguated test set . The baseline for this task is 0.7049 ( accuracy if the most frequent case ( nominative ) had been assigned to all NPs ) . 5 Assignment of verb position features One of the most striking properties of German is the distributional pattern of verbs in main and subordinate clauses . Most descriptive accounts of German syntax are based on a topology of the German sentence that treats the position of the verb as the fixed frame around which other syntactic constituents are organized in relatively free order ( cf. Eisenberg , 1999 ; Engel , 1996 ) . The position of the verb in German is non-negotiable ; errors in the positioning of the verb result in gibberish , whereas most permutations of other constituents only result in less fluent output . Depending on the position of the finite verb , German sentences and verb phrases are classified as being verb-initial , verb-second or verbfinal . In verb-initial clauses ( e.g. , in imperatives ) , the finite verb is in initial position . Verb-second sentences contain one constituent preceding the finite verb , in the so-called pre-field . The finite verb is followed by any number of constituents in the middle-field , and any non-finite verbs are positioned at the right periphery of the clause , possibly followed by extraposed material or complement clauses ( the post-field ) . Verb-final clauses contain no verbal element in the verbsecond position : all verbs are clustered at the right periphery , preceded by any number of constituents and followed only by complement clauses and extraposed material . During the Flesh-out stage in Amalgam , a decision tree classifier is consulted to make a classification decision among the four verb positions : verb-initial , verb-second , verbfinal , and undefined . The value undefined for the target feature of verb position is extracted for those verbal constituents where the local syntactic context is too limited to make a clear distinction between initial , second , or final position of the verb . The number of undefined verb positions is small compared to the number of clearly established verb positions : in the test set , there were only 690 observed cases of undefined verb position out of a total of 15,492 data points . At runtime in Amalgam , verb position features are assigned based on the classification provided by the decision tree model . 5.1 Features in the verb position model For each data point , 713 features were extracted . Of those features , 41 were selected by the decision tree algorithm . The selected features fall into the following categories : 5.2 The verb position model The decision tree model for verb position has 115 branching nodes . Precision , recall and Fmeasure for the model are given in Table 2 . As a point of reference for the verb position classifier , assigning the most frequent value ( second ) of the target feature yields a baseline score of 0.4240 . 6 Extraposition In both German and English it is possible to extrapose clausal material to the right periphery of the sentence ( extraposed clauses underlined in the examples below ) : Relative clause extraposition : English : A man just left who had come to ask a question . German : Der Mann ist gerade weggegangen , der gekommen war , um eine Frage zu stellen . Infinitival clause extraposition : English : A decision was made to leave the country . German : Eine Entscheidung wurde getroffen , das Land zu verlassen . Complement clause extraposition : English : A rumour has been circulating that he is ill . German : Ein Gercht ging um , dass er krank ist . Extraposition is not obligatory like other types of movement ( such as Wh-movement ) . Both extraposed and non-extraposed versions of a sentence are acceptable , with varying degrees of fluency . The interesting difference between English and German is the frequency of this phenomenon . While it can easily be argued that English sentence realization may ignore extraposition and still result in very fluent output , the fluency of sentence realization for German will suffer much more from the lack of a good extraposition mechanism . We profiled data from various domains ( Gamon et al. 2002a ) to substantiate this linguistic claim ( see Uszkoreit et al. 1998 for similar results ) . In the technical domain , more than one third of German relative clauses are extraposed , as compared to a meagre 0.22 % of English relative clauses . In encyclopaedia text ( Microsoft Encarta ) , approximately every fifth German relative clause is extraposed , compared to only 0.3 % of English relative clauses . For complement clauses and infinitival clauses , the differences are not as striking , but still significant : in the technical and encyclopaedia domains , extraposition of infinitival and complement clauses in German ranges from 1.5 % to 3.2 % , whereas English only shows a range from 0 % to 0.53 % . We chose to model extraposition as an iterative movement process from the original attachment site to the next higher node in the tree ( for an alternative one-step solution and a comparison of the two approaches see ( Gamon et al. , 2002a ) ) . The target feature of the model is the answer to the yes/no question Should the clause move from node X to the parent of node X ? . 6.1 Features in the extraposition model The tendency of a clause to be extraposed depends on properties of both the clause itself ( e.g. , some notion of heaviness ) and the current attachment site . Very coarse linguistic generalizations are that a relative clause tends to be extraposed if it is sufficiently heavy and if it is followed by verbal material in the same clause . Feature extraction for this model reflects that fact by taking into consideration features on the extraposition candidate , the current attachment site , and potential next higher landing site . This results in a total of 1168 features . Each node in the parent chain of an extraposable clause , up to the actual attachment node , constitutes a single data point During the decision tree building process , 60 features were selected as predictive . They can be classified as follows : 6.2 The extraposition model During testing of the extraposition model , the model was consulted for each extraposable clause to find the highest node to which that clause could be extraposed . In other words , the target node for extraposition is the highest node in the parent chain for which the answer to the classification task Should the clause move from node X to the parent of node X ? is yes with no interceding no answer . The prediction of the model was compared with the actual observed attachment site of the extraposable clause to yield the accuracy figures shown in Table 3 . The model has 116 branching nodes . The baseline for this task is calculated by applying the most frequent value for the target feature ( do n't move ) to all nodes . The baseline for extraposition of infinitival and complement clauses is very high . The number of extraposed clauses of both types in the test set ( fifteen extraposed infinitival clauses and twelve extraposed complement clauses ) is very small , so it comes as no surprise that the model accuracy ranges around the baseline for these two types of extraposed clauses . 7 Syntactic aggregation Any sentence realization component that generates from an abstract semantic representation and strives to produce fluent output beyond simple templates will have to deal with coordination and the problem of duplicated material in coordination . This is generally viewed as a subarea of aggregation in the generation literature ( Wilkinson , 1995 ; Shaw , 1998 ; Reape and Mellish , 1999 ; Dalianis and Hovy , 1993 ) . In Amalgam , the approach we take is strictly intrasentential , along the lines of what has been called conjunction reduction in the linguistic literature ( McCawley , 1988 ) . While this may seem a fairly straightforward task compared to inter-sentential , semantic and lexical aggregation , it should be noted that the cross-linguistic complexity of the phenomenon makes it much less trivial than a first glance at English would suggest . In German , for example , position of the verb in the coordinated VPs plays an important role in determining which duplicated constituent can be omitted . The target feature for the classification task is formulated as follows : In which coordinated constituent is the duplicated constituent to be realized ? . There are three values for the target feature : first , last , and middle . The third value ( middle ) is a default value for cases where neither the first , nor the last coordinated constituent can be identified as the location for the realization of duplicated constituents . At generation runtime , multiple realizations of a constituent in coordination are collected and the aggregation model is consulted to decide on the optimal position in which to realize that constituent . The constituent in that position is retained , while all other duplicates are removed from the tree . 7.1 Features in the syntactic aggregation model A total of 714 features were extracted for the syntactic aggregation model . Each instance of coordination which exhibits duplicated material at the semantic level without corresponding duplication at the syntactic level constitutes a data point . Of these features , 15 were selected as predictive in the process of building the decision tree model : 7.2 The syntactic aggregation model The syntactic aggregation model has 21 branching nodes . Precision , recall and F-measure for the model are given in Table 4 . As was to be expected on the basis of linguistic intuition , the value middle for the target feature did not play any role . In the test set there were only 2 observed instances of that value . The baseline for this task is 0.8566 ( assuming first as the default value ) . Value Precision Recall F-measure last 0.9191 0.9082 0.9136 first 0.9837 0.9867 0.9851 middle 0.0000 0.0000 0.0000 overall 0.9746 accuracy 8 Conclusion and future research We have demonstrated on the basis of four examples that it is possible to learn the contexts for complex linguistic operations in sentence realization with high accuracy . We proposed to standardize most of the feature extraction for the machine learning tasks to all available linguistic features on the node , and its parent and grandparent node . This generalized set of features allows us to rapidly train on new sets of data and to experiment with new machine learning tasks . Furthermore , it prevents us from focusing on a small set of hand-selected features for a given phenomenon ; hence , it allows us to learn new ( and unexpected ) generalizations from new data . We have found decision trees to be useful for our classification problems , but other classifiers are certainly applicable . Decision trees provided an easily accessible inventory of the selected features and some indication of their relative importance in predicting the target features in question . Although our exposition has focused on the preferred value ( the mode ) predicted by the models , decision trees built by WinMine predict a probability distribution over all possible target values . For a system such as Amalgam , built as a pipeline of stages , this point is critical , since finding the best final hypothesis requires the consideration of multiple hypotheses and the concomitant combination of probabilities assigned by the various models in the pipeline to all possible target values . For example , our extraposition model presented above depends upon the value of the verb-position feature , which is predicted upstream in the pipeline . Currently , we greedily pursue the best hypothesis , which includes only the mode of the verb-position models prediction . However , work in progress involves a search that constructs multiple hypotheses incorporating each of the predictions of the verb-position model and their scores , and likewise for all other models . We have found the combination of knowledgeengineered linguistic operations with machinelearned contexts to be advantageous . The knowledge-engineered choice of linguistic operations , allows us to deal with complex linguistic phenomena . Machine learning , on the other hand , automates the discovery of general and domain-specific contexts . This facilitates adaptation of the system to a new domain or even to a new language . It should also be noted that none of the learned models can be easily replaced by a rule . While case assignment , for example , depends to a high degree on the lexical properties of the governing preposition or governing verb , other factors such as semantic relations , etc . , play a significant role , so that any rule approaching the accuracy of the model would have to be quite complex . We are currently adapting Amalgam to the task of French sentence realization , as a test of the linguistic generality of the system . Initial results are encouraging . It appears that much of the feature extraction and many of the linguistic operations are reusable . "}
  },
    {
    "id": "P03-1014",
    "result":     [
            {
        "value":         {
          "start": 246,
          "end": 280,
          "text": "stochastic topological field parser",
          "labels": ["Method"]
        },
        "id": 231
      },
            {
        "value":         {
          "start": 315,
          "end": 325,
          "text": "HPSG parser",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 676,
          "end": 679,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 684,
          "end": 694,
          "text": "LFG parsers",
          "labels": ["Method"]
        },
        "id": 234
      },
            {
        "value":         {
          "start": 735,
          "end": 743,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 2905,
          "end": 2942,
          "text": "probabilistic topological field parser",
          "labels": ["Method"]
        },
        "id": 235
      },
            {
        "value":         {
          "start": 2992,
          "end": 3002,
          "text": "HPSG parser",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 3034,
          "end": 3045,
          "text": "HPSG grammar",
          "labels": ["Method"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 3326,
          "end": 3336,
          "text": "HPSG system",
          "labels": ["Method"]
        },
        "id": 237
      },
            {
        "value":         {
          "start": 3345,
          "end": 3362,
          "text": "topological parser",
          "labels": ["Method"]
        },
        "id": 258
      },
            {
        "value":         {
          "start": 3478,
          "end": 3487,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 4511,
          "end": 4522,
          "text": "HPSG parsing",
          "labels": ["Method"]
        },
        "id": 247
      },
            {
        "value":         {
          "start": 4644,
          "end": 4655,
          "text": "HPSG parsing",
          "labels": ["Method"]
        },
        "id": 247
      },
            {
        "value":         {
          "start": 4816,
          "end": 4832,
          "text": "HPSG chart parser",
          "labels": ["Method"]
        },
        "id": 241
      },
            {
        "value":         {
          "start": 5557,
          "end": 5568,
          "text": "HPSG parsing",
          "labels": ["Method"]
        },
        "id": 247
      },
            {
        "value":         {
          "start": 6439,
          "end": 6461,
          "text": "topological field model",
          "labels": ["Method"]
        },
        "id": 243
      },
            {
        "value":         {
          "start": 6891,
          "end": 6913,
          "text": "topological field model",
          "labels": ["Method"]
        },
        "id": 243
      },
            {
        "value":         {
          "start": 7405,
          "end": 7408,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 7451,
          "end": 7464,
          "text": "NEGRA treebank",
          "labels": ["Dataset"]
        },
        "id": 244
      },
            {
        "value":         {
          "start": 7554,
          "end": 7567,
          "text": "NEGRA treebank",
          "labels": ["Dataset"]
        },
        "id": 244
      },
            {
        "value":         {
          "start": 7597,
          "end": 7604,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 7652,
          "end": 7660,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7666,
          "end": 7671,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 7791,
          "end": 7808,
          "text": "topological parser",
          "labels": ["Method"]
        },
        "id": 258
      },
            {
        "value":         {
          "start": 7879,
          "end": 7888,
          "text": "TnT tagger",
          "labels": ["Method"]
        },
        "id": 244
      },
            {
        "value":         {
          "start": 7950,
          "end": 7961,
          "text": "LoPar parser",
          "labels": ["Method"]
        },
        "id": 245
      },
            {
        "value":         {
          "start": 7994,
          "end": 8005,
          "text": "inaccuracies",
          "labels": ["Metric"]
        },
        "id": 246
      },
            {
        "value":         {
          "start": 8805,
          "end": 8812,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 9155,
          "end": 9158,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 9277,
          "end": 9280,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 9420,
          "end": 9431,
          "text": "HPSG parsing",
          "labels": ["Method"]
        },
        "id": 247
      },
            {
        "value":         {
          "start": 9799,
          "end": 9815,
          "text": "topological trees",
          "labels": ["Method"]
        },
        "id": 247
      },
            {
        "value":         {
          "start": 9845,
          "end": 9859,
          "text": "HPSG structures",
          "labels": ["Method"]
        },
        "id": 248
      },
            {
        "value":         {
          "start": 9968,
          "end": 9971,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 9997,
          "end": 10012,
          "text": "topological tree",
          "labels": ["Method"]
        },
        "id": 250
      },
            {
        "value":         {
          "start": 10138,
          "end": 10153,
          "text": "topological tree",
          "labels": ["Method"]
        },
        "id": 250
      },
            {
        "value":         {
          "start": 10238,
          "end": 10241,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 10558,
          "end": 10561,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 10770,
          "end": 10773,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 11141,
          "end": 11156,
          "text": "topological tree",
          "labels": ["Method"]
        },
        "id": 250
      },
            {
        "value":         {
          "start": 11236,
          "end": 11239,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 11680,
          "end": 11683,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 12268,
          "end": 12309,
          "text": "Whiteboard Annotation Transformer ( WHAT )",
          "labels": ["Method"]
        },
        "id": 250
      },
            {
        "value":         {
          "start": 12412,
          "end": 12424,
          "text": "XSLT engines6",
          "labels": ["Method"]
        },
        "id": 251
      },
            {
        "value":         {
          "start": 12547,
          "end": 12566,
          "text": "XSLT transformations",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 12746,
          "end": 12765,
          "text": "XSLT transformations",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 12788,
          "end": 12805,
          "text": "topological parser",
          "labels": ["Method"]
        },
        "id": 258
      },
            {
        "value":         {
          "start": 12896,
          "end": 12906,
          "text": "HPSG parser",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 13497,
          "end": 13516,
          "text": "topological analysis",
          "labels": ["Method"]
        },
        "id": 253
      },
            {
        "value":         {
          "start": 13957,
          "end": 13969,
          "text": "HPSG analysis",
          "labels": ["Method"]
        },
        "id": 254
      },
            {
        "value":         {
          "start": 15652,
          "end": 15661,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 15800,
          "end": 15809,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 15888,
          "end": 15899,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 15908,
          "end": 15924,
          "text": "topological parse",
          "labels": ["Method"]
        },
        "id": 261
      },
            {
        "value":         {
          "start": 15967,
          "end": 15974,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16292,
          "end": 16310,
          "text": "topological parsers",
          "labels": ["Method"]
        },
        "id": 257
      },
            {
        "value":         {
          "start": 16312,
          "end": 16319,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16472,
          "end": 16481,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 16557,
          "end": 16574,
          "text": "topological parser",
          "labels": ["Method"]
        },
        "id": 258
      },
            {
        "value":         {
          "start": 16581,
          "end": 16590,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 16785,
          "end": 16794,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 16822,
          "end": 16829,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16912,
          "end": 16923,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 16980,
          "end": 16996,
          "text": "topological parse",
          "labels": ["Method"]
        },
        "id": 261
      },
            {
        "value":         {
          "start": 17028,
          "end": 17035,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17174,
          "end": 17181,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17221,
          "end": 17229,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17235,
          "end": 17240,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 17336,
          "end": 17353,
          "text": "topological parses",
          "labels": ["Method"]
        },
        "id": 258
      },
            {
        "value":         {
          "start": 17498,
          "end": 17506,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17517,
          "end": 17522,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 17561,
          "end": 17577,
          "text": "topological parse",
          "labels": ["Method"]
        },
        "id": 261
      },
            {
        "value":         {
          "start": 17590,
          "end": 17592,
          "text": "TnT",
          "labels": ["Method"]
        },
        "id": 350
      },
            {
        "value":         {
          "start": 17615,
          "end": 17623,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17664,
          "end": 17673,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 17703,
          "end": 17711,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17783,
          "end": 17791,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17855,
          "end": 17863,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 17923,
          "end": 17931,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18279,
          "end": 18287,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18406,
          "end": 18417,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 18437,
          "end": 18443,
          "text": "entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 18740,
          "end": 18751,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 18758,
          "end": 18767,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 18805,
          "end": 18821,
          "text": "topological parse",
          "labels": ["Method"]
        },
        "id": 261
      },
            {
        "value":         {
          "start": 18924,
          "end": 18930,
          "text": "entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 18948,
          "end": 18956,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18962,
          "end": 18967,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 18972,
          "end": 18990,
          "text": "topological parsing",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 19091,
          "end": 19102,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 19283,
          "end": 19289,
          "text": "entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 19726,
          "end": 19733,
          "text": "Coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 19890,
          "end": 19898,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20003,
          "end": 20008,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20074,
          "end": 20081,
          "text": "Coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 20235,
          "end": 20246,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 20264,
          "end": 20271,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 20314,
          "end": 20320,
          "text": "entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 20338,
          "end": 20346,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20350,
          "end": 20355,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20361,
          "end": 20368,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 20450,
          "end": 20458,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20476,
          "end": 20481,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20487,
          "end": 20494,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 20511,
          "end": 20519,
          "text": "f-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 20545,
          "end": 20553,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20559,
          "end": 20564,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20616,
          "end": 20624,
          "text": "f-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 20696,
          "end": 20704,
          "text": "F-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 20759,
          "end": 20767,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20773,
          "end": 20778,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20815,
          "end": 20822,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 20922,
          "end": 20930,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20941,
          "end": 20946,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20950,
          "end": 20957,
          "text": "Coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 21077,
          "end": 21088,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 21121,
          "end": 21130,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 21412,
          "end": 21423,
          "text": "NEGRA corpus",
          "labels": ["Dataset"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 21482,
          "end": 21493,
          "text": "HPSG grammar",
          "labels": ["Method"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 21892,
          "end": 21910,
          "text": "topological parsing",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 22223,
          "end": 22231,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 22292,
          "end": 22301,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 22559,
          "end": 22566,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 22718,
          "end": 22725,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 23041,
          "end": 23048,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 23428,
          "end": 23437,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 23751,
          "end": 23760,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 23926,
          "end": 23935,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 24089,
          "end": 24098,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 24294,
          "end": 24302,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24314,
          "end": 24323,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 24716,
          "end": 24725,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 24813,
          "end": 24821,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24849,
          "end": 24860,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 24964,
          "end": 24970,
          "text": "entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 25075,
          "end": 25083,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25132,
          "end": 25141,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 25200,
          "end": 25211,
          "text": "tree entropy",
          "labels": ["Metric"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 25481,
          "end": 25489,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25988,
          "end": 25995,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 26172,
          "end": 26182,
          "text": "HPSG parses",
          "labels": ["Method"]
        },
        "id": 263
      },
            {
        "value":         {
          "start": 26381,
          "end": 26384,
          "text": "HPSG",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 26553,
          "end": 26571,
          "text": "topological parsing",
          "labels": ["Method"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 26666,
          "end": 26675,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      }
    ],
    "data": {"text": "Integrated Shallow and Deep Parsing : TopP meets HPSG Abstract We present a novel , data-driven method for integrated shallow and deep parsing . Mediated by an XML-based multi-layer annotation architecture , we interleave a robust , but accurate stochastic topological field parser of German with a constraintbased HPSG parser . Our annotation-based method for dovetailing shallow and deep phrasal constraints is highly flexible , allowing targeted and fine-grained guidance of constraint-based parsing . We conduct systematic experiments that demonstrate substantial performance gains .1 1 Introduction One of the strong points of deep processing ( DNLP ) technology such as HPSG or LFG parsers certainly lies with the high degree of precision as well as detailed linguistic analysis these systems are able to deliver . Although considerable progress has been made in the area of processing speed , DNLP systems still can not rival shallow and medium depth technologies in terms of throughput and robustness . As a net effect , the impact of deep parsing technology on application-oriented NLP is still fairly limited . With the advent of XML-based hybrid shallowdeep architectures as presented in ( Grover and Lascarides , 2001 ; Crysmann et al. , 2002 ; Uszkoreit , 2002 ) it has become possible to integrate the added value of deep processing with the performance and robustness of shallow processing . So far , integration has largely focused on the lexical level , to improve upon the most urgent needs in increasing the robustness and coverage of deep parsing systems , namely lexical coverage . While integration in ( Grover and Lascarides , 2001 ) was still restricted to morphological and PoS information , ( Crysmann et al. , 2002 ) extended shallow-deep integration at the lexical level to lexico-semantic information , and named entity expressions , including multiword expressions . ( Crysmann et al. , 2002 ) assume a vertical , pipeline scenario where shallow NLP tools provide XML annotations that are used by the DNLP system as a preprocessing and lexical interface . The perspective opened up by a multi-layered , data-centric architecture is , however , much broader , in that it encourages horizontal cross-fertilisation effects among complementary and/or competing components . One of the culprits for the relative inefficiency of DNLP parsers is the high degree of ambiguity found in large-scale grammars , which can often only be resolved within a larger syntactic domain . Within a hybrid shallow-deep platform one can take advantage of partial knowledge provided by shallow parsers to pre-structure the search space of the deep parser . In this paper , we will thus complement the efforts made on the lexical side by integration at the phrasal level . We will show that this may lead to considerable performance increase for the DNLP component . More specifically , we combine a probabilistic topological field parser for German ( Becker and Frank , 2002 ) with the HPSG parser of ( Callmeier , 2000 ) . The HPSG grammar used is the one originally developed by ( Muller and Kasper , 2000 ) , with significant performance enhancements by B . Crysmann . In Section 2 we discuss the mapping problem involved with syntactic integration of shallow and deep analyses and motivate our choice to combine the HPSG system with a topological parser . Section 3 outlines our basic approach towards syntactic shallow-deep integration . Section 4 introduces various confidence measures , to be used for fine-tuning of phrasal integration . Sections 5 and 6 report on experiments and results of integrated shallow-deep parsing , measuring the effect of various integration parameters on performance gains for the DNLP component . Section 7 concludes and discusses possible extensions , to address robustness issues . 2 Integrated Shallow and Deep Processing The prime motivation for integrated shallow-deep processing is to combine the robustness and efficiency of shallow processing with the accuracy and fine-grainedness of deep processing . Shallow analyses could be used to pre-structure the search space of a deep parser , enhancing its efficiency . Even if deep analysis fails , shallow analysis could act as a guide to select partial analyses from the deep parsers chart enhancing the robustness of deep analysis , and the informativeness of the combined system . In this paper , we concentrate on the usage of shallow information to increase the efficiency , and potentially the quality , of HPSG parsing . In particular , we want to use analyses delivered by an efficient shallow parser to pre-structure the search space of HPSG parsing , thereby enhancing its efficiency , and guiding deep parsing towards a best-first analysis suggested by shallow analysis constraints . The search space of an HPSG chart parser can be effectively constrained by external knowledge sources if these deliver compatible partial subtrees , which would then only need to be checked for compatibility with constituents derived in deep parsing . Raw constituent span information can be used to guide the parsing process by penalizing constituents which are incompatible with the precomputed shape . Additional information about proposed constituents , such as categorial or featural constraints , provide further criteria for prioritising compatible , and penalising incompatible constituents in the deep parsers chart . An obvious challenge for our approach is thus to identify suitable shallow knowledge sources that can deliver compatible constraints for HPSG parsing . 2.1 The Shallow-Deep Mapping Problem However , chunks delivered by state-of-the-art shallow parsers are not isomorphic to deep syntactic analyses that explicitly encode phrasal embedding structures . As a consequence , the boundaries of deep grammar constituents in ( 1 . a ) can not be predetermined on the basis of a shallow chunk analysis ( 1 . b ) . Moreover , the prevailing greedy bottom-up processing strategies applied in chunk parsing do not take into account the macro-structure of sentences . They are thus easily trapped in cases such as ( 2 ) . In sum , state-of-the-art chunk parsing does neither provide sufficient detail , nor the required accuracy to act as a guide for deep syntactic analysis . 2.2 Stochastic Topological Parsing Recently , there is revived interest in shallow analyses that determine the clausal macro-structure of sentences . The topological field model of ( German ) syntax ( Hohle , 1983 ) divides basic clauses into distinct fields pre - , middle - , and post-fields delimited by verbal or sentential markers , which constitute the left / right sentence brackets . This model of clause structure is underspecified , or partial as to non-sentential constituent structure , but provides a theory-neutral model of sentence macro-structure . Due to its linguistic underpinning , the topological field model provides a pre-partitioning of complex sentences that is ( i ) highly compatible with deep syntactic analysis , and thus ( ii ) maximally effective to increase parsing efficiency if interleaved with deep syntactic analysis ; ( iii ) partiality regarding the constituency of non-sentential material ensures robustness , coverage , and processing efficiency . ( Becker and Frank , 2002 ) explored a corpusbased stochastic approach to topological field parsing , by training a non-lexicalised PCFG on a topological corpus derived from the NEGRA treebank of German . Measured on the basis of hand-corrected PoS-tagged input as provided by the NEGRA treebank , the parser achieves 100 % coverage for length < 40 ( 99.8 % for all ) . Labelled precision and recall are around 93 % . Perfect match ( full tree identity ) is about 80 % ( cf. Table 1 , disamb + ) . In this paper , the topological parser was provided a tagger front-end for free text processing , using the TnT tagger ( Brants , 2000 ) . The grammar was ported to the efficient LoPar parser of ( Schmid , 2000 ) . Tagging inaccuracies lead to a drop of 5.1 / 4.7 percent dis - cove - perfect LP LR 0CB 2CB amb rage match in % in % in % in % + 100.0 80.4 93.4 92.9 92.1 98.9 99.8 72.1 88.3 88.2 87.8 97.9 age points in LP / LR , and 8.3 percentage points in perfect match rate ( Table 1 , disamb ) . As seen in Figure 1 , the topological trees abstract away from non-sentential constituency phrasal fields MF ( middle-field ) and VF ( pre-field ) directly expand to PoS tags . By contrast , they perfectly render the clausal skeleton and embedding structure of complex sentences . In addition , parameterised category labels encode larger syntactic contexts , or constructions , such as clause type ( CL-V2 , - SUBCL , - REL ) , or inflectional patterns of verbal clusters ( RKVFIN,-VPART ) . These properties , along with their high accuracy rate , make them perfect candidates for tight integration with deep syntactic analysis . Moreover , due to the combination of scrambling and discontinuous verb clusters in German syntax , a deep parser is confronted with a high degree of local ambiguity that can only be resolved at the clausal level . Highly lexicalised frameworks such as HPSG , however , do not lend themselves naturally to a topdown parsing strategy . Using topological analyses to guide the HPSG will thus provide external top-down information for bottom-up parsing . 3 TopP meets HPSG Our work aims at integration of topological and HPSG parsing in a data-centric architecture , where each component acts independently2 in contrast to the combination of different syntactic formalisms within a unified parsing process .3 Data-based integration not only favours modularity , but facilitates flexible and targeted dovetailing of structures . 3.1 Mapping Topological to HPSG Structures While structurally similar , topological trees are not fully isomorphic to HPSG structures . In Figure 1 , e.g . , the span from the verb hatte to the end of the sentence forms a constituent in the HPSG analysis , while in the topological tree the same span is dominated by a sequence of categories : LK , MF , RK , NF . Yet , due to its linguistic underpinning , the topological tree can be used to systematically predict key constituents in the corresponding target HPSG 2See Section 6 for comparison to recent work on integrated chunk-based and dependency parsing in ( Daum et al . , 2003 ) . 3As , for example , in ( Duchier and Debusmann , 2001 ) . analysis . We know , for example , that the span from the fronted verb ( LK-VFIN ) till the end of its clause CL-V2 corresponds to an HPSG phrase . Also , the first position that follows this verb , here the leftmost daughter of MF , demarcates the left edge of the traditional VP . Spans of the vorfeld VF and clause categories CL exactly match HPSG constituents . Category CL-V2 tells us that we need to reckon with a fronted verb in position of its LK daughter , here 3 , while in CL-SUBCL we expect a complementiser in the position of LK , and a finite verb within the right verbal complex RK , which spans positions 12 to 13 . In order to communicate such structural constraints to the deep parser , we scan the topological tree for relevant configurations , and extract the span information for the target HPSG constituents . The resulting map constraints ( Fig. 1 ) encode a bracket type name4 that identifies the target constituent and its left and right boundary , i.e. the concrete span in the sentence under consideration . The span is encoded by the word position index in the input , which is identical for the two parsing processes .5 In addition to pure constituency constraints , a skilled grammar writer will be able to associate specific HPSG grammar constraints positive or negative with these bracket types . These additional constraints will be globally defined , to permit finegrained guidance of the parsing process . This and further information ( cf. Section 4 ) is communicated to the deep parser by way of an XML interface . 3.2 Annotation-based Integration In the annotation-based architecture of ( Crysmann et al. , 2002 ) , XML-encoded analysis results of all components are stored in a multi-layer XML chart . The architecture employed in this paper improves on ( Crysmann et al . , 2002 ) by providing a central Whiteboard Annotation Transformer ( WHAT ) that supports flexible and powerful access to and transformation of XML annotation based on standard XSLT engines6 ( see ( Schafer , 2003 ) for more details on WHAT ) . Shallow-deep integration is thus fully annotation driven . Complex XSLT transformations are applied to the various analyses , in order to extract or combine independent knowledge sources , including XPath access to information stored in shallow annotation , complex XSLT transformations to the output of the topological parser , and extraction of bracket constraints . 3.3 Shaping the Deep Parser’s Search Space The HPSG parser is an active bidirectional chart parser which allows flexible parsing strategies by using an agenda for the parsing tasks .7 To compute priorities for the tasks , several information sources can be consulted , e.g . the estimated quality of the participating edges or external resources like PoS tagger results . Object-oriented implementation of the priority computation facilitates exchange and , moreover , combination of different ranking strategies . Extending our current regime that uses PoS tagging for prioritisation , 8 we are now utilising phrasal constraints ( brackets ) from topological analysis to enhance the hand-crafted parsing heuristic employed so far . Conditions for changing default priorities Every bracket pair brx computed from the topological analysis comes with a bracket type x that defines its behaviour in the priority computation . Each bracket type can be associated with a set of positive and negative constraints that state a set of permissible or forbidden rules and / or feature structure configurations for the HPSG analysis . The bracket types fall into three main categories : left - , right - , and fully matching brackets . A rightmatching bracket may affect the priority of tasks whose resulting edge will end at the right bracket of a pair , like , for example , a task that would combine edges C and F or C and D in Fig. 2 . Left-matching brackets work analogously . For fully matching brackets , only tasks that produce an edge that matches the span of the bracket pair can be affected , like , e.g. , a task that combines edges B and C in Fig. 2 . If , in addition , specified rule as well as feature structure constraints hold , the task is rewarded if they are positive constraints , and penalised if they are negative ones . All tasks that produce crossing edges , i.e. where one endpoint lies strictly inside the bracket pair and the other lies strictly outside , are penalised , e.g. , a task that combines edges A and B . This behaviour can be implemented efficiently when we assume that the computation of a task pri ority takes into account the priorities of the tasks it builds upon . This guarantees that the effect of changing one task in the parsing process will propagate to all depending tasks without having to check the bracket conditions repeatedly . For each task , it is sufficient to examine the startand endpoints of the building edges to determine if its priority is affected by some bracket . Only four cases can occur : For left - / right-matching brackets , a match behaves exactly like the corresponding left or right hit . Computing the new priority If the priority of a task is changed , the change is computed relative to the default priority . We use two alternative confidence values , and a hand-coded parameter y ( x ) , to adjust the impact on the default priority heuristics . conf , , t ( brx ) specifies the confidence for a concrete bracket pair brx of type x in a given sentence , based on the tree entropy of the topological parse . confpr specifies a measure of expected accuracy for each bracket type . Sec. 4 will introduce these measures . The priority p ( t ) of a task t involving a bracket brx is computed from the default priority p ( t ) by : 4 Confidence Measures This way of calculating priorities allows flexible parameterisation for the integration of bracket constraints . While the topological parsers accuracy is high , we need to reckon with ( partially ) wrong analyses that could counter the expected performance gains . An important factor is therefore the confidence we can have , for any new sentence , into the best parse delivered by the topological parser : If confidence is high , we want it to be fully considered for prioritisation if it is low , we want to lower its impact , or completely ignore the proposed brackets . We will experiment with two alternative confidence measures : ( i ) expected accuracy of particular bracket types extracted from the best parse delivered , and ( ii ) tree entropy based on the probability distribution encountered in a topological parse , as a measure of the overall accuracy of the best parse proposed and thus the extracted brackets .9 4.1 Confpr: Accuracy of map-constraints To determine a measure of expected accuracy for the map constraints , we computed precision and recall for the 34 bracket types by comparing the extracted brackets from the suite of best delivered topological parses against the brackets we extracted from the trees in the manually annotated evaluation corpus in ( Becker and Frank , 2002 ) . We obtain 88.3 % precision , 87.8 % recall for brackets extracted from the best topological parse , run with TnT front end . We chose precision of extracted bracket types as a static confidence weight for prioritisation . Precision figures are distributed as follows : 26.5 % of the bracket types have precision > 90 % ( 93.1 % in avg , 53.5 % of bracket mass ) , 50 % have precision > 80 % ( 88.9 % avg , 77.7 % bracket mass ) . 20.6 % have precision < 50 % ( 41.26 % in avg , 2.7 % bracket mass ) . For experiments using a threshold on confpr ( x ) for bracket type x , we set a threshold value of 0.7 , which excludes 32.35 % of the lowconfidence bracket types ( and 22.1 % bracket mass ) , and includes chunk-based brackets ( see Section 5 ) . 4.2 Conferit: Entropy of Parse Distribution While precision over bracket types is a static measure that is independent from the structural complexity of a particular sentence , tree entropy is defined as the entropy over the probability distribution of the set of parsed trees for a given sentence . It is a useful measure to assess how certain the parser is about the best analysis , e.g. to measure the training utility value of a data point in the context of sample selection ( Hwa , 2000 ) . We thus employ tree entropy as a confidence measure for the quality of the best topological parse , and the extracted bracket constraints . We carry out an experiment to assess the effect of varying entropy thresholds 0 on precision and recall of topological parsing , in terms of perfect match rate , and show a way to determine an optimal value for 0 . We compute tree entropy over the full probability distribution , and normalise the values to be distributed in a range between 0 and 1 . The normalisation factor is empirically determined as the highest entropy over all sentences of the training set .10 Experimental setup We randomly split the manually corrected evaluation corpus of ( Becker and Frank , 2002 ) ( for sentence length < 40 ) into a training set of 600 sentences and a test set of 408 sentences . This yields the following values for the training set ( test set in brackets ) : initial perfect match rate is 73.5 % ( 70.0 % ) , LP 88.8 % ( 87.6 % ) , and LR 88.5 % ( 87.8 % ) .11 Coverage is 99.8 % for both . Evaluation measures For the task of identifying the perfect matches from a set of parses we give the following standard definitions : precision is the proportion of selected parses that have a perfect match thus being the perfect match rate , and recall is the proportion of perfect matches that the system selected . Coverage is usually defined as the proportion of attempted analyses with at least one parse . We extend this definition to treat successful analyses with a high tree entropy as being out of coverage . Fig . 3 shows the effect of decreasing entropy thresholds 0 on precision , recall and coverage . The unfiltered set of all sentences is found at 0 = 1 . Lowering 0 in creases precision , and decreases recall and coverage . We determine f-measure as composite measure of precision and recall with equal weighting ( a = 0.5 ) . Results We use f-measure as a target function on the training set to determine a plausible 0 . F-measure is maximal at 0 = 0.236 with 88.9 % , see Figure 4 . Precision and recall are 83.7 % and 94.8 % resp . while coverage goes down to 83.0 % . Applying the same 0 on the test set , we get the following results : 80.5 % precision , 93.0 % recall . Coverage goes down to 80.6 % . LP is 93.3 % , LR is 91.2 % . Confidence Measure We distribute the complement of the associated tree entropy of a parse tree tr as a global confidence measure over all brackets br extracted from that parse : confe , , , t ( br ) = 1 - ent ( tr ) . For the thresholded version of confe , , , t ( br ) , we set the threshold to 1 - 0 = 1 - 0:236 = 0:764 . 5 Experiments Experimental Setup In the experiments we use the subset of the NEGRA corpus ( 5060 sents , 24.57 % ) that is currently parsed by the HPSG grammar .12 Average sentence length is 8.94 , ignoring punctuation ; average lexical ambiguity is 3.05 entries / word . As baseline , we performed a run without topological information , yet including PoS prioritisation from tagging .13 A series of tests explores the effects of alternative parameter settings . We further test the impact of chunk information . To this end , phrasal fields determined by topological parsing were fed to the chunk parser of ( Skut and Brants , 1998 ) . Extracted NP and PP bracket constraints are defined as left-matching bracket types , to compensate for the non-embedding structure of chunks . Chunk brackets are tested in conjunction with topological brackets , and in isolation , using the labelled precision value of 71.1 % in ( Skut and Brants , 1998 ) as a uniform confidence weight .14 Measures For all runs we measure the absolute time and the number of parsing tasks needed to compute the first reading . The times in the individual runs were normalised according to the number of executed tasks per second . We noticed that the coverage of some integrated runs decreased by up to 1 % of the 5060 test items , with a typical loss of around 0.5 % . To warrant that we are not just trading coverage for speed , we derived two measures from the primary data : an upper bound , where we associated every unsuccessful parse with the time and number of tasks used when the limit of 70000 passive edges was hit , and a lower bound , where we removed the most expensive parses from each run , until we reached the same coverage . Whereas the upper bound is certainly more realistic in an application context , the lower bound gives us a worst case estimate of expectable speed-up . Integration Parameters We explored the following range of weighting parameters for prioritisation ( see Section 3.3 and Table 2 ) . We use two global settings for the heuristic parameter y. Setting y to 12 without using any confidence measure causes the priority of every affected parsing task to be in - or decreased by half its value . Setting y to 1 drastically increases the influence of topological information , the priority for rewarded tasks is doubled and set to zero for penalized ones . The first two runs ( rows with P E ) ignore both confidence parameters ( confpr = ent = 1 ) , measuring only the effect of higher or lower influence of topological information . In the remaining six runs , the impact of the confidence measures confpr = ent is tested individually , namely + P E and P + E , by setting the resp . alternative value to 1 . For two runs , we set the resp . confidence values that drop below a certain threshold to zero ( PT , ET ) to exclude un certain candidate brackets or bracket types . For runs including chunk bracketing constraints , we chose thresholded precision ( PT ) as confidence weights for topological and / or chunk brackets . 6 Discussion of Results Table 2 summarises the results . A high impact on bracket constraints ( y1 ) results in lower performance gains than using a moderate impact ( - y1 ) ( rows 2,4,5 vs. 3,8,9 ) . A possible interpretation is that for high y , wrong topological constraints and strong negative priorities can mislead the parser . Use of confidence weights yields the best performance gains ( with - y1 ) , in particular , thresholded precision of bracket types PT , and tree entropy + E , with comparable speed-up of factor 2.2 / 2.3 and 2.27 / 2.23 ( 2.25 if averaged ) . Thresholded entropy ET yields slightly lower gains . This could be due to a non-optimal threshold , or the fact that while precision differentiates bracket types in terms of their confidence , such that only a small number of brackets are weakened tree entropy as a global measure penalizes all brackets for a sentence on an equal basis , neutralizing positive effects which as seen in + / P may still contribute useful information . Additional use of chunk brackets ( row 10 ) leads to a slight decrease , probably due to lower precision of chunk brackets . Even more , isolated use of chunk information ( row 11 ) does not yield signifi cant gains over the baseline ( 0.89 / 1.1 ) . Similar results were reported in ( Daum et al. , 2003 ) for integration of chunk - and dependency parsing .15 For PT - E ( yz , Figure 5 shows substantial performance gains , with some outliers in the range of length 2536 . 962 sentences ( length A , avg . 11.09 ) took longer parse time as compared to the baseline ( with 5 % variance margin ) . For coverage losses , we isolated two factors : while erroneous topological information could lead the parser astray , we also found cases where topological information prevented spurious HPSG parses to surface . This suggests that the integrated system bears the potential of crossvalidation of different components . 7 Conclusion We demonstrated that integration of shallow topological and deep HPSG processing results in significant performance gains , of factor 2.25 at a high level of deep parser efficiency . We show that macrostructural constraints derived from topological parsing improve significantly over chunk-based constraints . Fine-grained prioritisation in terms of confidence weights could further improve the results . Our annotation-based architecture is now easily extended to address robustness issues beyond lexical matters . By extracting spans for clausal fragments from topological parses , in case of deep parsing fail ure the chart can be inspected for spanning analyses for sub-sentential fragments . Further , we can simplify the input sentence , by pruning adjunct subclauses , and trigger reparsing on the pruned input . "}
  },
    {
    "id": "P03-1022",
    "result":     [
            {
        "value":         {
          "start": 1635,
          "end": 1649,
          "text": "TRAINS93 corpus",
          "labels": ["Dataset"]
        },
        "id": 264
      },
            {
        "value":         {
          "start": 3018,
          "end": 3035,
          "text": "Switchboard corpus",
          "labels": ["Dataset"]
        },
        "id": 1284
      },
            {
        "value":         {
          "start": 12371,
          "end": 12378,
          "text": "TF * IDF",
          "labels": ["Method"]
        },
        "id": 267
      },
            {
        "value":         {
          "start": 12408,
          "end": 12415,
          "text": "TF * IDF",
          "labels": ["Metric"]
        },
        "id": 267
      },
            {
        "value":         {
          "start": 13388,
          "end": 13392,
          "text": "RPART",
          "labels": ["Method"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 13438,
          "end": 13441,
          "text": "CART",
          "labels": ["Method"]
        },
        "id": 268
      },
            {
        "value":         {
          "start": 13494,
          "end": 13499,
          "text": "S-Plus",
          "labels": ["Tool"]
        },
        "id": 269
      },
            {
        "value":         {
          "start": 13505,
          "end": 13505,
          "text": "R",
          "labels": ["Tool"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 13551,
          "end": 13551,
          "text": "R",
          "labels": ["Tool"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 13675,
          "end": 13679,
          "text": "RPART",
          "labels": ["Method"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 16420,
          "end": 16428,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 16432,
          "end": 16437,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 16443,
          "end": 16451,
          "text": "f-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 18367,
          "end": 18375,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18570,
          "end": 18578,
          "text": "f-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 18606,
          "end": 18611,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 18623,
          "end": 18631,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19720,
          "end": 19728,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19732,
          "end": 19737,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 19743,
          "end": 19750,
          "text": "fmeasure",
          "labels": ["Metric"]
        },
        "id": 271
      },
            {
        "value":         {
          "start": 19968,
          "end": 19973,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 20563,
          "end": 20571,
          "text": "f-measure",
          "labels": ["Metric"]
        },
        "id": 992
      },
            {
        "value":         {
          "start": 20945,
          "end": 20953,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      }
    ],
    "data": {"text": "A Machine Learning Approach to Pronoun Resolution in Spoken Dialogue Abstract We apply a decision tree based approach to pronoun resolution in spoken dialogue . Our system deals with pronouns with NPand non-NP-antecedents . We present a set of features designed for pronoun resolution in spoken dialogue and determine the most promising features . We evaluate the system on twenty Switchboard dialogues and show that it compares well to Byrons ( 2002 ) manually tuned system . 1 Introduction Corpus-based methods and machine learning techniques have been applied to anaphora resolution in written text with considerable success ( Soon et al. , 2001 ; Ng & Cardie , 2002 , among others ) . It has been demonstrated that systems based on these approaches achieve a performance that is comparable to hand-crafted systems . Since they can easily be applied to new domains it seems also feasible to port a given corpus-based anaphora resolution system from written text to spoken dialogue . This paper describes the extensions and adaptations needed for applying our anaphora resolution system ( Muller et al. , 2002 ; Strube et al. , 2002 ) to pronoun resolution in spoken dialogue . There are important differences between written text and spoken dialogue which have to be accounted for . The most obvious difference is that in spoken dialogue there is an abundance of ( personal and demonstrative ) pronouns with non-NP-antecedents or no antecedents at all . Corpus studies have shown that a significant amount of pronouns in spoken dialogue have non-NP-antecedents : Byron & Allen ( 1998 ) report that about 50 % of the pronouns in the TRAINS93 corpus have non-NP-antecedents . Eckert & Strube ( 2000 ) note that only about 45 % of the pronouns in a set of Switchboard dialogues have NP-antecedents . The remainder consists of 22 % which have non-NP-antecedents and 33 % without antecedents . These studies suggest that the performance of a pronoun resolution algorithm can be improved considerably by enabling it to resolve also pronouns with non-NP-antecedents . Because of the difficulties a pronoun resolution algorithm encounters in spoken dialogue , previous approaches were applied only to tiny domains , they needed deep semantic analysis and discourse processing and relied on hand-crafted knowledge bases . In contrast , we build on our existing anaphora resolution system and incrementally add new features specifically devised for spoken dialogue . That way we are able to determine relatively powerful yet computationally cheap features . To our knowledge the work presented here describes the first implemented system for corpus-based anaphora resolution dealing also with non-NP-antecedents . 2 NP- vs. Non-NP-Antecedents Spoken dialogue contains more pronouns with nonNP-antecedents than written text does . However , pronouns with NP-antecedents ( like 3rd pers . masculine / feminine pronouns , cf . he in the example below ) still constitute the largest fraction of all coreferential pronouns in the Switchboard corpus . In spoken dialogue there are considerable numbers of pronouns that pick up different kinds of abstract objects from the previous discourse , e.g. events , states , concepts , propositions or facts ( Webber , 1991 ; Asher , 1993 ) . These anaphors then have VP-antecedents ( it in ( B6 ) below ) or sentential antecedents ( that in ( B5 ) ) . A1 : ... [ he ] s nine months old ... . A2 : [ He ] likes to dig around a little bit . A3 : [ His ] mother comes in and says , why did you let [ him ] [ play in the dirt ] , A : 4 I guess [ [ he ] s enjoying himself ] . B5 : [ That ] s right . B & [ It ] s healthy , . . . A major problem for pronoun resolution in spoken dialogue is the large number of personal and demonstrative pronouns which are either not referential at all ( e.g. expletive pronouns ) or for which a particular antecedent can not easily be determined by humans ( called vague anaphors by Eckert & Strube ( 2000 ) ) . In the following example , the that in utterance ( A3 ) refers back to utterance ( A1 ) . As for the first two pronouns in ( B4 ) , following Eckert & Strube ( 2000 ) and Byron ( 2002 ) we assume that referring expressions in disfluencies , abandoned utterances etc. are excluded from the resolution . The third pronoun in ( B4 ) is an expletive . The pronoun in ( A5 ) is different in that it is indeed referential : it refers back tothat from ( A3 ) . A1 : ... [ There is a lot of theft , a lot of assault dealing with , uh , people trying to get money for drugs . ] Pronoun resolution in spoken dialogue also has to deal with the whole range of difficulties that come with processing spoken language : disfluencies , hesitations , abandoned utterances , interruptions , backchannels , etc. . These phenomena have to be taken into account when formulating constraints on e.g. the search space in which an anaphor looks for its antecedent . E.g. , utterance ( B2 ) in the previous example does not contain any referring expressions . So the demonstrative pronoun in ( A3 ) has to have access not only to ( B2 ) but also to ( A1 ) . 3 Data 3.1 Corpus Our work is based on twenty randomly chosen Switchboard dialogues . Taken together , the dialogues contain 30810 tokens ( words and punctuation ) in 3275 sentences / 1771 turns . The annotation consists of 16601 markables , i.e. sequences of words and attributes associated with them . On the top level , different types of markables are distinguished : NPmarkables identify referring expressions like noun phrases , pronouns and proper names . Some of the attributes for these markables are derived from the Penn Treebank version of the Switchboard dialogues , e.g. grammatical function , NP form , grammatical case and depth of embedding in the syntactical structure . VP-markables are verb phrases , S-markables sentences . Disfluency-markables are noun phrases or pronouns which occur in unfinished or abandoned utterances . Among other ( typedependent ) attributes , markables contain a member attribute with the ID of the coreference class they are part of ( if any ) . If an expression is used to refer to an entity that is not referred to by any other expression , it is considered a singleton . Table 1 gives the distribution of the npform attribute for NP-markables . The second and third row give the number of non-singletons and singletons respectively that add up to the total number given in the first row . Table 2 shows the distribution of the agreement attribute ( i.e. person , gender , and number ) for the pronominal expressions in our corpus . The left figure in each cell gives the total number of expressions , the right figure gives the number of nonsingletons . Note the relatively high number of singletons among the personal and demonstrative pronouns ( 223 for it , 60 for they and 82 for that ) . These pronouns are either expletive or vague , and cause the most trouble for a pronoun resolution algorithm , which will usually attempt to find an antecedent nonetheless . Singleton they pronouns , in particular , are typical for spoken language ( as opposed to written text ) . The same is true for anaphors with non-NP-antecedents . However , while they are far more frequent in spoken language than in written text , they still constitute only a fraction of all coreferential expressions in our corpus . This defines an upper limit for what the resolution of these kinds of anaphors can contribute at all . These facts have to be kept in mind when comparing our results to results of coreference resolution in written text . 3.2 Data Generation Training and test data instances were generated from our corpus as follows . All markables were sorted in document order , and markables for first and second person pronouns were removed . The resulting list was then processed from top to bottom . If the list contained an NP-markable at the current position and if this markable was not an indefinite noun phrase , it was considered a potential anaphor . In that case , pairs of potentially coreferring expressions were generated by combining the potential anaphor with each compatible1 NP-markable preceding2 it in the list . The resulting pairs were labelled P if both markables had the same ( non-empty ) value in their member attribute , N otherwise . For anaphors with non-NP-antecedents , additional training and test data instances had to be generated . This process was triggered by the markable at the current position being it or that . In that case , a small set of potential non-NP-antecedents was generated by selecting S - and VP-markables from the last two valid sentences preceding the potential anaphor . The choice of the last two sentences was motivated pragmatically by considerations to keep the search space ( and the number of instances ) small . A sentence was considered valid if it was neither unfinished nor a backchannel utterance ( like e.g. Uh-huh , Yeah , etc. ) . From the selected markables , inaccessible non-NP-expressions were automatically removed . We considered an expression inaccessible if it ended before the sentence in which it was contained . This was intended to be a rough approximation of the concept of the right frontier ( Webber , 1991 ) . The remaining expressions were then combined with the potential anaphor . Finally , the resulting pairs were labelled P or N and added to the instances generated with NP-antecedents . 4 Features We distinguish two classes of features : NP-level features specify e.g. the grammatical function , NP form , morpho-syntax , grammatical case and the depth of embedding in the syntactical structure . For these features , each instance contains one value for the antecedent and one for the anaphor . Coreference-level features , on the other hand , describe the relation between antecedent and anaphor in terms of e.g. distance ( in words , markables and sentences ) , compatibility in terms of agreement and identity of syntactic function . For these features , each instance contains only one value . In addition , we introduce a set of features which is partly tailored to the processing of spoken dialogue . The feature ante exp type ( 17 ) is a rather obvious yet useful feature to distinguish NP - from non-NP-antecedents . The features ana np , vp and NP-level features s pref ( 18 , 19 , 20 ) describe a verbs preference for arguments of a particular type . Inspired by the work of Eckert & Strube ( 2000 ) and Byron ( 2002 ) , these features capture preferences for NP - or nonNP-antecedents by taking a pronouns predicative context into account . The underlying assumption is that if a verb preceding a personal or demonstrative pronoun preferentially subcategorizes sentences or VPs , then the pronoun will be likely to have a nonNP-antecedent . The features are based on a verb list compiled from 553 Switchboard dialogues .3 For every verb occurring in the corpus , this list contains up to three entries giving the absolute count of cases where the verb has a direct argument of type NP , VP or S . When the verb list was produced , pronominal arguments were ignored . The features mdist 3mf3p and mdist 3n ( 21 , 22 ) are refinements of the mdist feature . They measure the distance in markables between antecedent and anaphor , but in doing so they take the agreement value of the anaphor into account . For anaphors with an agreement value of 3mf or 3p , mdist 3mf3p is measured as D = 1 + the num ber of NP-markables between anaphor and potential antecedent . Anaphors with an agreement value of 3n , ( i.e. it or that ) , on the other hand , potentially have non-NP-antecedents , so mdist 3n is measured as D + the number of anaphorically accessible4 Sand VP-markables between anaphor and potential antecedent . The feature ante tfifd ( 23 ) is supposed to capture the relative importance of an expression for a dialogue . The underlying assumption is that the higher the importance of a non-NP expression , the higher the probability of its being referred back to . For our purposes , we calculated TF for every word by counting its frequency in each of our twenty Switchboard dialogues separately . The calculation of IDF was based on a set of 553 Switchboard dialogues . For every word , we calculated IDF as log ( 553/N ) , with N = number of documents containing the word . For every non-NP-markable , an average TF * IDF value was calculated as the TF * IDF sum of all words comprising the markable , divided by the number of words in the markable . The feature ante ic ( 24 ) as an alternative to ante tfidf is based on the same assumptions as the former . The information content of a non-NP-markable is calculated as follows , based on a set of 553 Switchboard dialogues : For each word in the markable , the IC value was calculated as the negative log of the total frequency of the word divided by the total number of words in all 553 dialogues . The average IC value was then calculated as the IC sum of all words in the markable , divided by the number of words in the markable . Finally , the feature wdist ic ( 25 ) measures the word-based distance between two expressions . It does so in terms of the sum of the individual words IC . The calculation of the IC was done as described for the ante ic feature . 5 Experiments and Results 5.1 Experimental Setup All experiments were performed using the decision tree learner RPART ( Therneau & Atkinson , 1997 ) , which is a CART ( Breiman et al . , 1984) reimplementation for the S-Plus and R statistical computing environments ( we use R , Ihaka & Gentleman ( 1996 ) , see http : / / www.r-project.org ) . We used the standard pruning and control settings for RPART ( cp = 0.0001 , minsplit = 20 , minbucket = 7 ) . All results reported were obtained by performing 20-fold crossvalidation . In the prediction phase , the trained classifier is exposed to unlabeled instances of test data . The classifiers task is to label each instance . When an instance is labeled as coreferring , the IDs of the anaphor and antecedent are kept in a response list for the evaluation according to Vilain et al. ( 1995 ) . For determining the relevant feature set we followed an iterative procedure similar to the wrapper approach for feature selection ( Kohavi & John , 1997 ) . We start with a model based on a set of predefined baseline features . Then we train models combining the baseline with all additional features separately . We choose the best performing feature ( fmeasure according to Vilain et al. ( 1995 ) ) , adding it to the model . We then train classifiers combining the enhanced model with each of the remaining features separately . We again choose the best performing classifier and add the corresponding new feature to the model . This process is repeated as long as significant improvement can be observed . 5.2 Results anteexptype=s,vp 1110 55 N ananpform=prp 747,11 N * ananpform=dtpro 363 44 N anteexptype=vp 177 3 N * anteexptype=s 186 41 N udist>=1.5 95 14 N * In our experiments we split the data in three sets according to the agreement of the anaphor : third person masculine and feminine pronouns ( 3mf ) , third person neuter pronouns ( 3n ) , and third person plural pronouns ( 3p ) . Since only 3n-pronouns have nonNP-antecedents , we were mainly interested in improvements in this data set . We used the same baseline model for each data set . The baseline model corresponds to a pronoun resolution algorithm commonly applied to written text , i.e. , it uses only the features in the first two parts of Table 3 . For the baseline model we generated training and test data which included only NPantecedents . Then we performed experiments using the features introduced for spoken dialogue . The training and test data for the models using additional features included NP - and non-NP-antecedents . For each data set we followed the iterative procedure outlined in Section 5.1 . In the following tables we present the results of our experiments . The first column gives the number of coreference links correctly found by the classifier , the second column gives the number of all coreference links found . The third column gives the total number of coreference links ( 1250 ) in the corpus . During evaluation , the list of all correct links is used as the key list against which the response list produced by the classifier ( cf. above ) is compared . The remaining three columns show precision , recall and f-measure , respectively . Table 4 gives the results for 3mf pronouns . The baseline model performs very well on this data set ( the low recall figure is due to the fact that the 3mf data set contains only a small subset of the coreference links expected by the evaluation ) . The results are comparable to any pronoun resolution algorithm dealing with written text . This shows that our pronoun resolution system could be ported to the spoken dialogue domain without sacrificing performance . Table 5 shows the results for 3n pronouns . The baseline model does not perform very well . As mentioned above , for evaluating the performance of the baseline model we removed all potential non-NPantecedents from the data . This corresponds to a naive application of a model developed for written text to spoken dialogue . First , we applied the same model to the data set containing all kinds of antecedents . The performance drops somewhat as the classifier is exposed to non-NP-antecedents without being able to differentiate between NP - and non-NP-antecedents . By adding the feature ante exp type the classifier is enabled to address NP - and non-NP-antecedents differently , which results in a considerable gain in performance . Substituting the wdist feature with the wdist ic feature also improves the performance considerably . The ante tfidf feature only contributes marginally to the overall performance . These results show that it pays off to consider features particularly designed for spoken dialogue . Table 6 presents the results for 3p pronouns , which do not have non-NP-antecedents . Many of these pronouns do not have an antecedent at all . Others are vague in that human annotators felt them to be referential , but could not determine an antecedent . Since we did not address that issue in depth , the classifier tries to find antecedents for these pronouns indiscriminately , which results in rather low precision figures , as compared to e.g . those for 3mf . Only the feature wdist ic leads to an improvement over the baseline . Table 7 shows the results for the combined classifiers . The improvement in f-measure is due to the increase in recall while the precision shows only a slight decrease . Though some of the features of the baseline model ( features 1-16 ) still occur in the decision tree learned , the feature ante exp type divides major parts of the tree quite nicely ( see Figure 1 ) . Below that node the feature ana npform is used to distinguish between negative ( personal pronouns ) and potential positive cases ( demonstrative pronouns ) . This confirms the hypothesis by Eckert & Strube ( 2000 ) and Byron ( 2002 ) to give high priority to these features . The decision tree fragment in Figure 1 correctly assigns the P label to 23-7 = 16 sentential antecedents . However , the most important problem is the large amount of pronouns without antecedents . The model does find ( wrong ) antecedents for a lot of pronouns which should not have one . Only a small fraction of these pronouns are true expletives ( i.e. , they precede a weather verb or are in constructions like It seems that ... . The majority of these cases are referential , but have no antecedent in the data ( i.e. , they are vague pronouns ) . The overall numbers for precision , recall and fmeasure are fairly low . One reason is that we did not attempt to resolve anaphoric definite NPs and proper names though these coreference links are contained in the evaluation key list . If we removed them from there , the recall of our experiments would approach the 51 % Byron ( 2002 ) mentioned for her system using only domain-independent semantic restrictions . 6 Comparison to Related Work Our approach for determining the feature set for pronoun resolution resembles the so-called wrapper approach for feature selection ( Kohavi & John , 1997 ) . This is in contrast to the majority of other work on feature selection for anaphora resolution , which was hardly ever done systematically . E.g . Soon et al . ( 2001 ) only compared baseline systems consisting of one feature each , only three of which yielded an f-measure greater than zero . Then they combined these features and achieved results which were close to the best overall results they report . While this tells us which features contribute a lot , it does not give any information about potential ( positive or negative ) influence of the rest . Ng & Cardie ( 2002 ) select the set of features by hand , giving a preference to high precision features . They admit that this method is quite subjective . Corpus-based work about pronoun resolution in spoken dialogue is almost non-existent . However , there are a few papers dealing with neuter pronouns with NP-antecedents . E.g. , Dagan & Itai ( 1991 ) presented a corpus-based approach to the resolution of the pronoun it , but they use a written text corpus and do not mention non-NP-antecedents at all . Paul et al. ( 1999 ) presented a corpus-based anaphora resolution algorithm for spoken dialogue . For their experiments , however , they restricted anaphoric relations to those with NP-antecedents . Byron ( 2002 ) presented a symbolic approach which resolves pronouns with NP - and non-NPantecedents in spoken dialogue in the TRAINS domain . Byron extends a pronoun resolution algorithm ( Tetrault , 2001 ) with semantic filtering , thus enabling it to resolve anaphors with non-NPantecedents as well . Semantic filtering relies on knowledge about semantic restrictions associated with verbs , like semantic compatibility between subject and predicative noun or predicative adjective . An evaluation on ten TRAINS93 dialogues with 80 3rd person pronouns and 100 demonstrative pronouns shows that semantic filtering and the implementation of different search strategies for personal and demonstrative pronouns yields a success rate of 72 % . As Byron admits , the major limitation of her algorithm is its dependence on domain-dependent resources which cover the domain entirely . When evaluating her algorithm with only domain-independent semantics , Byron achieved 51 % success rate . What is problematic with her approach is that she assumes the input to her algorithm to be only referential pronouns . This simplifies the task considerably . 7 Conclusions and Future Work We presented a machine learning approach to pronoun resolution in spoken dialogue . We built upon a system we used for anaphora resolution in written text and extended it with a set of features designed for spoken dialogue . We refined distance features and used metrics from information retrieval for determining non-NP-antecedents . Inspired by the more linguistically oriented work by Eckert & Strube ( 2000 ) and Byron ( 2002 ) we also evaluated the contribution of features which used the predicative context of the pronoun to be resolved . However , these features did not show up in the final models since they did not lead to an improvement . Instead , rather simple distance metrics were preferred . While we were ( almost ) satisfied with the performance of these features , the major problem for a spoken dialogue pronoun resolution algorithm is the abundance of pronouns without antecedents . Previous research could avoid dealing with this phenomenon by either applying the algorithm by hand ( Eckert & Strube , 2000 ) or excluding these cases ( Byron , 2002 ) from the evaluation . Because we included these cases in our evaluation we consider our approach at least comparable to Byrons system when she uses only domain-independent semantics . We believe that our system is more robust than hers and that it can more easily be ported to new domains . Acknowledgements . The work presented here has been partially funded by the German Ministry of Research and Technology as part of the EMBASSI project ( 01 IL 904 D/2 ) and by the Klaus Tschira Foundation . We would like to thank Susanne Wilhelm and Lutz Wind for doing the annotations , Kerstin Schurmann , Torben Pastuch and Klaus Rothenhausler for helping with the data preparation . "}
  },
    {
    "id": "P04-1002",
    "result":     [
            {
        "value":         {
          "start": 10558,
          "end": 10568,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 14471,
          "end": 14481,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 14654,
          "end": 14664,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 19081,
          "end": 19091,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 22253,
          "end": 22263,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 22546,
          "end": 22556,
          "text": "world model",
          "labels": ["Method"]
        },
        "id": 272
      }
    ],
    "data": {"text": "Constructivist Development of Grounded Construction Grammars SONY Computer Science Lab - Paris 6 Rue Amyot, 75005 Paris steels@arti.vub.ac.be Abstract The paper reports on progress in building computational models of a constructivist approach to language development . It introduces a formalism for construction grammars and learning strategies based on invention , abduction , and induction . Examples are drawn from experiments exercising the model in situated language games played by embodied artificial agents . 1 Introduction The constructivist approach to language learning proposes that children acquire linguistic competence ( ... ) only gradually , beginning with more concrete linguistic structures based on particular words and morphemes , and then building up to more abstract and productive structures based on various types of linguistic categories , schemas , and constructions . ( TomaselloBrooks , 1999 ) , p. 161 . The approach furthermore assumes that language development is ( i ) grounded in cognition because prior to ( or in a co-development with language ) there is an understanding and conceptualisation of scenes in terms of events , objects , roles that objects play in events , and perspectives on the event , and ( ii ) grounded in communication because language learning is intimately embedded in interactions with specific communicative goals . In contrast to the nativist position , defended , for example , by Pinker ( Pinker , 1998 ) , the constructivist approach does not assume that the semantic and syntactic categories as well as the linking rules ( specifying for example that the agent of an action is linked to the subject of a sentence ) are universal and innate . Rather , semantic and syntactic categories as well as the way they are linked is built up in a gradual developmental process , starting from quite specific verb-island constructions . Although the constructivist approach appears to explain a lot of the known empirical data about child language acquisition , there is so far no worked out model that details how constructivist language development works concretely , i.e. what kind of computational mechanisms are implied and how they work together to achieve adult ( or even child ) level competence . Moreover only little work has been done so far to build computational models for handling the sort of construction grammars assumed by this approach . Both challenges inform the research discussed in this paper . 2 Abductive Learning In the constructivist literature , there is often the implicit assumption that grammatical development is the result of observational learning , and several research efforts are going on to operationalise this approach for acquiring grounded lexicons and grammars ( see e.g. ( Roy , 2001 ) ) . The agents are given pairs with a real world situation , as perceived by the sensori-motor apparatus , and a language utterance . For example , an image of a ball is shown and at the same time a stretch of speech containing the word ball . Based on a generalisation process that uses statistical pattern recognition algorithms or neural networks , the learner then gradually extracts what is common between the various situations in which the same word or construction is used , thus progressively building a grounded lexicon and grammar of a language . The observational learning approach has had some success in learning words for objects and acquiring simple grammatical constructions , but there seem to be two inherent limitations . First , there is the well known poverty of the stimulus argument , widely accepted in linguistics , which says that there is not enough data in the sentences normally available to the language learner to arrive at realistic lexicons and grammars , let alone learn at the same time the categorisations and conceptualisations of the world implied by the language . This has lead many linguists to adopt the nativist position mentioned earlier . The nativist position could in principle be integrated in an observational learning framework by introducing strong biases on the generalisation process , incorporating the constraints of universal grammar , but it has been difficult to identify and operationalise enough of these constraints to do concrete experiments in realistic settings . Second , observational learning assumes that the language system ( lexicon and grammar ) exists as a fixed static system . However , observations of language in use shows that language users constantly align their language conventions to suit the purposes of specific conversations ( ClarkBrennan , 1991 ) . Natural languages therefore appear more to be like complex adaptive systems , similar to living systems that constantly adapt and evolve . This makes it difficult to rely exclusively on statistical generalisation . It does not capture the inherently creative nature of language use . This paper explores an alternative approach , which assumes a much more active stance from language users based on the Peircian notion of abduction ( Fann , 1970 ) . The speaker first attempts to use constructions from his existing inventory to express whatever he wants to express . However when that fails or is judged unsatisfactory , the speaker may extend his existing repertoire by inventing new constructions . These new constructions should be such that there is a high chance that the hearer may be able to guess their meaning . The hearer also uses as much as possible constructions stored in his own inventory to make sense of what is being said . But when there are unknown constructions , or the meanings do not fit with the situation being talked about , the hearer makes an educated guess about what the meaning of the unknown language constructions could be , and adds them as new hypotheses to his own inventory . Abductive constructivist learning hence relies crucially on the fact that both agents have sufficient common ground , share the same situation , have established joint attention , and share communicative goals . Both speaker and hearer use themselves as models of the other in order to guess how the other one will interpret a sentence or why the speaker says things in a particular way . Because both speaker and hearer are taking risks making abductive leaps , a third activity is needed , namely induction , not in the sense of statistical generalisation as in observational learning but in the sense of Peirce ( Fann , 1970 ) : A hypothesis arrived at by making educated guesses is tested against further data coming from subsequent interactions . When a construction leads to a successful interaction , there is some evidence that this construction is ( or could become ) part of the set of conventions adopted by the group , and language users should therefore prefer it in the future . When the construction fails , the language user should avoid it if alternatives are available . Implementing these visions of language learning and use is obviously an enormous challenge for computational linguistics . It requires not only cognitive and communicative grounding , but also grammar formalisms and associated parsing and production algorithms which are extremely flexible , both from the viewpoint of getting as far as possible in the interpretation or production process despite missing rules or incompatibilities in the inventories of speaker and hearer , and from the viewpoint of supporting continuous change . 3 Language Games The research reported here uses a methodological approach which is quite common in Artificial Life research but still relatively novel in ( computational ) linguistics : Rather than attempting to develop simulations that generate natural phenomena directly , as one does when using Newtons equations to simulate the trajectory of a ball falling from a tower , we engage in computational simulations and robotic experiments that create ( new ) artificial phenomena that have some of the characteristics of natural phenomena and hence are seen as explaining them . Specifically , we implement artificial agents with components modeling certain cognitive operations ( such as introducing a new syntactic category , computing an analogy between two events , etc. ) , and then see what language phenomena result if these agents exercise these components in embodied situated language games . This way we can investigate very precisely what causal factors may underly certain phenomena and can focus on certain aspects of ( grounded ) language use without having to face the vast full complexity of real human languages . A survey of work which follows a similar methodology is found in ( CangelosiParisi , 2003 ) . The artificial agents used in the experiments driving our research observe real-world scenes through their cameras . The scenes consist of interactions between puppets , as shown in figure 1 . These scenes enact common events like movement of people and objects , actions such as push or pull , give or take , etc. . In order to achieve the cognitive grounding assumed in constructivistlanguage learning , the scenes are processed by a battery of relatively standard machine vision algorithms that segment objects based on color and movement , track objects in real-time , and compute a stream of lowlevel features indicating which objects are touching , in which direction objects are moving , etc. . These low-level features are input to an eventrecognition system that uses an inventory of hierarchical event structures and matches them against the data streaming in from low-level vision , similar to the systems described in ( SteelsBaillie , 2003 ) . In order to achieve the communicative grounding required for constructivist learning , agents go through scripts in which they play various language games , similar to the setups described in ( Steels , 2003 ) . These language games are deliberately quite similar to the kind of scenes and interactions used in a lot of child language research . A language game is a routinised interaction between two agents about a shared situation in the world that involves the exchange of symbols . Agents take turns playing the role of speaker and hearer and give each other feedback about the outcome of the game . In the game further used in this paper , one agent describes to another agent an event that happened in the most recently experienced scene . The game succeeds if the hearer agrees that the event being described occurred in the recent scene . 4 The Lexicon Visual processing and event recognition results in a world model in the form of a series of facts describing the scene . To play the description game , the speaker selects one event as the topic and then seeks a series of facts which discriminate this event and its objects against the other events and objects in the context . We use a standard predicate calculus-style representation for meanings . A semantic structure consists of a set of units where each unit has a referent , which is the object or event to which the unit draws attention , and a meaning , which is a set of clauses constraining the referent . A semantic structure with one unit is for example written down as follows : [ 1 ] unit1 ev1 fall ( ev1 , true ) , fall-1 ( ev1 , obj1 ) , ball ( obj1 ) where unit1 is the unit , ev1 the referent , and fall ( ev1 , true ) , fall-1 ( ev1 , obj1 ) , ball ( obj1 ) the meaning . The different arguments of an event are decomposed into different predicates . For example , for John gives a book to Mary , there would be four clauses : give ( ev1 , true ) for the event itself , give-1 ( ev1 , John ) , for the one who gives , give-2 ( ev1 , book1 ) , for the object given , and give-3 ( ev1 , Mary ) , for the recipient . This representation is more flexible and makes it possible to add new components ( like the manner of an event ) at any time . Syntactic structures mirror semantic structures . They also consist of units and the name of units are shared with semantic structures so that crossreference between them is straightforward . The form aspects of the sentence are represented in a declarative predicate calculus style , using the units as arguments . For example , the following unit is constrained as introducing the string fall : [ 2 ] unit1 string ( unit1 , fall ) The rule formalism we have developed uses ideas from several existing formalisms , particularly unification grammars and is most similar to the Embodied Construction Grammars proposed in ( BergenChang , 2003 ) . Lexical rules link parts of semantic structure with parts of syntactic structure . All rules are reversable . When producing , the left side of a rule is matched against the semantic structure and , if there is a match , the right side is unified with the syntactic structure . Conversely when parsing , the right side is matched against the syntactic structure and the left side unified with the semantic structure . Here is a lexical entry for the word fall . [ 3 ] ? unit ? ev fall ( ? ev , ? state ) , fall-1 ( ? ev , ? obj ) ? unit string ( ? unit , fall ) It specifies that a unit whose meaning is fall ( ? ev , ? state ) , fall-1 ( ? ev , ? obj ) is expressed with the string fall . Variables are written down with a question mark in front . Their scope is restricted to the structure or rule in which they appear and rule application often implies the renaming of certain variables to take care of the scope constraints . Here is a lexical entry for ball : [ 4 ] ? unit ? obj ball ( ? obj ) ? unit string ( ? unit , ball ) Lexicon lookup attempts to find the minimal set of rules that covers the total semantic structure . New units may get introduced ( both in the syntactic and semantic structure ) if the meaning of a unit is broken down in the lexicon into more than one word . Thus , the original semantic structure in [ 1 ] results after the application of the two rules [ 3 ] and [ 4 ] in the following syntactic and semantic structures : If this syntactic structure is rendered , it produces the utterance fall ball . No syntax is implied yet . In the reverse direction , the parser starts with the two units forming the syntactic structure in [ 5 ] and application of the rules produces the following semantic structure : The semantic structure in [ 6 ] now contains variables for the referent of each unit and for the various predicate-arguments in their meanings . The interpretation process matches these variables against the facts in the world model . If a single consistent series of bindings can be found , then interpretation is successful . For example , assume that the facts in the meaning part of [ 1 ] are in the world model then matching [ 6 ] against them results in the bindings : ev/ev1 , ? state/true , ? obj/obj1 , ? obj1/obj1 When the same word or the same meaning is covered by more than one rule , a choice needs to be made . Competing rules may develop if an agent invented a new word for a particular meaning but is later confronted with another word used by somebody else for the same meaning . Every rule has a score and in production and parsing , rules with the highest score are preferred . When the speaker performs lexicon lookup and rules were found to cover the complete semantic structure , no new rules are needed . But when some part is uncovered , the speaker should create a new rule . We have experimented so far with a simple strategy where agents lump together the uncovered facts in a unit and create a brand new word , consisting of a randomly chosen configuration of syllables . For example , if no word for ball ( obj1 ) exists yet to cover the semantic structure in [ 1 ] , a new rule such as [ 4 ] can be constructed by the speaker and subsequently used . If there is no word at all for the whole semantic structure in [ 1 ] , a single word covering the whole meaning will be created , giving the effect of holophrases . The hearer first attempts to parse as far as possible the given sentence , and then interprets the resulting semantic structure , possibly using joint attention or other means that may help to find the intended interpretation . If this results in a unique set of bindings , the language game is deemed successful . But if there were parts of the sentence which were not covered by any rule , then the hearer can use abductive learning . The first critical step is to guess as well as possible the meaning of the unknown word ( s ) . Thus suppose the sentence is fall ball , resulting in the semantic structure : [ 8 ] unit1 ? ev fall ( ? ev , ? state ) , fall-1 ( ? ev , ? obj ) If this structure is matched , bindings for ? ev and ? obj are found . The agent can now try to find the possible meaning of the unknown word ball . He can assume that this meaning must somehow help in the interpretation process . He therefore conceptualises the same way as if he would be the speaker and constructs a distinctive description that draws attention to the event in question , for example by constraining the referent of ? obj with an additional predicate . Although there are usually several ways in which obj1 differs from other objects in the context . There is a considerable chance that the predicate ball is chosen and hence ball ( ? obj ) is abductively inferred as the meaning of ball resulting in a rule like [ 4 ] . Agents use induction to test whether the rules they created by invention and abduction have been adopted by the group . Every rule has a score , which is local to each agent . When the speaker or hearer has success with a particular rule , its score is increased and the score of competing rules is decreased , thus implementing lateral inhibition . When there is a failure , the score of the rule that was used is decreased . Because the agents prefer rules with the highest score , there is a positive feedback in the system . The more a word is used for a particular meaning , the more success that word will have . Figure 2 : Winner-take-all effect in words competing for same meaning . The x-axis plots language games and the y-axis the use frequency . Scores rise in all the agents for these words and so progressively we see a winner-take-all effect with one word dominating for the expression of a particular meaning ( see figure 2 ) . Many experiments have by now been performed showing that this kind of lateral inhibition dynamics allows a population of agents to negotiate a shared inventory of formmeaning pairs for content words ( Steels , 2003 ) . 5 Syntactisation The reader may have noticed that the semantic structure in [ 6 ] resulting from parsing the sentence fall ball , includes two variables which will both get bound to the same object , namely ? obj , introduced by the predicate fall-1 ( ? ev , ? obj ) , and ? obj1 , introduced by the predicate ball ( ? obj1 ) . We say that in this case ? obj and ? obj1 form an equality . Just from parsing the two words , the hearer can not know that the object involved in the fall event is the same as the object introduced by ball . He can only figure this out when looking at the scene ( i.e . the world model ) . In fact , if there are several balls in the scene and only one of them is falling , there is no way to know which object is intended . And even if the hearer can figure it out , it is still desirable that the speaker should provide extra-information about equalities to optimise the hearers interpretation efforts . A major thesis of the present paper is that resolving equivalences between variables is the main motor for the introduction of syntax . To achieve it , the agents could , as a first approximation , use rules like the following one , to be applied after all lexical rules have been applied : This rule is formally equivalent to the lexical rules discussed earlier in the sense that it links parts of a semantic structure with parts of a syntactic structure . But now more than one unit is involved . Rule [ 9 ] will do the job , because when unifying its right side with the semantic structure ( in parsing ) ? obj2 unifies with the variables ? obj ( supplied by fall ) and ? obj1 ( supplied by ball ) and this forces them to be equivalent . Note that ? unit1 in [ 9 ] only contains those parts of the original meaning that involve the variables which need to be made equal . The above rule works but is completely specific to this case . It is an example of the ad hoc verb-island constructions reported in an early stage of child language development . Obviously it is much more desirable to have a more general rule , which can be achieved by introducing syntactic and semantic categories . A semantic category ( such as agent , perfective , countable , male ) is a categorisation of a conceptual relation , which is used to constrain the semantic side of grammatical rules . A syntactic category ( such as noun , verb , nominative ) is a categorisation of a word or a group of words , which can be used to constrain the syntactic side of grammatical rules . A rule using categories can be formed by taking rule [ 9 ] above and turning all predicates or content words into semantic or syntactic categories . The agent then needs to create sem-rules to categorise a predicate as belonging to a semantic category , as in : and syn-rules to categorise a word as belonging to a syntactic category , as in : These rules have arrows going only in one direction because they are only applied in one way . ' During production , the sem-rules are applied first , then the lexical rules , next the syn-rules and then the gram ` Actually if word morphology is integrated , syn-rules need to be bi-directional , but this topic is not discussed further here due to space limitations . matical rules . In parsing , the lexical rules are applied first ( in reverse direction ) , then the syn-rules and the sem-rules , and only then the grammatical rules ( in reverse direction ) . The complete syntactic and semantic structures for example [ 9 ] look as follows : The right side of rule [ 10 ] matches with this syntactic structure , and if the left side of rule [ 10 ] is unified with the semantic structure in [ 13 ] the variable ? obj2 unifies with ? obj and ? obj1 , thus resolving the equality before semantic interpretation ( matching against the world model ) starts . How can language users develop such rules ? The speaker can detect equalities that need to be resolved by re-entrance : Before rendering a sentence and communicating it to the hearer , the speaker reparses his own sentence and interprets it against the facts in his own world model . If the resulting set of bindings contains variables that are bound to the same object after interpretation , then these equalities are candidates for the construction of a rule and new syntactic and semantic categories are made as a side effect . Note how the speaker uses himself as a model of the hearer and fixes problems that the hearer might otherwise encounter . The hearer can detect equalities by first interpreting the sentence based on the constructions that are already part of his own inventory and the shared situation and prior joint attention . These equalities are candidates for new rules to be constructed by the hearer , and they again involve the introduction of syntactic and semantic categories . Note that syntactic and semantic categories are always local to an agent . The same lateral inhibition dynamics is used for grammatical rules as for lexical rules , and so is also a positive feedback loop leading to a winner-take-all effect for grammatical rules . 6 Hierarchy Natural languages heavily use categories to tighten rule application , but they also introduce additional syntactic markings , such as word order , function words , affixes , morphological variation of word forms , and stress or intonation patterns . These markings are often used to signal to which category certain words belong . They can be easily incorporated in the formalism developed so far by adding additional descriptors of the units in the syntactic structure . For example , rule [ 10 ] can be expanded with word order constraints and the introduction of a particle ba : Note that it was necessary to introduce a superunit ? unit4 in order to express the word order constraints between the ba-particle and the unit that introduces the object . Applying this rule as well as the synrules and sem-rules discussed earlier to the semantic structure in [ 5 ] yields : When this syntactic structure is rendered , it produces fall ball ba , or equivalently ball ba fall , because only the order between ball and ba is constrained . Obviously the introduction of additional syntactic features makes the learning of grammatical rules more difficult . Natural languages appear to have meta-level strategies for invention and abduction . For example , a language ( like Japanese ) tends to use particles for expressing the roles of objects in events and this usage is a strategy both for inventing the expression of a new relation and for guessing what the use of an unknown word in the sentence might be . Another language ( like Swahili ) uses morphological variations similar to Latin for the same purpose and thus has ended up with a rich set of affixes . In our experiments so far , we have implemented such strategies directly , so that invention and abduction is strongly constrained . We still need to work out a formalism for describing these strategies as metarules and research the associated learning mechanisms . Figure 3 : The graph shows the dependency structure as well as the phrase-structure emerging through the application of multiple rules When the same word participates in several rules , we automatically get the emergence of hierarchical structures . For example , suppose that two predicates are used to draw attention to obj1 in [ 5 ] : ball and red . If the lexicon has two separate words for each predicate , then the initial semantic structure would introduce different variables so that the meaning after parsing fall ball ba red would be : [ 15 ] fall ( ? ev , ? state ) , fall-1 ( ? ev , ? obj ) , ball ( ? obj ) , red ( ? obj2 ) To resolve the equality between ? obj and ? obj2 , the speaker could create the following rule : The predicate ball is declared to belong to semcat4 and the word ball to syncat4 . The predicate red belongs to semcat3 and the word red to syncat3 . Rendering the syntactic structure after application of this rule gives the sentence fall red ball ba . A hierarchical structure ( figure 3 ) emerges because ball participates in two rules . 7 Re-use Agents obviously should not invent new conventions from scratch every time they need one , but rather use as much as possible existing categorisations and hence existing rules . This simple economy principle quickly leads to the kind of syntagmatic and paradigmatic regularities that one finds in natural grammars . For example , if the speaker wants to express that a block is falling , no new semantic or syntactic categories or linking rules are needed but block can simply be declared to belong to semcat4 and block to syncat3 and rule [ 14 ] applies . Re-use should be driven by analogy . In one of the largest experiments we have carried out so far , agents had a way to compute the similarity between two event-structures by pairing the primitive operations making up an event . For example , a pick-up action is decomposed into : an object moving into the direction of another stationary object , the first object then touching the second object , and next the two objects moving together in ( roughly ) the opposite direction . A put-down action has similar subevents , except that their ordering is different . The roles of the objects involved ( the hand , the object being picked up ) are identical and so their grammatical marking could be re-used with very low risk of being misunderstood . When a speaker reuses a grammatical marking for a particular semantic category , this gives a strong hint to the hearer what kind of analogy is expected . By using these invention and abduction strategies , semantic categories like agent or patient gradually emerged in the artificial grammars . Figure 4 visualises the result of this experiment ( after 700 games between 2 agents taking turns ) . The x-axis ( randomly ) ranks the different predicate-argument relations , the y-axis their markers . Without re-use , every argument would have its own marker . Now several markers ( such as va or zu ) cover more than one relation . Figure 4 : More compact grammars result from reuse based on semantic analogies . 8 Conclusions The paper reports significant steps towards the computational modeling of a constructivist approach to language development . It has introduced aspects of a construction grammar formalism that is designed to handle the flexibility required for emergent developing grammars . It also proposed that invention , abduction , and induction are necessary and sufficient for language learning . Much more technical work remains to be done but already significant experimental results have been obtained with embodied agents playing situated language games . Most of the open questions concern under what circumstances syntactic and semantic categories should be re-used . Research funded by Sony CSL with additional funding from ESF-OMLL program , EU FET-ECAgents and CNRS OHLL . "}
  },
    {
    "id": "P04-1004",
    "result":     [
            {
        "value":         {
          "start": 17921,
          "end": 17928,
          "text": "openCCG8",
          "labels": ["Tool"]
        },
        "id": 272
      },
            {
        "value":         {
          "start": 18285,
          "end": 18317,
          "text": "Hybrid Logic Dependency Semantics",
          "labels": ["Method"]
        },
        "id": 273
      },
            {
        "value":         {
          "start": 18321,
          "end": 18324,
          "text": "HLDS",
          "labels": ["Method"]
        },
        "id": 277
      },
            {
        "value":         {
          "start": 18425,
          "end": 18428,
          "text": "HLDS",
          "labels": ["Method"]
        },
        "id": 277
      },
            {
        "value":         {
          "start": 18483,
          "end": 18486,
          "text": "HLDS",
          "labels": ["Method"]
        },
        "id": 277
      },
            {
        "value":         {
          "start": 19142,
          "end": 19145,
          "text": "HLDS",
          "labels": ["Method"]
        },
        "id": 277
      },
            {
        "value":         {
          "start": 22698,
          "end": 22709,
          "text": "completeness",
          "labels": ["Metric"]
        },
        "id": 275
      },
            {
        "value":         {
          "start": 22713,
          "end": 22720,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22728,
          "end": 22736,
          "text": "relevance",
          "labels": ["Metric"]
        },
        "id": 276
      },
            {
        "value":         {
          "start": 24152,
          "end": 24155,
          "text": "HLDS",
          "labels": ["Method"]
        },
        "id": 277
      }
    ],
    "data": {"text": "Analysis of Mixed Natural and Symbolic Language Input in Mathematical Dialogs Abstract Discourse in formal domains , such as mathematics , is characterized by a mixture of telegraphic natural language and embedded ( semi - ) formal symbolic mathematical expressions . We present language phenomena observed in a corpus of dialogs with a simulated tutorial system for proving theorems as evidence for the need for deep syntactic and semantic analysis . We propose an approach to input understanding in this setting . Our goal is a uniform analysis of inputs of different degree of verbalization : ranging from symbolic alone to fully worded mathematical expressions . 1 Introduction Our goal is to develop a language understanding module for a flexible dialog system tutoring mathematical problem solving , in particular , theorem proving ( Benzmuller et al. , 2003a ) .1 As empirical findings in the area of intelligent tutoring show , flexible natural language dialog supports active learning ( Moore , 1993 ) . However , little is known about the use of natural language in dialog setting in formal domains , such as mathematics , due to the lack of empirical data . To fill this gap , we collected a corpus of dialogs with a simulated tutorial dialog system for teaching proofs in naive set theory . An investigation of the corpus reveals various phenomena that present challenges for such input understanding techniques as shallow syntactic analysis combined with keyword spotting , or statistical methods , e.g. , Latent Semantic Analysis , which are commonly employed in ( tutorial ) dialog systems . The prominent characteristics of the language in our corpus include : ( i ) tight interleaving of natural and symbolic language , ( ii ) varying degree of natural language verbalization of the formal mathematical content , and ( iii ) informal and/or imprecise reference to mathematical concepts and relations . These phenomena motivate the need for deep syntactic and semantic analysis in order to ensure correct mapping of the surface input to the underlying proof representation . An additional methodological desideratum is to provide a uniform treatment of the different degrees of verbalization of the mathematical content . By designing one grammar which allows a uniform treatment of the linguistic content on a par with the mathematical content , one can aim at achieving a consistent analysis void of example-based heuristics . We present such an approach to analysis here . The paper is organized as follows : In Section 2 , we summarize relevant existing approaches to input analysis in ( tutorial ) dialog systems on the one hand and analysis of mathematical discourse on the other . Their shortcomings with respect to our setting become clear in Section 3 where we show examples of language phenomena from our dialogs . In Section 4 , we propose an analysis methodology that allows us to capture any mixture of natural and mathematical language in a uniform way . We show example analyses in Section 5 . In Section 6 , we conclude and point out future work issues . 2 Related work Language understanding in dialog systems , be it with text or speech interface , is commonly performed using shallow syntactic analysis combined with keyword spotting . Tutorial systems also successfully employ statistical methods which compare student responses to a model built from preconstructed gold-standard answers ( Graesser et al. , 2000 ) . This is impossible for our dialogs , due to the presence of symbolic mathematical expressions . Moreover , the shallow techniques also remain oblivious of such aspects of discourse meaning as causal relations , modality , negation , or scope of quantifiers which are of crucial importance in our setting . When precise understanding is needed , tutorial systems either use menu - or template-based input , or use closed-questions to elicit short answers of little syntactic variation ( Glass , 2001 ) . However , this conflicts with the preference for flexible dialog in active learning ( Moore , 1993 ) . With regard to interpreting mathematical texts , ( Zinn , 2003 ) and ( Baur , 1999 ) present DRT analyses of course-book proofs . However , the language in our dialogs is more informal : natural language and symbolic mathematical expressions are mixed more freely , there is a higher degree and more variety of verbalization , and mathematical objects are not properly introduced . Moreover , both above approaches rely on typesetting and additional information that identifies mathematical symbols , formulae , and proof steps , whereas our input does not contain any such information . Forcing the user to delimit formulae would reduce the flexibility of the system , make the interface harder to use , and might not guarantee a clean separation of the natural language and the non-linguistic content anyway . 3 Linguistic data In this section , we first briefly describe the corpus collection experiment and then present the common language phenomena found in the corpus . 3.1 Corpus collection 24 subjects with varying educational background and little to fair prior mathematical knowledge participated in a Wizard-of-Oz experiment ( Benzmuller et al. , 2003b ) . In the tutoring session , they were asked to prove 3 theorems2 : ( iii ) . To encourage dialog with the system , the subjects were instructed to enter proof steps , rather than complete proofs at once . Both the subjects and the tutor were free in formulating their turns . Buttons were available in the interface for inserting mathematical symbols , while literals were typed on the keyboard . The dialogs were typed in German . The collected corpus consists of 66 dialog logfiles , containing on average 12 turns . The total number of sentences is 1115 , of which 393 are student sentences . The students turns consisted on average of 1 sentence , the tutors of 2 . More details on the corpus itself and annotation efforts that guide the development of the system components can be found in ( Wolska et al. , 2004 ) . 2 stands for set complement and for power set . 3.2 Language phenomena To indicate the overall complexity of input understanding in our setting , we present an overview of common language phenomena in our dialogs .3 In the remainder of this paper , we then concentrate on the issue of interleaved natural language and mathematical expressions , and present an approach to processing this type of input . Interleaved natural language and formulae Mathematical language , often semi-formal , is interleaved with natural language informally verbalizing proof steps . In particular , mathematical expressions ( or parts thereof ) may lie within the scope of quantifiers or negation expressed in natural language : For parsing , this means that the mathematical content has to be identified before it is interpreted within the utterance . Imprecise or informal naming Domain relations and concepts are described informally using imprecise and/or ambiguous expressions . A enthaelt B [ A contains B ] A muss in B sein [ A must be in B ] where contain and be in can express the domain relation of either subset or element ; where be outside of and be different are informal descriptions of the empty intersection of sets . To handle imprecision and informality , we constructed an ontological knowledge base containing domain-specific interpretations of the predicates ( Horacek and Wolska , 2004 ) . Discourse deixis Anaphoric expressions refer deictically to pieces of discourse : der obere Ausdruck [ the above term ] der letzte Satz [ the last sentence ] Folgerung aus dem Obigen [ conclusion from the above ] aus der regel in der zweiten Zeile In our domain , this class of referring expressions also includes references to structural parts of terms and formulae such as the left side or the inner parenthesis which are incomplete specifications : the former refers to a part of an equation , the latter , metonymic , to an expression enclosed in parenthesis . Moreover , these expressions require discourse referents for the sub-parts of mathematical expressions to be available . Generic vs. specific reference Generic and specific references can appear within one utterance : where a power set is a generic reference , whereas is a specific reference to a subset of a specific instance of a power set introduced earlier . Co-reference4 Co-reference phenomena specific to informal mathematical discourse involve ( parts of ) mathematical expressions within text . Entities denoted with the same literals may or may not co-refer : DeMorgan-Regel-2 besagt : = In diesem Fall : z.B. = dem Begriff ) = dem Begriff [DeMorgan-Regel-2 means: ) In this case : e.g. = the term = the term ] Informal descriptions of proof-step actions Sometimes , actions involving terms , formulae or parts thereof are verbalized before the appropriate formal operation is performed : Wende zweimal die DeMorgan-Regel an [ Im applying DeMorgan rule twice ] damit kann ich den oberen Ausdruck wie folgt schreiben : ... [ given this I can write the upper term as follows : ... ] The meaning of the action verbs is needed for the interpretation of the intended proof-step . Metonymy Metonymic expressions are used to refer to structural sub-parts of formulae , resulting in predicate structures acceptable informally , yet incompatible in terms of selection restrictions . , der Begriff A B dann ja schon dadrin und ist somit auch Element davon [ Then for the left hand side it holds that ... , the term A Bis already there , and so an element of it ] 4To indicate co-referential entities , we inserted the indices which are not present in the dialog logfiles . where the predicate hold , in this domain , normally takes an argument of sort CONST , TERM or FORMULA , rather than LOCATION ; de morgan regel 2 auf beide komplemente angewendet [ de morgan rule 2 applied to both complements ] where the predicate apply takes two arguments : one of sort RULE and the other of sort TERM or FORMULA , rather than OPERATION ON SETS . In the next section , we present our approach to a uniform analysis of input that consists of a mixture of natural language and mathematical expressions . 4 Uniform input analysis strategy The task of input interpretation is two-fold . Firstly , it is to construct a representation of the utterances linguistic meaning . Secondly , it is to identify and separate within the utterance : ( i ) parts which constitute meta-communication with the tutor , e.g. : Ich habe die Aufgabenstellung nicht verstanden . [ I dont understand what the task is . ] ( ii ) parts which convey domain knowledge that should be verified by a domain reasoner ; for example , the entire utterance ist laut deMorgan-1 [ ... is , according to deMorgan-1 , ... ] can be evaluated ; on the other hand , the domain reasoners knowledge base does not contain appropriate representations to evaluate the correctness of using , e.g. , the focusing particle also , as in : Our goal is to provide a uniform analysis of inputs of varying degrees of verbalization . This is achieved by the use of one grammar that is capable of analyzing utterances that contain both natural language and mathematical expressions . Syntactic categories corresponding to mathematical expressions are treated in the same way as those of linguistic lexical entries : they are part of the deep analysis , enter into dependency relations and take on semantic roles . The analysis proceeds in 2 stages : 1 . After standard pre-processing ,5 mathematical expressions are identified , analyzed , categorized , and substituted with default lexicon entries encoded in the grammar ( Section 4.1 ) . ) of bracketed sub-expressions includes : A B , C D , , etc. . Evaluation We have conducted a preliminary evaluation of the mathematical expression parser . Both the student and tutor turns were included to provide more data for the evaluation . Of the 890 mathematical expressions found in the corpus ( 432 in the student and 458 in the tutor turns ) , only 9 were incorrectly recognized . The following classes of errors were detected : 6 2 . Next , the input is syntactically parsed , and a representation of its linguistic meaning is constructed compositionally along with the parse ( Section 4.2 ) . The obtained linguistic meaning representation is subsequently merged with discourse context and interpreted by consulting a semantic lexicon of the domain and a domain-specific knowledge base ( Section 4.3 ) . If the syntactic parser fails to produce an analysis , a shallow chunk parser and keyword-based rules are used to attempt partial analysis and build a partial representation of the predicate-argument structure . In the next sections , we present the procedure of constructing the linguistic meaning of syntactically well-formed utterances . 4.1 Parsing mathematical expressions The task of the mathematical expression parser is to identify mathematical expressions . The identified mathematical expressions are subsequently verified as to syntactic validity and categorized . Implementation Identification of mathematical expressions within word-tokenized text is performed using simple indicators : single character tokens ( with the characters and standing for power set and set complement respectively ) , mathematical symbol unicodes , and new-line characters . The tagger converts the infix notation used in the input into an expression tree from which the following information is available : surface sub-structure ( e.g. , left side of an expression , list of sub-expressions , list of bracketed sub-expressions ) and expression type based on the top level operator ( e.g. , CONST , TERM , FORMULA 0 FORMULA ( formula missing left argument ) , etc. ) . For example , the expression ) is represented by the formula tree in Fig. 1 . The bracket subscripts indicate the operators heading sub-formulae enclosed in parenthesis . Given the expressions top node operator , = , the expression is of type formula , its left side is the expression , the list [ The same holds with ... ] The examples in ( 1 ) and ( 2 ) have to do with parentheses . In ( 1 ) , the student actually omitted them . The remedy in such cases is to ask the student to correct the input . In ( 2 ) , on the other hand , no parentheses are missing , but they are ambiguous between mathematical brackets and parenthetical statement markers . The parser mistakenly included one of the parentheses with the mathematical expressions , thereby introducing an error . We could include a list of mathematical operations allowed to be verbalized , in order to include the logical connective in ( 2a ) in the tagged formula . But ( 2b ) shows that this simple solution would not remedy the problem overall , as there is no pattern as to the amount and type of linguistic material accompanying the formulae in parenthesis . We are presently working on ways to identify the two uses of parentheses in a pre-processing step . In ( 3 ) the error is caused by a non-standard character , ? , found in the formula . In ( 4 ) the student omitted punctuation causing the character D to be interpreted as a nonstandard literal for naming an operation on sets . 4.2 Deep analysis The task of the deep parser is to produce a domainindependent linguistic meaning representation of syntactically well-formed sentences and fragments . By linguistic meaning ( LM ) , we understand the dependency-based deep semantics in the sense of the Prague School notion of sentence meaning as employed in the Functional Generative Description ( FGD ) ( Sgall et al. , 1986 ; Kruijff , 2001 ) . It represents the literal meaning of the utterance rather than a domain-specific interpretation .7 In FGD , the central frame unit of a sentence/clause is the head verb which specifies the tectogrammatical relations ( TRs ) of its dependents ( participants ) . Further distinction is drawn into inner participants , such as Actor , Patient , Addressee , and free modifications , such as Location , Means , Direction . Using TRs rather than surface grammatical roles provides a generalized view of the correlations between domain-specific content and its linguistic realization . We use a simplified set of TRs based on ( Hajicova et al. , 2000 ) . One reason for simplification is to distinguish which relations are to be understood metaphorically given the domain sub-language . In order to allow for ambiguity in the recognition of TRs , we organize them hierarchically into a taxonomy . The most commonly occurring relations in our context , aside from the inner participant roles of Actor and Patient , are Cause , Condition , and ResultConclusion ( which coincide with the rhetorical relations in the argumentative structure of the proof ) , for example : Da [ A gilt ] CAUSE , alle x , die in A sind sind nicht in B [ As A applies , all x that are in A are not in B ] Wenn [ A ] COND , dann A B = [ IfA , thenA B = ] Da gilt , [ alle x , die in A sind sind nicht in B ] RES Wenn A , dann [ A B = ] RES Other commonly found TRs include NormCriterion , e.g. [ nach deMorgan-Regel-2 ] NORM ist = ... ) [ according to De Morgan rule 2 it holds that ... ] ist [ laut DeMorgan-1 ] NORM ( ) [ ... equals , according to De Morgan rule1 , ... ] We group other relations into sets of HasProperty , GeneralRelation ( for adjectival and clausal modification ) , and Other ( a catch-all category ) , for example : dann muessen alla A und B [ in C ] PROP-LOC enthalten sein where PROP-LOC denotes the HasProperty relation of type Location , GENREL is a general relation as in complementation , and PROP-FROM is a HasProperty relation of type Direction-From or From-Source . More details on the investigation into tectogrammatical relations that build up linguistic meaning of informal mathematical text can be found in ( Wolska and Kruijff-Korbayova , 2004a ) . The syntactic analysis is performed using openCCG8 , an open source parser for Multi-Modal Combinatory Categorial Grammar ( MMCCG ) . MMCCG is a lexicalist grammar formalism in which application of combinatory rules is controlled though context-sensitive specification of modes on slashes ( Baldridge and Kruijff , 2003 ) . The linguistic meaning , built in parallel with the syntax , is represented using Hybrid Logic Dependency Semantics ( HLDS ) , a hybrid logic representation which allows a compositional , unification-based construction of HLDS terms with CCG ( Baldridge and Kruijff , 2002 ) . An HLDS term is a relational structure where dependency relations between heads and dependents are encoded as modal relations . The syntactic categories for a lexical entry FORMULA , corresponding to mathematical expressions of type formula , are , , and . For example , in one of the readings of B enthaelt enthaelt represents the meaning contain taking dependents in the relations Actor and Patient , shown schematically in Fig. 2 . enthalten : contain utterance B enthaelt [ B contains ] . FORMULA represents the default lexical entry for identified mathematical expressions categorized as formula ( cf. Section 4.1 ) . The LM is represented by the following HLDS term : @ h1 ( contain ACT ( f1 FORMULA : B ) PAT ( f2 FORMULA : ) where h1 is the state where the proposition contain is true , and the nominals f1 and f2 represent dependents of the head contain , which stand in the tectogrammatical relations Actor and Patient , respectively . It is possible to refer to the structural sub-parts of the FORMULA type expressions , as formula subparts are identified by the tagger , and discourse ref erents are created for them and stored with the discourse model . We represent the discourse model within the same framework of hybrid modal logic . Nominals of the hybrid logic object language are atomic formulae that constitute a pointing device to a particular place in a model where they are true . The satisfaction operator , @ , allows to evaluate a formula at the point in the model given by a nominal ( e.g. the formula @ evaluates at the point i ) . For discourse modeling , we adopt the hybrid logic formalization of the DRT notions in ( Kruijff , 2001 ; Kruijff and Kruijff-Korbayova , 2001 ) . Within this formalism , nominals are interpreted as discourse referents that are bound to propositions through the satisfaction operator . In the example above , f1 and f2 represent discourse referents for FORMULA : B and FORMULA : , respectively . More technical details on the formalism can be found in the aforementioned publications . 4.3 Domain interpretation The linguistic meaning representations obtained from the parser are interpreted with respect to the domain . We are constructing a domain ontology that reflects the domain reasoners knowledge base , and is augmented to allow resolution of ambiguities introduced by natural language . For example , the previously mentioned predicate contain represents the semantic relation of Containment which , in the domain of naive set theory , is ambiguous between the domain relations ELEMENT , SUBSET , and PROPER SUBSET . The specializations of the ambiguous semantic relations are encoded in the ontology , while a semantic lexicon provides interpretations of the predicates . At the domain interpretation stage , the semantic lexicon is consulted to translate the tectogrammatical frames of the predicates into the semantic relations represented in the domain ontology . More details on the lexical-semantic stage of interpretation can be found in ( Wolska and KruijffKorbayova , 2004b ) , and more details on the domain ontology are presented in ( Horacek and Wolska , 2004 ) . For example , for the predicate contain , the lexicon contains the following facts : , ) ( SUBFORMULA , embedding ) [ a Patient of type FORMULA is a subformula embedded within a FORMULA in the Actor relation with respect to the head contain ] Translation rules that consult the ontology expand the meaning of the predicates to all their alternative domain-specific interpretations preserving argument structure . As it is in the capacity of neither sentence-level nor discourse-level analysis to evaluate the correctness of the alternative interpretations , this task is delegated to the Proof Manager ( PM ) . The task of the PM is to : ( A ) communicate directly with the theorem prover ; 9 ( B ) build and maintain a representation of the proof constructed by the student ; 10 ( C ) check type compatibility of proof-relevant entities introduced as new in discourse ; ( D ) check consistency and validity of each of the interpretations constructed by the analysis module , with the proof context ; ( E ) evaluate the proof-relevant part of the utterance with respect to completeness , accuracy , and relevance . 5 Example analysis In this section , we illustrate the mechanics of the approach on the following examples . Example ( 1 ) shows the tight interaction of natural language and mathematical formulae . The intended reading of the scope of negation is over a part of the formula following it , rather than the whole formula . The analysis proceeds as follows . The formula tagger first identifies the formula x A and substitutes it with the generic entry FORMULA represented in the lexicon . If there was no prior discourse entity for B to verify its type , the type is ambiguous between CONST , TERM , and FORMULA .11 The sentence is assigned four alternative readings : The last reading is obtained by partitioning an entity of type FORMULA in meaningful ways , taking into account possible interaction with preceding modifiers . Here , given the quantifier no , the expression x A has been split into its surface parts 9We are using a version of MEGA adapted for assertionlevel proving ( Vo et al. , 2003 ) . tains no ] . as follows : [ x ] [ A ] .12 [ x ] has been substituted with a generic lexical entry CONST , and [ A ] with a symbolic entry for a formula missing its left argument ( cf. Section 4.1 ) . The readings ( i ) and ( ii ) are rejected because of sortal incompatibility . The linguistic meanings of readings ( iii ) and ( iv ) are presented in Fig. 3 and Fig. 4 , respectively . The corresponding HLDS representations are : 13 for FORMULA contains no FORMULA : s : ( @ k1 ( kein RESTR f2 BODY ( e1 enthalten ACT ( f1 FORMULA ) PAT f2 ) ) @ f2 ( FORMULA ) ) [ formula B embeds no subformula x A ] for CONST contains no CONST 0 FORMULA : Next , the semantic lexicon is consulted to translate these readings into their domain interpretations . The relevant lexical semantic entries were presented in Section 4.3 . Using the linguistic meaning , the semantic lexicon , and the ontology , we obtain four interpretations paraphrased below : for FORMULA contains no FORMULA : ( 1.1 ) it is not the case that PAT , the formula , x A , is a subformula of ACT , the formula B ; for CONST contains no CONST 0 FORMULA : The interpretation ( 1.1 ) is verified in the discourse context with information on structural parts of the discourse entity B of type formula , while ( 1.2a-c ) are translated into messages to the PM and passed on for evaluation in the proof context . Example ( 2 ) contains one mathematical formula . Such utterances are the simplest to analyze : The formulae identified by the mathematical expression tagger are passed directly to the PM . Example ( 3 ) shows an utterance with domainrelevant content fully linguistically verbalized . The analysis of fully verbalized utterances proceeds similarly to the first example : the mathematical expressions are substituted with the appropriate generic lexical entries ( here , A and B are substituted with their three possible alternative readings : CONST , TERM , and FORMULA , yielding several readings CONST contains no elements that are also in CONST , TERM contains no elements that are also in TERM , etc. ) . Next , the sentence is analyzed by the grammar . The semantic roles of Actor and Patient associated with the verb contain are taken by A and elements respectively ; quantifier no is in the relation Restrictor with A ; the relative clause is in the GeneralRelation with elements , etc. . The linguistic meaning of the utterance in example ( 3 ) is shown in Fig. 5 . Then , the semantic lexicon and the ontology are consulted to translate the linguistic meaning into its domain-specific interpretations , which are in this case very similar to the ones of example ( 1 ) . 6 Conclusions and Further Work Based on experimentally collected tutorial dialogs on mathematical proofs , we argued for the use of deep syntactic and semantic analysis . We presented an approach that uses multimodal CCG with hy ] . [ B conbrid logic dependency semantics , treating natural and symbolic language on a par , thus enabling uniform analysis of inputs with varying degree of formal content verbalization . A preliminary evaluation of the mathematical expression parser showed a reasonable result . We are incrementally extending the implementation of the deep analysis components , which will be evaluated as part of the next Wizard-of-Oz experiment . One of the issues to be addressed in this context is the treatment of ill-formed input . On the one hand , the system can initiate a correction subdialog in such cases . On the other hand , it is not desirable to go into syntactic details and distract the student from the main tutoring goal . We therefore need to handle some degree of ill-formed input . Another question is which parts of mathematical expressions should have explicit semantic representation . We feel that this choice should be motivated empirically , by systematic occurrence of natural language references to parts of mathematical expressions ( e.g. , the left/right side , the parenthesis , and the inner parenthesis ) and by the syntactic contexts in which they occur ( e.g. , the partitioning [ x ] [ A ] seems well motivated in B contains no x A ; [ x ] is a constituent in x of complement of B. ) We also plan to investigate the interaction of modal verbs with the argumentative structure of the proof . For instance , the necessity modality is compatible with asserting a necessary conclusion or a prerequisite condition ( e.g. , A und B muessen disjunkt sein . [ A and B must be disjoint . ] ) . This introduces an ambiguity that needs to be resolved by the domain reasoner . "}
  },
    {
    "id": "P05-1004",
    "result":     [
            {
        "value":         {
          "start": 376,
          "end": 382,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 1150,
          "end": 1156,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 1874,
          "end": 1880,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 1891,
          "end": 1911,
          "text": "UMLS medical resource",
          "labels": ["Dataset"]
        },
        "id": 277
      },
            {
        "value":         {
          "start": 2111,
          "end": 2117,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 2373,
          "end": 2383,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 2419,
          "end": 2430,
          "text": "BLLIP corpus",
          "labels": ["Dataset"]
        },
        "id": 279
      },
            {
        "value":         {
          "start": 2437,
          "end": 2447,
          "text": "WORDNET 2.0",
          "labels": ["Dataset"]
        },
        "id": 282
      },
            {
        "value":         {
          "start": 2627,
          "end": 2633,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 3036,
          "end": 3042,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 3130,
          "end": 3136,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 3268,
          "end": 3275,
          "text": "WORDNETs",
          "labels": ["Dataset"]
        },
        "id": 491
      },
            {
        "value":         {
          "start": 3765,
          "end": 3775,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 3915,
          "end": 3921,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 4275,
          "end": 4281,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 4345,
          "end": 4355,
          "text": "WORDNET 2.0",
          "labels": ["Dataset"]
        },
        "id": 282
      },
            {
        "value":         {
          "start": 4977,
          "end": 4983,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 5076,
          "end": 5086,
          "text": "miniWORDNET",
          "labels": ["Dataset"]
        },
        "id": 282
      },
            {
        "value":         {
          "start": 5113,
          "end": 5119,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 5271,
          "end": 5277,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 5404,
          "end": 5410,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 5560,
          "end": 5566,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 6099,
          "end": 6105,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 6664,
          "end": 6670,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 6756,
          "end": 6770,
          "text": "lexical FreeNet",
          "labels": ["Dataset"]
        },
        "id": 283
      },
            {
        "value":         {
          "start": 7247,
          "end": 7254,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 7832,
          "end": 7838,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 8474,
          "end": 8480,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 8590,
          "end": 8613,
          "text": "Latent Semantic Analysis",
          "labels": ["Method"]
        },
        "id": 284
      },
            {
        "value":         {
          "start": 8838,
          "end": 8870,
          "text": "multi-class perceptron classifier",
          "labels": ["Method"]
        },
        "id": 285
      },
            {
        "value":         {
          "start": 9056,
          "end": 9062,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 9456,
          "end": 9462,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 9516,
          "end": 9528,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 9536,
          "end": 9546,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 9592,
          "end": 9616,
          "text": "cross-validation approach",
          "labels": ["Method"]
        },
        "id": 287
      },
            {
        "value":         {
          "start": 9671,
          "end": 9681,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 9744,
          "end": 9756,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10041,
          "end": 10053,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10168,
          "end": 10178,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10209,
          "end": 10224,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10271,
          "end": 10275,
          "text": "BLLIP",
          "labels": ["Dataset"]
        },
        "id": 289
      },
            {
        "value":         {
          "start": 10369,
          "end": 10381,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10400,
          "end": 10415,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10428,
          "end": 10438,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10500,
          "end": 10510,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10547,
          "end": 10559,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 10862,
          "end": 10892,
          "text": "British National Corpus ( BNC )",
          "labels": ["Dataset"]
        },
        "id": 290
      },
            {
        "value":         {
          "start": 10900,
          "end": 10931,
          "text": "Reuters Corpus Volume 1 ( RCV1 )",
          "labels": ["Dataset"]
        },
        "id": 291
      },
            {
        "value":         {
          "start": 10951,
          "end": 10987,
          "text": "Linguistic Data Consortiums news text",
          "labels": ["Dataset"]
        },
        "id": 292
      },
            {
        "value":         {
          "start": 11012,
          "end": 11040,
          "text": "Continuous Speech Recognition",
          "labels": ["Dataset"]
        },
        "id": 293
      },
            {
        "value":         {
          "start": 11048,
          "end": 11050,
          "text": "CSR",
          "labels": ["Dataset"]
        },
        "id": 294
      },
            {
        "value":         {
          "start": 11060,
          "end": 11100,
          "text": "North American News Text Corpus ( NANTC )",
          "labels": ["Dataset"]
        },
        "id": 295
      },
            {
        "value":         {
          "start": 11108,
          "end": 11133,
          "text": "NANTC Supplement ( NANTS )",
          "labels": ["Dataset"]
        },
        "id": 296
      },
            {
        "value":         {
          "start": 11145,
          "end": 11159,
          "text": "ACQUAINT Corpus",
          "labels": ["Dataset"]
        },
        "id": 297
      },
            {
        "value":         {
          "start": 11243,
          "end": 11245,
          "text": "LDC",
          "labels": ["Dataset"]
        },
        "id": 298
      },
            {
        "value":         {
          "start": 11273,
          "end": 11295,
          "text": "English Gigaword corpus",
          "labels": ["Dataset"]
        },
        "id": 648
      },
            {
        "value":         {
          "start": 11384,
          "end": 11405,
          "text": "Grok-OpenNLP tokenizer",
          "labels": ["Tool"]
        },
        "id": 299
      },
            {
        "value":         {
          "start": 11455,
          "end": 11466,
          "text": "MXTerminator",
          "labels": ["Tool"]
        },
        "id": 300
      },
            {
        "value":         {
          "start": 11758,
          "end": 11776,
          "text": "Vector-space models",
          "labels": ["Method"]
        },
        "id": 302
      },
            {
        "value":         {
          "start": 12001,
          "end": 12019,
          "text": "vector-space models",
          "labels": ["Method"]
        },
        "id": 302
      },
            {
        "value":         {
          "start": 12296,
          "end": 12309,
          "text": "SEXTANT system",
          "labels": ["Method"]
        },
        "id": 302
      },
            {
        "value":         {
          "start": 12499,
          "end": 12505,
          "text": "SEXTANT",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 12567,
          "end": 12573,
          "text": "SEXTANT",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 12729,
          "end": 12744,
          "text": "SEXTANT approach",
          "labels": ["Method"]
        },
        "id": 304
      },
            {
        "value":         {
          "start": 12996,
          "end": 13019,
          "text": "weighted JACCARD measure",
          "labels": ["Metric"]
        },
        "id": 305
      },
            {
        "value":         {
          "start": 13642,
          "end": 13648,
          "text": "SEXTANT",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 13657,
          "end": 13682,
          "text": "maximum entropy POS tagger",
          "labels": ["Method"]
        },
        "id": 306
      },
            {
        "value":         {
          "start": 13811,
          "end": 13823,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 13893,
          "end": 13916,
          "text": "Trigrams ` n Tags tagger",
          "labels": ["Tool"]
        },
        "id": 308
      },
            {
        "value":         {
          "start": 14008,
          "end": 14030,
          "text": "maximum entropy chunker",
          "labels": ["Method"]
        },
        "id": 309
      },
            {
        "value":         {
          "start": 14140,
          "end": 14152,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 14164,
          "end": 14180,
          "text": "CoNLL 2000 script",
          "labels": ["Tool"]
        },
        "id": 310
      },
            {
        "value":         {
          "start": 14194,
          "end": 14206,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 14327,
          "end": 14333,
          "text": "SEXTANT",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 14419,
          "end": 14424,
          "text": "morpha",
          "labels": ["Tool"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 14572,
          "end": 14577,
          "text": "morpha",
          "labels": ["Tool"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 14588,
          "end": 14595,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 14622,
          "end": 14643,
          "text": "CELEX lexical database",
          "labels": ["Dataset"]
        },
        "id": 312
      },
            {
        "value":         {
          "start": 14736,
          "end": 14741,
          "text": "morpha",
          "labels": ["Tool"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 18357,
          "end": 18363,
          "text": "SEXTANT",
          "labels": ["Metric"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 18922,
          "end": 18928,
          "text": "SEXTANT",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 19111,
          "end": 19118,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19196,
          "end": 19201,
          "text": "voting",
          "labels": ["Method"]
        },
        "id": 313
      },
            {
        "value":         {
          "start": 19650,
          "end": 19665,
          "text": "fall-back method",
          "labels": ["Method"]
        },
        "id": 314
      },
            {
        "value":         {
          "start": 19875,
          "end": 19885,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 20234,
          "end": 20244,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 21390,
          "end": 21396,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 21800,
          "end": 21810,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 21887,
          "end": 21899,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 23860,
          "end": 23867,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23923,
          "end": 23933,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 24055,
          "end": 24067,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 24084,
          "end": 24091,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24130,
          "end": 24140,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 24491,
          "end": 24498,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24683,
          "end": 24691,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24695,
          "end": 24700,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 24706,
          "end": 24712,
          "text": "f-score",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 27737,
          "end": 27749,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 27925,
          "end": 27939,
          "text": "fallback method",
          "labels": ["Method"]
        },
        "id": 316
      },
            {
        "value":         {
          "start": 27966,
          "end": 27973,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 27990,
          "end": 28002,
          "text": "WORDNET 1.7.1",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 28145,
          "end": 28151,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 28601,
          "end": 28607,
          "text": "WORDNET",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 28985,
          "end": 28995,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 29238,
          "end": 29248,
          "text": "WORDNET 1.6",
          "labels": ["Dataset"]
        },
        "id": 317
      },
            {
        "value":         {
          "start": 29365,
          "end": 29397,
          "text": "supervised multi-class perceptron",
          "labels": ["Method"]
        },
        "id": 317
      }
    ],
    "data": {"text": "Supersense Tagging of Unknown Nouns using Semantic Similarity Abstract The limited coverage of lexical-semantic resources is a significant problem for NLP systems which can be alleviated by automatically classifying the unknown words . Supersense tagging assigns unknown nouns one of 26 broad semantic categories used by lexicographers to organise their manual insertion into WORDNET . Ciaramita and Johnson ( 2003 ) present a tagger which uses synonym set glosses as annotated training examples . We describe an unsupervised approach , based on vector-space similarity , which does not require annotated examples but significantly outperforms their tagger . We also demonstrate the use of an extremely large shallow-parsed corpus for calculating vector-space semantic similarity . 1 Introduction Lexical-semantic resources have been applied successful to a wide range of Natural Language Processing ( NLP ) problems ranging from collocation extraction ( Pearce , 2001 ) and class-based smoothing ( Clark and Weir , 2002 ) , to text classification ( Baker and McCallum , 1998 ) and question answering ( Pasca and Harabagiu , 2001 ) . In particular , WORDNET ( Fellbaum , 1998 ) has significantly influenced research in NLP . Unfortunately , these resource are extremely timeconsuming and labour-intensive to manually develop and maintain , requiring considerable linguistic and domain expertise . Lexicographers can not possibly keep pace with language evolution : sense distinctions are continually made and merged , words are coined or become obsolete , and technical terms migrate into the vernacular . Technical domains , such as medicine , require separate treatment since common words often take on special meanings , and a significant proportion of their vocabulary does not overlap with everyday vocabulary . Burgun and Bodenreider ( 2001 ) compared an alignment of WORDNET with the UMLS medical resource and found only a very small degree of overlap . Also , lexicalsemantic resources suffer from : bias towards concepts and senses from particular topics . Some specialist topics are better covered in WORDNET than others , e.g . dog has finer-grained distinctions than cat and worm although this does not reflect finer distinctions in reality ; limited coverage of infrequent words and senses . Ciaramita and Johnson ( 2003 ) found that common nouns missing from WORDNET 1.6 occurred every 8 sentences in the BLLIP corpus . By WORDNET 2.0 , coverage has improved but the problem of keeping up with language evolution remains difficult . consistency when classifying similar words into categories . For instance , the WORDNET lexicographer file for ionosphere ( location ) is different to exosphere and stratosphere ( object ) , two other layers of the earths atmosphere . These problems demonstrate the need for automatic or semi-automatic methods for the creation and maintenance of lexical-semantic resources . Broad semantic classification is currently used by lexicographers to organise the manual insertion of words into WORDNET , and is an experimental precursor to automatically inserting words directly into the WORDNET hierarchy . Ciaramita and Johnson ( 2003 ) call this supersense tagging and describe a multi-class perceptron tagger , which uses WORDNETs hierarchical structure to create many annotated training instances from the synset glosses . This paper describes an unsupervised approach to supersense tagging that does not require annotated sentences . Instead , we use vector-space similarity to retrieve a number of synonyms for each unknown common noun . The supersenses of these synonyms are then combined to determine the supersense . This approach significantly outperforms the multi-class perceptron on the same dataset based on WORDNET 1.6 and 1.7.1 . 2 Supersenses There are 26 broad semantic classes employed by lexicographers in the initial phase of inserting words into the WORDNET hierarchy , called lexicographerfzles ( lexfzles ) . For the noun hierarchy , there are 25 lex-files and a file containing the top level nodes in the hierarchy called Tops . Other syntactic classes are also organised using lex-files : 15 for verbs , 3 for adjectives and 1 for adverbs . Lex-files form a set of coarse-grained sense distinctions within WORDNET . For example , company appears in the following lex-files in WORDNET 2.0 : group , which covers company in the social , commercial and troupe fine-grained senses ; and state , which covers companionship . The names and descriptions of the noun lex-files are shown in Table 1 . Some lex-files map directly to the top level nodes in the hierarchy , called unique beginners , while others are grouped together as hyponyms of a unique beginner ( Fellbaum , 1998 , page 30 ) . For example , abstraction subsumes the lex-files attribute , quantity , relation , communication and time . Ciaramita and Johnson ( 2003 ) call the noun lex-file classes supersenses . There are 11 unique beginners in the WORDNET noun hierarchy which could also be used as supersenses . Ciaramita ( 2002 ) has produced a miniWORDNET by manually reducing the WORDNET hierarchy to 106 broad categories . Ciaramita et al . ( 2003 ) describe how the lex-files can be used as root nodes in a two level hierarchy with the WORDNET synsets appearing directly underneath . Other alternative sets of supersenses can be created by an arbitrary cut through the WORDNET hierarchy near the top , or by using topics from a thesaurus such as Rogets ( Yarowsky , 1992 ) . These topic distinctions are coarser-grained than WORDNET senses , which have been criticised for being too difficult to distinguish even for experts . Ciaramita and Johnson ( 2003 ) believe that the key sense distinctions are still maintained by supersenses . They suggest that supersense tagging is similar to named entity recognition , which also has a very small set of categories with similar granularity ( e.g. location and person ) for labelling predominantly unseen terms . Supersense tagging can provide automated or semiautomated assistance to lexicographers adding words to the WORDNET hierarchy . Once this task is solved successfully , it may be possible to insert words directly into the fine-grained distinctions of the hierarchy itself . Clearly , this is the ultimate goal , to be able to insert new terms into lexical resources , extending the structure where necessary . Supersense tagging is also interesting for many applications that use shallow semantics , e.g. information extraction and question answering . 3 Previous Work A considerable amount of research addresses structurally and statistically manipulating the hierarchy of WORDNET and the construction of new wordnets using the concept structure from English . For lexical FreeNet , Beeferman ( 1998 ) adds over 350 000 collocation pairs ( trigger pairs ) extracted from a 160 million word corpus of broadcast news using mutual information . The co-occurrence window was 500 words which was designed to approximate average document length . Caraballo and Charniak ( 1999 ) have explored determining noun specificity from raw text . They find that simple frequency counts are the most effective way of determining the parent-child ordering , achieving 83 % accuracy over types of vehicle , food and occupation . The other measure they found to be successful was the entropy of the conditional distribution of surrounding words given the noun . Specificity ordering is a necessary step for building a noun hierarchy . However , this approach clearly can not build a hierarchy alone . For instance , entity is less frequent than many concepts it subsumes . This suggests it will only be possible to add words to an existing abstract structure rather than create categories right up to the unique beginners . Hearst and Schutze ( 1993 ) flatten WORDNET into 726 categories using an algorithm which attempts to minimise the variance in category size . These categories are used to label paragraphs with topics , effectively repeating Yarowskys ( 1992 ) experiments using the their categories rather than Rogets thesaurus . Schutzes ( 1992 ) WordSpace system was used to add topical links , such as between ball , racquet and game ( the tennis problem ) . Further , they also use the same vector-space techniques to label previously unseen words using the most common class assigned to the top 20 synonyms for that word . Widdows ( 2003 ) uses a similar technique to insert words into the WORDNET hierarchy . He first extracts synonyms for the unknown word using vector-space similarity measures based on Latent Semantic Analysis and then searches for a location in the hierarchy nearest to these synonyms . This same technique as is used in our approach to supersense tagging . Ciaramita and Johnson ( 2003 ) implement a supersense tagger based on the multi-class perceptron classifier ( Crammer and Singer , 2001 ) , which uses the standard collocation , spelling and syntactic features common in WSD and named entity recognition systems . Their insight was to use the WORDNET glosses as annotated training data and massively increase the number of training instances using the noun hierarchy . They developed an efficient algorithm for estimating the model over hierarchical training data . 4 Evaluation Ciaramita and Johnson ( 2003 ) propose a very natural evaluation for supersense tagging : inserting the extra common nouns that have been added to a new version of WORDNET . They use the common nouns that have been added to WORDNET 1.7.1 since WORDNET 1.6 and compare this evaluation with a standard cross-validation approach that uses a small percentage of the words from their WORDNET 1.6 training set for evaluation . Their results suggest that the WORDNET 1.7.1 test set is significantly harder because of the large number of abstract category nouns , e.g . communication and cognition , that appear in the 1.7.1 data , which are difficult to classify . Our evaluation will use exactly the same test sets as Ciaramita and Johnson ( 2003 ) . The WORDNET 1.7.1 test set consists of 744 previously unseen nouns , the majority of which ( over 90 % ) have only one sense . The WORDNET 1.6 test set consists of several cross-validation sets of 755 nouns randomly selected from the BLLIP training set used by Ciaramita and Johnson ( 2003 ) . They have kindly supplied us with the WORDNET 1.7.1 test set and one cross-validation run of the WORDNET 1.6 test set . Our development experiments are performed on the WORDNET 1.6 test set with one final run on the WORDNET 1.7.1 test set . Some examples from the test sets are given in Table 2 with their supersenses . 5 Corpus We have developed a 2 billion word corpus , shallowparsed with a statistical NLP pipeline , which is by far the largest NLP processed corpus described in published research . The corpus consists of the British National Corpus ( BNC ) , the Reuters Corpus Volume 1 ( RCV1 ) , and most of the Linguistic Data Consortiums news text collected since 1987 : Continuous Speech Recognition III ( CSR-III ) ; North American News Text Corpus ( NANTC ) ; the NANTC Supplement ( NANTS ) ; and the ACQUAINT Corpus . The components and their sizes including punctuation are given in Table 3 . The LDC has recently released the English Gigaword corpus which includes most of the corpora listed above . We have tokenized the text using the Grok-OpenNLP tokenizer ( Morton , 2002 ) and split the sentences using MXTerminator ( Reynar and Ratnaparkhi , 1997 ) . Any sentences less than 3 words or more than 100 words long were rejected , along with sentences containing more than 5 numbers or more than 4 brackets , to reduce noise . The rest of the pipeline is described in the next section . 6 Semantic Similarity Vector-space models of similarity are based on the distributional hypothesis that similar words appear in similar contexts . This hypothesis suggests that semantic similarity can be measured by comparing the contexts each word appears in . In vector-space models each headword is represented by a vector of frequency counts recording the contexts that it appears in . The key parameters are the context extraction method and the similarity measure used to compare context vectors . Our approach to vector-space similarity is based on the SEXTANT system described in Grefenstette ( 1994 ) . Curran and Moens ( 2002b ) compared several context extraction methods and found that the shallow pipeline and grammatical relation extraction used in SEXTANT was both extremely fast and produced high-quality results . SEXTANT extracts relation tuples ( w , r , w0 ) for each noun , where w is the headword , r is the relation type and w0 is the other word . The efficiency of the SEXTANT approach makes the extraction of contextual information from over 2 billion words of raw text feasible . We describe the shallow pipeline in detail below . Curran and Moens ( 2002a ) compared several different similarity measures and found that Grefenstettes weighted JACCARD measure performed the best : where wgt ( w , r , w0 ) is the weight function for relation ( w , r , w0 ) . Curran and Moens ( 2002a ) introduced the TTEST weight function , which is used in collocation extraction . Here , the t-test compares the joint and product probability distributions of the headword and context : where indicates a global sum over that element of the relation tuple . JACCARD and TTEST produced better quality synonyms than existing measures in the literature , so we use Curran and Moens configuration for our supersense tagging experiments . 6.1 Part of Speech Tagging and Chunking Our implementation of SEXTANT uses a maximum entropy POS tagger designed to be very efficient , tagging at around 100 000 words per second ( Curran and Clark , 2003 ) , trained on the entire Penn Treebank ( Marcus et al . , 1994 ) . The only similar performing tool is the Trigrams ` n Tags tagger ( Brants , 2000 ) which uses a much simpler statistical model . Our implementation uses a maximum entropy chunker which has similar feature types to Koeling ( 2000 ) and is also trained on chunks extracted from the entire Penn Treebank using the CoNLL 2000 script . Since the Penn Treebank separates PPs and conjunctions from NPs , they are concatenated to match Grefenstettes table-based results , i.e . the SEXTANT always prefers noun attachment . 6.2 Morphological Analysis Our implementation uses morpha , the Sussex morphological analyser ( Minnen et al . , 2001 ) , which is implemented using lex grammars for both affix splitting and generation . morpha has wide coverage nearly 100 % against the CELEX lexical database ( Minnen et al . , 2001 ) and is very efficient , analysing over 80 000 words per second . morpha often maintains sense distinctions between singular and plural nouns ; for instance : spectacles is not reduced to spectacle , but fails to do so in other cases : glasses is converted to glass . This inconsistency is problematic when using morphological analysis to smooth vector-space models . However , morphological smoothing still produces better results in practice . 6.3 Grammatical Relation Extraction After the raw text has been POS tagged and chunked , the grammatical relation extraction algorithm is run over the chunks . This consists of five passes over each sentence that first identify noun and verb phrase heads and then collect grammatical relations between each common noun and its modifiers and verbs . A global list of grammatical relations generated by each pass is maintained across the passes . The global list is used to determine if a word is already attached . Once all five passes have been completed this association list contains all of the nounmodifier/verb pairs which have been extracted from the sentence . The types of grammatical relation extracted by SEXTANT are shown in Table 4 . For relations between nouns ( nn and nnprep ) , we also create inverse relations ( w0 , r0 , w ) representing the fact that w0 can modify w . The 5 passes are described below . Pass 1: Noun Pre-modifiers This pass scans NPs , left to right , creating adjectival ( adj ) and nominal ( nn ) pre-modifier grammatical relations ( GRs ) with every noun to the pre-modifiers right , up to a preposition or the phrase end . This corresponds to assuming right-branching noun compounds . Within each NP only the NP and PP heads remain unattached . Pass 2: Noun Post-modifiers This pass scans NPs , right to left , creating post-modifier GRs between the unattached heads of NPs and PPs . If a preposition is encountered between the noun heads , a prepositional noun ( nnprep ) GR is created , otherwise an appositional noun ( nn ) GR is created . This corresponds to assuming right-branching PP attachment . After this phrase only the NP head remains unattached . Tense Determination The rightmost verb in each VP is considered the head . A VP is initially categorised as active . If the head verb is a form of be then the VP becomes attributive . Otherwise , the algorithm scans the VP from right to left : if an auxiliary verb form of be is encountered the VP becomes passive ; if a progressive verb ( except being ) is encountered the VP becomes active . Only the noun heads on either side of VPs remain unattached . The remaining three passes attach these to the verb heads as either subjects or objects depending on the voice of the VP . Pass 3: Verb Pre-Attachment This pass scans sentences , right to left , associating the first NP head to the left of the VP with its head . If the VP is active , a subject ( subj ) relation is created ; otherwise , a direct object ( dobj ) relation is created . For example , antigen is the subject of represent . Pass 4: Verb Post-Attachment This pass scans sentences , left to right , associating the first NP or PP head to the right of the VP with its head . If the VP was classed as active and the phrase is an NP then a direct object ( dobj ) relation is created . If the VP was classed as passive and the phrase is an NP then a subject ( subj ) relation is created . If the following phrase is a PP then an indirect object ( iobj ) relation is created . The interaction between the head verb and the preposition determine whether the noun is an indirect object of a ditransitive verb or alternatively the head of a PP that is modifying the verb . However , SEXTANT always attaches the PP to the previous phrase . Pass 5: Verb Progressive Participles The final step of the process is to attach progressive verbs to subjects and objects ( without concern for whether they are already attached ) . Progressive verbs can function as nouns , verbs and adjectives and once again a naive approximation to the correct attachment is made . Any progressive verb which appears after a determiner or quantifier is considered a noun . Otherwise , it is a verb and passes 3 and 4 are repeated to attach subjects and objects . Finally , SEXTANT collapses the nn , nnprep and adj relations together into a single broad noun-modifier grammatical relation . Grefenstette ( 1994 ) claims this extractor has a grammatical relation accuracy of 75 % after manually checking 60 sentences . 7 Approach Our approach uses voting across the known supersenses of automatically extracted synonyms , to select a supersense for the unknown nouns . This technique is similar to Hearst and Schutze ( 1993 ) and Widdows ( 2003 ) . However , sometimes the unknown noun does not appear in our 2 billion word corpus , or at least does not appear frequently enough to provide sufficient contextual information to extract reliable synonyms . In these cases , our SUFFIX EXAMPLE SUPERSENSE fall-back method is a simple hand-coded classifier which examines the unknown noun and makes a guess based on simple morphological analysis of the suffix . These rules were created by inspecting the suffixes of rare nouns in WORDNET 1.6 . The supersense guessing rules are given in Table 5 . If none of the rules match , then the default supersense artifact is assigned . The problem now becomes how to convert the ranked list of extracted synonyms for each unknown noun into a single supersense selection . Each extracted synonym votes for its one or more supersenses that appear in WORDNET 1.6 . There are many parameters to consider : The experiments described below consider a range of options for these parameters . In fact , these experiments are so quick to run we have been able to exhaustively test many combinations of these parameters . We have experimented with up to 200 voting extracted synonyms . There are several ways to weight each synonyms contribution . The simplest approach would be to give each synonym the same weight . Another approach is to use the scores returned by the similarity system . Alternatively , the weights can use the ranking of the extracted synonyms . Again these options have been considered below . A related question is whether to use all of the extracted synonyms , or perhaps filter out synonyms for which a small amount of contextual information has been extracted , and so might be unreliable . The final issue is how to deal with polysemy . Does every supersense of each extracted synonym get the whole weight of that synonym or is it distributed evenly between the supersenses like Resnik ( 1995 ) ? Another alternative is to only consider unambiguous synonyms with a single supersense in WORDNET . A disadvantage of this similarity approach is that it requires full synonym extraction , which compares the unknown word against a large number of words when , in fact , we want to calculate the similarity to a small number of supersenses . This inefficiency could be reduced significantly if we consider only very high frequency words , but even this is still expensive . 8 Results We have used the WORDNET 1.6 test set to experiment with different parameter settings and have kept the WORDNET 1.7.1 test set as a final comparison of best results with Ciaramita and Johnson ( 2003 ) . The experiments were performed by considering all possible configurations of the parameters described above . The following voting options were considered for each supersense of each extracted synonym : the initial voting weight for a supersense could either be a constant ( IDENTITY ) or the similarity score ( SCORE ) of the synonym . The initial weight could then be divided by the number of supersenses to share out the weight ( SHARED ) . The weight could also be divided by the rank ( RANK ) to penalise supersenses further down the list . The best performance on the 1.6 test set was achieved with the SCORE voting , without sharing or ranking penalties . The extracted synonyms are filtered before contributing to the vote with their supersense ( s ) . This filtering involves checking that the synonyms frequency and number of contexts are large enough to ensure it is reliable . We have experimented with a wide range of cutoffs and the best performance on the 1.6 test set was achieved using a minimum cutoff of 5 for the synonyms frequency and the number of contexts it appears in . The next question is how many synonyms are considered . We considered using just the nearest unambiguous synonym , and the top 5 , 10 , 20 , 50 , 100 and 200 synonyms . All of the top performing configurations used 50 synonyms . We have also experimented with filtering out highly polysemous nouns by eliminating words with two , three or more synonyms . However , such a filter turned out to make little difference . Finally , we need to decide when to use the similarity measure and when to fall-back to the guessing rules . This is determined by looking at the frequency and number of attributes for the unknown word . Not surprisingly , the similarity system works better than the guessing rules if it has any information at all . The results are summarised in Table 6 . The accuracy of the best-performing configurations was 68 % on the WORDNET 1.6 test set with several other parameter combinations described above performing nearly as well . On the previously unused WORDNET 1.7.1 test set , our accuracy is 63 % using the best system on the WORDNET 1.6 test set . By optimising the parameters on the 1.7.1 test set we can increase that to 64 % , indicating that we have not excessively over-tuned on the 1.6 test set . Our results significantly outperform Ciaramita and Johnson ( 2003 ) on both test sets even though our system is unsupervised . The large difference between our 1.6 and 1.7.1 test set accuracy demonstrates that the 1.7.1 set is much harder . Table 7 shows the breakdown in performance for each supersense . The columns show the number of instances of each supersense with the precision , recall and f-score measures as percentages . The most frequent supersenses in both test sets were person , attribute and act . Of the frequent categories , person is the easiest supersense to get correct in both the 1.6 and 1.7.1 test sets , followed by food , artifact and substance . This is not surprising since these concrete words tend to have very fewer other senses , well constrained contexts and a relatively high frequency . These factors are conducive for extracting reliable synonyms . These results also support Ciaramita and Johnsons view that abstract concepts like communication , cognition and state are much harder . We would expect the location supersense to perform well since it is quite concrete , but unfortunately our synonym extraction system does not incorporate proper nouns , so many of these words were classified using the hand-built classifier . Also , in the data from Ciaramita and Johnson all of the words are in lower case , so no sensible guessing rules could help . 9 Other Alternatives and Future Work An alternative approach worth exploring is to create context vectors for the supersense categories themselves and compare these against the words . This has the advantage of producing a much smaller number of vectors to compare against . In the current system , we must compare a word against the entire vocabulary ( over 500 000 headwords ) , which is much less efficient than a comparison against only 26 supersense context vectors . The question now becomes how to construct vectors of supersenses . The most obvious solution is to sum the context vectors across the words which have each supersense . However , our early experiments suggest that this produces extremely large vectors which do not match well against the much smaller vectors of each unseen word . Also , the same questions arise in the construction of these vectors . How are words with multiple supersenses handled ? Our preliminary experiments suggest that only combining the vectors for unambiguous words produces the best results . One solution would be to take the intersection between vectors across words for each supersense ( i.e. to find the common contexts that these words appear in ) . However , given the sparseness of the data this may not leave very large context vectors . A final solution would be to consider a large set of the canonical attributes ( Curran and Moens , 2002a ) to represent each supersense . Canonical attributes summarise the key contexts for each headword and are used to improve the efficiency of the similarity comparisons . There are a number of problems our system does not currently handle . Firstly , we do not include proper names in our similarity system which means that location entities can be very difficult to identify correctly ( as the results demonstrate ) . Further , our similarity system does not currently incorporate multi-word terms . We overcome this by using the synonyms of the last word in the multi-word term . However , there are 174 multi-word terms ( 23 % ) in the WORDNET 1.7.1 test set which we could probably tag more accurately with synonyms for the whole multi-word term . Finally , we plan to implement a supervised machine learner to replace the fallback method , which currently has an accuracy of 37 % on the WORDNET 1.7.1 test set . We intend to extend our experiments beyond the Ciaramita and Johnson ( 2003 ) set to include previous and more recent versions of WORDNET to compare their difficulty , and also perform experiments over a range of corpus sizes to determine the impact of corpus size on the quality of results . We would like to move onto the more difficult task of insertion into the hierarchy itself and compare against the initial work by Widdows ( 2003 ) using latent semantic analysis . Here the issue of how to combine vectors is even more interesting since there is the additional structure of the WORDNET inheritance hierarchy and the small synonym sets that can be used for more fine-grained combination of vectors . 10 Conclusion Our application of semantic similarity to supersense tagging follows earlier work by Hearst and Schutze ( 1993 ) and Widdows ( 2003 ) . To classify a previously unseen common noun our approach extracts synonyms which vote using their supersenses in WORDNET 1.6 . We have experimented with several parameters finding that the best configuration uses 50 extracted synonyms , filtered by frequency and number of contexts to increase their reliability . Each synonym votes for each of its supersenses from WORDNET 1.6 using the similarity score from our synonym extractor . Using this approach we have significantly outperformed the supervised multi-class perceptron Ciaramita and Johnson ( 2003 ) . This paper also demonstrates the use of a very efficient shallow NLP pipeline to process a massive corpus . Such a corpus is needed to acquire reliable contextual information for the often very rare nouns we are attempting to supersense tag . This application of semantic similarity demonstrates that an unsupervised methods can outperform supervised methods for some NLP tasks if enough data is available . "}
  },
    {
    "id": "P05-1008",
    "result":     [
            {
        "value":         {
          "start": 4156,
          "end": 4179,
          "text": "language variation model",
          "labels": ["Method"]
        },
        "id": 318
      },
            {
        "value":         {
          "start": 13027,
          "end": 13049,
          "text": "decision-counting model",
          "labels": ["Method"]
        },
        "id": 319
      },
            {
        "value":         {
          "start": 15428,
          "end": 15429,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 15651,
          "end": 15656,
          "text": "F test",
          "labels": ["Metric"]
        },
        "id": 322
      },
            {
        "value":         {
          "start": 16714,
          "end": 16715,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 16769,
          "end": 16774,
          "text": "F test",
          "labels": ["Metric"]
        },
        "id": 322
      },
            {
        "value":         {
          "start": 17785,
          "end": 17801,
          "text": "best-first search",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 20218,
          "end": 20219,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 20910,
          "end": 20911,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 21642,
          "end": 21643,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 22058,
          "end": 22059,
          "text": "R2",
          "labels": ["Metric"]
        },
        "id": 323
      }
    ],
    "data": {"text": "Empirically-based Control of Natural Language Generation Abstract In this paper we present a new approach to controlling the behaviour of a natural language generation system by correlating internal decisions taken during free generation of a wide range of texts with the surface stylistic characteristics of the resulting outputs , and using the correlation to control the generator . This contrasts with the generate-andtest architecture adopted by most previous empirically-based generation approaches , offering a more efficient , generic and holistic method of generator control . We illustrate the approach by describing a system in which stylistic variation ( in the sense of Biber ( 1988 ) ) can be effectively controlled during the generation of short medical information texts . 1 Introduction This paper1 is concerned with the problem of controlling the output of natural language generation ( NLG ) systems . In many application scenarios the generators task is underspecified , resulting in multiple possible solutions ( texts expressing the desired content ) , all equally good to the generator , but not equally appropriate for the application . Customising the generator directly to overcome this generally leads to ad-hoc , non-reusable solutions . A more modular approach is a generate-andtest architecture , in which all solutions are generated , and then ranked or otherwise selected according to their appropriateness in a separate post1 Paiva and Evans ( 2004 ) provides an overview of our framework and detailed comparison with previous approaches to stylistic control ( like Hovy ( 1988 ) , Green and DiMarco ( 1993 ) and Langkilde-Geary ( 2002 ) ) . This paper provides a more detailed account of the system and reports additional experimental results . process . Such architectures have been particularly prominent in the recent development of empirically-based approaches to NLG , where generator outputs can be selected according to application requirements acquired directly from human subjects ( e.g. Walker et al. ( 2002 ) ) or statistically from a corpus ( e.g. Langkilde-Geary ( 2002 ) ) . However , this approach suffers from a number of drawbacks : In this paper we present an empirically-based method for controlling a generator which overcomes these deficiencies . It controls the generator internally , so that it can produce just one ( locally ) optimal solution ; it employs a model of language variation , so that the generator can be controlled within a multidimensional space of possible variants ; its view of the generator is completely holistic , so that it can accommodate any other control mechanisms intrinsic to the generation task . To illustrate our approach we describe a system for controlling style in the sense of Biber ( 1988 ) during the generation of short texts giving instructions about doses of medicine . The paper continues as follows . In 2 we describe our overall approach . We then present the implemented system ( 3 ) and report on our experimental evaluation ( 4 ) . We end with a discussion of conclusions and future directions ( 5 ) . 2 Overview of the Approach Our overall approach has two phases : ( 1 ) offline calculation of the control parameters , and ( 2 ) online application to generation . In the first phase we determine a set of correlation equations , which capture the relationship between surface linguistic features of generated texts and the internal generator decisions that gave rise to those texts ( see figure 1 ) . In the second phase , these correlations are used to guide the generator to produce texts with particular surface feature characteristics ( see figure 2 ) . The starting point is a corpus of texts which represents all the variability that we wish to capture . Counts for ( surface ) linguistic features from the texts in the corpus are obtained , and a factor analysis is used to establish dimensions of variation in terms of these counts : each dimension is defined by a weighted sum of scores for particular features , and factor analysis determines the combination that best accounts for the variability across the whole corpus . This provides a language variation model which can be used to score a new text along each of the identified dimensions , that is , to locate the text in the variation space determined by the corpus . The next step is to take a generator which can generate across the range of variation in the corpus , and identify within it the key choice points ( CP1 , CP2 , ... CPn ) in its generation of a text . We then allow the generator to freely generate all possible texts from one or more inputs . For each text so generated we record ( a ) the texts score according to the variation model and ( b ) the set of decisions made at each of the selected choice points in the generator . Finally , for a random sample of the generated texts , a statistical correlation analysis is undertaken between the scores and the corresponding generator decisions , resulting in correlation equations which predict likely variation scores from generator decisions . In the second phase , the generator is adapted to use the correlation equations to conduct a best-first search of the generation space . As well as the usual input , the generator is supplied with target scores for each dimension of variation . At each choice point , the correlation equations are used to predict which choice is most likely to move closer to the target score for the final text . This basic architecture makes no commitment to what is meant by variation , linguistic features , generator choice points , or even NLG system . The key ideas are that a statistical analysis of surface features of a corpus of texts can be used to define a model of variation ; this model can then be used to control a generator ; and the model can also be used to evaluate the generators performance . In the next section we describe a concrete instantiation of this architecture , in which variation is stylistic variation as characterised by a collection of shallow lexical and syntactic features . 3 An Implemented System In order to evaluate the effectiveness of this general approach , we implemented a system which attempts to control style of text generated as de fined by Biber ( 1988 ) in short text ( typically 2-3 sentences ) describing medicine dosage instructions . 3.1 Factor Analysis Biber characterised style in terms of very shallow linguistic features , such as presence of pronouns , auxiliaries , passives etc. . By using factor analysis techniques he was able to determine complex correlations between the occurrence and nonoccurrence of such features in text , which he used to characterise different styles of text .2 We adopted the same basic methodology , applied to a smaller more consistent corpus of just over 300 texts taken from proprietary patient information leaflets . Starting with around 70 surface linguistic features as variables , our factor analysis yielded two main factors ( each containing linguistic features grouped in positive and negative correlated subgroups ) which we used as our dimensions of variation . We interpreted these dimensions as follows ( this is a subjective process factor analysis does not itself provide any interpretation of factors ) : dimension 1 ranges from texts that try to involve the reader ( high positive score ) to text that try to be distant from the reader ( high negative score ) ; dimension 2 ranges from texts with more pronominal reference and a higher proportion of certain verbal forms ( high positive score ) to text that use full nominal reference ( high negative score ) .3 3.2 Generator Architecture The generator was constructed from a mixture of existing components and new implementation , using a fairly standard overall architecture as shown in figure 3 . Here , dotted lines show the control flow and the straight lines show data flow the choice point annotations are described below . The input constructor takes an input specification and , using a background database of medicine information , creates a network of concepts and re2 Some authors ( e.g. Lee ( 1999 ) ) have criticised Biber for making assumptions about the validity and generalisability of his approach to English language as a whole . Here , however , we use his methodology to characterise whatever variation exists without needing to make any broader claims . Each network is then split into subnetworks by the split network module . This partitions the network by locating proposition objects ( marked with a double-lined box in figure 4 ) which have no parent and tracing the subnetwork reachable from each one . We call these subnetworks propnets . In figure 4 , there are two propnets , rooted in [ 1 : take ] and [ 9 : state ] proposition [ 15 : state ] is not a root as it can be reached from [ 1 : take ] . A list of all possible groupings of these propnets is obtained4 , and one of the possible combinations is passed to the network ordering module . This is the first source of non-determinism in our system , marked as choice point one in figure 3 . A combination of subnetworks will be material for the realisation of one paragraph and each subnetwork will be realised as one sentence . 4 For instance , with three propnets ( A , B and C ) the list of combinations would be [ ( A , B , C ) , ( A , BC ) , ( AB , C ) , ( AC , B ) , ( ABC ) ] . The network ordering module receives a combination of subnetworks and orders them based on the number of common elements between each subnetwork . The strategy is to try to maximise the possibility of having a smooth transition from one sentence to the next in accordance with Centering Theory ( Grosz et al. , 1995 ) , and so increase the possibility of having a pronoun generated . The referring expression module receives one subnetwork at a time and decides , for each object that is of type [ thing ] , which type of referring expression will be generated . The module is re-used from the Riches system ( Cahill et al. , 2001 ) and it generates either a definite description or a pronoun . This is the second source of non-determinism in our system , marked as choice point two in figure 3 . Referring expression decisions are recorded by introducing additional nodes into the network , as shown for example in figure 5 ( a fragment of the network in figure 4 , with the additional nodes ) . NP pruning is responsible for erasing from a referring expression subnetwork all the nodes that can be transitively reached from a node marked to be pronominalised . This prevents the realiser from trying to express the information twice . In figure 5 , [ 7 : dose ] is marked to be pronominalised , so the concepts [ 11 : of ] and [ 3 : medicine ] do not need to be realised , so they are pruned . 5 Although some of the labels in this figure look like words , they bear no direct relation to words in the surface text for example , of may be realised as a genitive construction or a possessive . The realiser is a re-implementation of Nicolovs ( 1999 ) generator , extended to use the widecoverage lexicalised grammar developed in the LEXSYS project ( Carroll et al. , 2000 ) , with further semantic extensions for the present system . It selects grammar rules by matching their semantic patterns to subnetworks of the input , and tries to generate a sentence consuming the whole input . In general there are several rules linking each piece of semantics to its possible realisation , so this is our third , and most prolific , source of non-determinism in the architecture , marked as choice point three in figure 3 . A few examples of outputs for the input represented in figure 4 are : the dose of the patient 's medicine is taken twice a day . it is two grams . the two-gram dose of the patient 's medicine is taken twice a day . the patient takes the two-gram dose of the patient 's medicine twice a day . From a typical input corresponding to 2-3 sentences , this generator will generate over a 1000 different texts . 3.3 Tracing Generator Behaviour In order to control the generators behaviour we first allow it to run freely , recording a trace of the decisions it makes at each choice point during the production of each text . Although there are only three choice points in figure 3 , the control structure included two loops : an outer loop which ranges over the sequence of propnets , generating a sentence for each one , and an inner loop which ranges over subnetworks of a propnet as realisation rules are chosen . So the decision structure for even a small text may be quite complex . In the experiments reported here , the trace of the generation process is simply a record of the number of times each decision ( choice point , and what choice was made ) occurred . Paiva ( 2004 ) discusses more complex tracing models , where the context of each decision ( for example , what the preceding decision was ) is recorded and used in the correlation . However the best results were obtained using just the simple decision-counting model ( perhaps in part due to data sparseness for more complex models ) . 3.4 Correlating Decisions with Text Features By allowing the generator to freely generate all possible output from a single input , we recorded a set of < trace , text > pairs ranging across the full variation space . From these pairs we derived corresponding < decision-count , factor-score > pairs , to which we applied a very simple correlational technique , multivariate linear regression analysis , which is used to find an estimator function for a linear relationship ( i.e. , one that can be approximated by a straight line ) from the data available for several variables ( Weisberg , 1985 ) . In our case we want to predict the value for a score in a stylistic dimension ( SSi ) based on a configuration of generator decisions ( GDj ) as seen in equation 1 . We used three randomly sampled data sets of 1400 , 1400 and 5000 observations obtained from a potential base of about 1,400,000 different texts that could be produced by our generator from a single input . With each sample , we obtained a regression equation for each stylistic dimension separately . In the next subsections we will present the final results for each of the dimensions separately . Regression on Stylistic Dimension 1 For the regression model on the first stylistic dimension ( SS1 ) , the generator decisions that were used in the regression analysis7 are : imperative with one object sentences ( IMP _ VNP ) , V _ NP _ PP agentless passive sentences ( PAS _ VNPP ) , V _ NP bypassives ( BYPAS _ VN ) , and N _ PP clauses ( NPP ) and these are all decisions that happen in the realiser , i.e. , at the third choice point in the architecture . This resulted in the regression equation shown in equation 2 . 6 SSi represents a stylistic score and is the dependent variable or criterion in the regression analysis ; the GDjs represent generator decisions and are called the independent variables or predictors ; the xjs are weights , and c is the error . 7 The process of determining the regression takes care of eliminating the variables ( i.e. generator decisions ) that are not useful to estimate the stylistic dimensions . The coefficients for the regression on SS1 are unstandardised coefficients , i.e. the ones that are used when dealing with raw counts for the generator decisions . The coefficient of determination ( R2 ) , which measures the proportion of the variance of the dependent variable about its mean that is explained by the independent variables , had a reasonably high value ( .895 ) 9 and the analysis of variance obtained an F test of 1701.495 . One of the assumptions that this technique assumes is the linearity of the relation between the dependent and the independent variables ( i.e. , in our case , between the stylistic scores in a dimension and the generator decisions ) . The analysis of the residuals resulted in a graph that had some problems but that resembled a normal graph ( see ( Paiva , 2004 ) for more details ) . Regression on Stylistic Dimension 2 For the regression model on the second stylistic dimension ( SS2 ) the variables that we used were : the number of times a network was split ( SPLITNET ) , generation of a pronoun ( RE _ PRON ) , auxiliary verb ( VAUX ) , noun with determiner ( NOUN ) , transitive verb ( VNP ) , and agentless passive ( PAS _ VNP ) the first type of decision happens in the split network module ( our first choice point ) ; the second , in the referring expression module ( second choice point ) ; and the rest in the realiser ( third choice point ) . The main results for this model are as follows : the coefficient of determination ( R2 ) was .959 and the analysis of variance obtained an F test of 2298.519 . The unstandardised regression coefficients for this model can be seen in eq . 3 . With this second model we did not find any problems with the linearity assumptions as the analysis of the residuals gave a normal graph . 4 Controlling the Generator These regression equations characterise the way in which generator decisions influence the final style of the text ( as measured by the stylistic factors ) . In order to control the generator , the user specifies a target stylistic score for each dimension of the text to be generated . At each choice point during generation , all possible decisions are collected in a list and the regression equations are used to order them . The equations allow us to estimate the subsequent values of SS1 and SS2 for each of the possible decisions , and the decisions are ordered according to the distance of the resulting scores from the target scores the closer the score , the better the decision . Hence the search algorithm that we are using here is the best-first search , i.e . , the best local solution according to an evaluation function ( which in this case is the Euclidian distance from the target and the resulted value obtained by using the regression equation ) is tried first but all the other local solutions are kept in order so backtracking is possible . In this paper we report on tests of two internal aspects of the system11 . First we wish to know how good the generator is at hitting a user-specified target i.e. , how close are the scores given by the regression equations for the first text generated to the users input target scores . Second , we wish to know how good the regression equation scores are at modelling the original stylistic factors i.e. , we want to compare the regression scores of an output text with the factor analysis scores . We address these questions across the whole of the twodimensional stylistic space , by specifying a rectangular grid of scores spanning the whole space , and asking the generator to produce texts for each grid point from the same semantic input specification . In this case we divided the scoring space with an 8 by 10 grid pattern as shown in figure 6.12 Each point specifies the target scores for each text that should be generated ( the number next to each point is an identifier of each text ) . For instance , text number 1 was targeted at coordinate ( 7 , 44 ) , whereas text number 79 was targeted at coordinate ( +7 , 28 ) . 4.1 Comparing Target Points and Regression Scores In the first part of this experiment we wanted to know how close to the user-specified target coordinates the resulting regression scores of the first generated text were . This can be done in two different ways . The first is to plot the resulting regression scores ( see figure 7 ) and visually check if it mirrors the grid-shape pattern of the target points ( figure 6 ) this can be done by inspecting the text identifiers13 . This can be a bit misleading because there will always be variation around the target point that was supposed to be achieved ( i.e. , there is a margin for error ) and this can blur the comparison unfavourably . A more formal comparison can be made by plotting the target points versus the regression results for each dimension separately and obtaining a correlation measure between these values . These correlations are shown in figure 8 for SS1 ( left ) and SS2 ( right ) . The degree of correlation ( R2 ) between the values of target and regression points is 0.9574 for SS1 and 0.942 for SS2 , which means that the search mechanism is working very satisfactorily on both dimensions .14 4.2 Comparing Target Points and Stylistic Scores In the second part of this experiment we wanted to know whether the regression equations were doing the job they were supposed to do by comparing the regression scores with stylistic scores obtained ( from the factor analysis ) for each of the generated texts . In figure 9 we plotted the texts in a graph in accordance with their stylistic scores ( once again , some texts occupy the same point so they do not appear ) . 14 All the correlational figures ( R2 ) presented for this experiment are significant at the 0.01 level ( twotailed ) . In the ideal situation , the generator would have produced texts with the perfect regression scores and they would be identical to the stylistic scores , so the graph in the figure 9 would be like a gridshape one as in figure 6 . However we have already seen in figure 7 , that this is not the case for the relation between the target coordinates and the regression scores . So we did not expect the plot of stylistic scores 1 ( SS1 ) against stylistic scores 2 ( SS2 ) to be a perfect grid . Figure 10 ( left-hand side ) shows the relation between the target points and the scores obtained from the original factor equation of SS1 . The value of R2 , which represents their correlation , is high ( 0.9458 ) , considering that this represents the possible accumulation of errors of two stages : from the target to the regression scores , and then from the regression to the actual factor scores . On the right of figure 10 we can see the plotting of the target points and their respective factor scores on SS2 . The correlation obtained is also reasonably high ( R2 = 0.9109 ) . 5 Discussion and Future Work These results demonstrate that it is possible to provide effective control of a generator correlating internal generator behaviour with characteristics of the resulting texts . It is important to note that these two sets of variables ( generator decision and surface features ) are in principle quite independent of each other . Although in some cases there are strong correlations ( for example , the generators use of a passive rule , correlates with the occurrence of passive participles in the text ) , in others the relationship is much less direct ( for example , the choice of how many subnetworks to split a network into , i.e. , SPLITNET , does not correspond to any feature in the factor analysis ) , and the way individual features combine into significant factors may be quite different . Another feature of our approach is that we do not assume some pre-defined notion of parameters of variation variation is characterised completely by a corpus ( in contrast to approaches which use a corpus to characterise a single style ) . The disadvantage of this is that variation is not grounded in some intuitive notion of style : the interpretation of the stylistic dimensions is subjective and tentative . However , as no comprehensive computationally realisable theory of style yet exists , we believe that this approach has considerable promise for practical , empirically-based stylistic control . The results reported here also make us think that a possible avenue for future work is to explore the issue of what types of problems the generalisation induced by our framework ( which will be discussed below ) can be applied to . This paper dealt with an application to stylistic variation but , in theory , the approach can be applied to any kind of process to which there is a sorting function that can impose an order , using a measurable scale ( e.g. , ranking ) , onto the outputs of another process . Schematically the approach can be abstracted to any sort of problem of the form shown in figure 11 . Here there is a producer process outputting a large number of solutions . There is also a sorter process which will classify those solutions in a certain order . The numerical value associated with the output by the sorter can be correlated with the decisions the producer took to generate the output . The same correlation and control mechanism used in this paper can be introduced in the producer process , making it controllable with respect to the sorting dimension . "}
  },
    {
    "id": "P06-1010",
    "result":     [
            {
        "value":         {
          "start": 3836,
          "end": 3857,
          "text": "maximum-entropy models",
          "labels": ["Method"]
        },
        "id": 323
      },
            {
        "value":         {
          "start": 5369,
          "end": 5386,
          "text": "Xinhua News agency",
          "labels": ["Dataset"]
        },
        "id": 324
      },
            {
        "value":         {
          "start": 5699,
          "end": 5727,
          "text": "SNoW machine learning toolkit",
          "labels": ["Tool"]
        },
        "id": 325
      },
            {
        "value":         {
          "start": 6400,
          "end": 6407,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 7823,
          "end": 7842,
          "text": "source-channel model",
          "labels": ["Method"]
        },
        "id": 326
      },
            {
        "value":         {
          "start": 8809,
          "end": 8837,
          "text": "Festival text-tospeech system",
          "labels": ["Tool"]
        },
        "id": 327
      },
            {
        "value":         {
          "start": 11300,
          "end": 11330,
          "text": "Pearson correlation coefficient",
          "labels": ["Method"]
        },
        "id": 331
      },
            {
        "value":         {
          "start": 11427,
          "end": 11432,
          "text": "cosine",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 11469,
          "end": 11493,
          "text": "Jensen-Shannon divergence",
          "labels": ["Method"]
        },
        "id": 334
      },
            {
        "value":         {
          "start": 11541,
          "end": 11571,
          "text": "Pearson correlation coefficient",
          "labels": ["Method"]
        },
        "id": 331
      },
            {
        "value":         {
          "start": 14064,
          "end": 14072,
          "text": "CO method",
          "labels": ["Method"]
        },
        "id": 343
      },
            {
        "value":         {
          "start": 14263,
          "end": 14270,
          "text": "PageRank",
          "labels": ["Method"]
        },
        "id": 332
      },
            {
        "value":         {
          "start": 14564,
          "end": 14571,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15344,
          "end": 15351,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17655,
          "end": 17660,
          "text": "Cosine",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 17664,
          "end": 17682,
          "text": "Pearson coefficient",
          "labels": ["Method"]
        },
        "id": 333
      },
            {
        "value":         {
          "start": 17690,
          "end": 17714,
          "text": "Jensen-Shannon divergence",
          "labels": ["Method"]
        },
        "id": 334
      },
            {
        "value":         {
          "start": 17918,
          "end": 17936,
          "text": "Pearson correlation",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 18240,
          "end": 18258,
          "text": "Pearson correlation",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 18304,
          "end": 18309,
          "text": "Cosine",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 18334,
          "end": 18346,
          "text": "JS-divergence",
          "labels": ["Method"]
        },
        "id": 335
      },
            {
        "value":         {
          "start": 18368,
          "end": 18397,
          "text": "phonetic correspondence method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 18424,
          "end": 18451,
          "text": "frequency correlation method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 18987,
          "end": 19000,
          "text": "phonetic model",
          "labels": ["Method"]
        },
        "id": 338
      },
            {
        "value":         {
          "start": 19067,
          "end": 19094,
          "text": "frequency correlation method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 19889,
          "end": 19917,
          "text": "phonetic correspondence model",
          "labels": ["Method"]
        },
        "id": 339
      },
            {
        "value":         {
          "start": 19995,
          "end": 20022,
          "text": "frequency correlation method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 20061,
          "end": 20090,
          "text": "phonetic correspondence method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 20280,
          "end": 20309,
          "text": "phonetic correspondence method",
          "labels": ["Method"]
        },
        "id": 340
      },
            {
        "value":         {
          "start": 22857,
          "end": 22858,
          "text": "CO",
          "labels": ["Method"]
        },
        "id": 342
      },
            {
        "value":         {
          "start": 22864,
          "end": 22865,
          "text": "MI",
          "labels": ["Method"]
        },
        "id": 341
      },
            {
        "value":         {
          "start": 22997,
          "end": 22998,
          "text": "CO",
          "labels": ["Method"]
        },
        "id": 342
      },
            {
        "value":         {
          "start": 23030,
          "end": 23040,
          "text": "MI approach",
          "labels": ["Method"]
        },
        "id": 342
      },
            {
        "value":         {
          "start": 23861,
          "end": 23869,
          "text": "CO method",
          "labels": ["Method"]
        },
        "id": 343
      },
            {
        "value":         {
          "start": 23904,
          "end": 23912,
          "text": "MI method",
          "labels": ["Method"]
        },
        "id": 343
      }
    ],
    "data": {"text": "Named Entity Transliteration with Comparable Corpora Abstract In this paper we investigate ChineseEnglish name transliteration using comparable corpora , corpora where texts in the two languages deal in some of the same topics and therefore share references to named entities but are not translations of each other . We present two distinct methods for transliteration , one approach using phonetic transliteration , and the second using the temporal distribution of candidate pairs . Each of these approaches works quite well , but by combining the approaches one can achieve even better results . We then propose a novel score propagation method that utilizes the co-occurrence of transliteration pairs within document pairs . This propagation method achieves further improvement over the best results from the previous step . 1 Introduction As part of a more general project on multilingual named entity identification , we are interested in the problem of name transliteration across languages that use different scripts . One particular issue is the discovery of named entities in comparable texts in multiple languages , where by comparable we mean texts that are about the same topic , but are not in general translations of each other . For example , if one were to go through an English , Chinese and Arabic newspaper on the same day , it is likely that the more important international events in various topics such as politics , business , science and sports , would each be covered in each of the newspapers . Names of the same persons , locations and so forth which are often transliterated rather than translated would be found in comparable stories across the three papers .1 We wish to use this expectation to leverage transliteration , and thus the identification of named entities across languages . Our idea is that the occurrence of a cluster of names in , say , an English text , should be useful if we find a cluster of what looks like the same names in a Chinese or Arabic text . An example of what we are referring to can be found in Figure 1 . These are fragments of two stories from the June 8 , 2001 Xinhua English and Chinese newswires , each covering an international womens badminton championship . Though these two stories are from the same newswire source , and cover the same event , they are not translations of each other . Still , not surprisingly , a lot of the names that occur in one , also occur in the other . Thus ( Camilla ) Martin shows up in the Chinese version asAi ' 1 : ma-er-ting ; Judith Meulendijks is T - V fL ' A A JW yu mo-lun-di-ke-si ; and Mette Sorensen is ) - fL ' V mai su-lun-sen . Several other correspondences also occur . While some of the transliterations are standard thus Martin is conventionally transliterated asAi ' 1 : ma-erting many of them were clearly more novel , though all of them follow the standard Chinese conventions for transliterating foreign names . These sample documents illustrate an important point : if a document in language L1 has a set of names , and one finds a document in L2 containing a set of names that look as if they could be transliterations of the names in the L1 document , then this should boost ones confidence that the two sets of names are indeed transliterations of each other . We will demonstrate that this intuition is correct . 2 Previous Work In previous work on Chinese named-entity transliteration e.g. ( Meng et al. , 2001 ; Gao et al. , 2004 ) , the problem has been cast as the problem of producing , for a given Chinese name , an English equivalent such as one might need in a machine translation system . For example , for the nameI-A * wei wei-lian-mu-si , one would like to arrive at the English name V ( enus ) Williams . Common approaches include sourcechannel methods , following ( Knight and Graehl , 1998 ) or maximum-entropy models . Comparable corpora have been studied extensively in the literature ( e.g. , ( Fung , 1995 ; Rapp , 1995 ; Tanaka and Iwasaki , 1996 ; Franz et al. , 1998 ; Ballesteros and Croft , 1998 ; Masuichi et al. , 2000 ; Sadat et al. , 2003 ) ) , but transliteration in the context of comparable corpora has not been well addressed . The general idea of exploiting frequency correlations to acquire word translations from comparable corpora has been explored in several previous studies ( e.g. , ( Fung , 1995 ; Rapp , 1995 ; Tanaka and Iwasaki , 1996 ) ) . Recently , a method based on Pearson correlation was proposed to mine word pairs from comparable corpora ( Tao and Zhai , 2005 ) , an idea similar to the method used in ( Kay and Roscheisen , 1993 ) for sentence alignment . In our work , we adopt the method proposed in ( Tao and Zhai , 2005 ) and apply it to the problem of transliteration . We also study several variations of the similarity measures . Mining transliterations from multilingual web pages was studied in ( Zhang and Vines , 2004 ) ; Our work differs from this work in that we use comparable corpora ( in particular , news data ) and leverage the time correlation information naturally available in comparable corpora . 3 Chinese Transliteration with Comparable Corpora We assume that we have comparable corpora , consisting of newspaper articles in English and Chinese from the same day , or almost the same day . In our experiments we use data from the English and Chinese stories from the Xinhua News agency for about 6 months of 2001.2 We assume that we have identified names for persons and locationstwo types that have a strong tendency to be transliterated wholly or mostly phoneticallyin the English text ; in this work we use the named-entity recognizer described in ( Li et al . , 2004 ) , which is based on the SNoW machine learning toolkit ( Carlson et al . , 1999 ) . To perform the transliteration task , we propose the following general three-step approach : The intuition behind the third step is the following . Suppose several high-confidence name transliteration pairs occur in a pair of English and Chinese documents . Intuitively , this would increase our confidence in the other plausible transliteration pairs in the same document pair . We thus propose a score propagation method to allow these high-confidence pairs to propagate some of their scores to other co-occurring transliteration pairs . As we will show later , such a propagation strategy can generally further improve the transliteration accuracy ; in particular , it can further improve the already high performance from combining the two scoring methods . 3.1 Candidate Selection The English named entity candidate selection process was already described above . Candidate Chinese transliterations are generated by consulting a list of characters that are frequently used for transliterating foreign names . As discussed elsewhere ( Sproat et al. , 1996 ) , a subset of a few hundred characters ( out of several thousand ) tends to be used overwhelmingly for transliterating foreign names into Chinese . We use a list of 495 such characters , derived from various online dictionaries . A sequence of three or more characters from the list is taken as a possible name . If the character occurs , which is frequently used to represent the space between parts of an English name , then at least one character to the left and right of this character will be collected , even if the character in question is not in the list of foreign characters . Armed with the English and Chinese candidate lists , we then consider the pairing of every English candidate with every Chinese candidate . Obviously it would be impractical to do this for all of the candidates generated for , say , an entire year : we consider as plausible pairings those candidates that occur within a day of each other in the two corpora . 3.2 Candidate scoring based on pronunciation We adopt a source-channel model for scoring English-Chinese transliteration pairs . In general , we seek to estimate P ( elc ) , where e is a word in Roman script , and c is a word in Chinese script . Since Chinese transliteration is mostly based on pronunciation , we estimate P ( e | c ) , where e is the pronunciation of e and c is the pronunciation of c. Again following standard practice , we decompose the estimate of P ( e | c ) as P ( e | c ) _ Ili P ( ei | ci ) . Here , ei is the ith subsequence of the English phone string , and ci is the ith subsequence of the Chinese phone string . Since Chinese transliteration attempts to match the syllablesized characters to equivalent sounding spans of the English language , we fix the ci to be syllables , and let the ei range over all possible subsequences of the English phone string . For training data we have a small list of 721 names in Roman script and their Chinese equivalent . Pronunciations for English words are obtained using the Festival text-tospeech system ( Taylor et al . , 1998 ) ; for Chinese , we use the standard pinyin transliteration of the characters . English-Chinese pairs in our training dictionary were aligned using the alignment algorithm from ( Kruskal , 1999 ) , and a hand-derived set of 21 rules-of-thumb : for example , we have rules that encode the fact that Chinese / l / can correspond to English / r / , / n / or / er / ; and that Chinese / w / may be used to represent / v / . Given that there are over 400 syllables in Mandarin ( not counting tone ) and each of these syllables can match a large number of potential English phone spans , this is clearly not enough training data to cover all the parameters , and so we use Good-Turing estimation to estimate probabilities for unseen correspondences . Since we would like to filter implausible transliteration pairs we are less lenient than standard estimation techniques in that we are willing to assign zero probability to some correspondences . Thus we set a hard rule that for an English phone span to correspond to a Chinese syllable , the initial phone of the English span must have been seen in the training data as corresponding to the initial of the Chinese syllable some minimum number of times . For consonant-initial syllables we set the minimum to 4 . We omit further details of our estimation technique for lack of space . This phonetic correspondence model can then be used to score putative transliteration pairs . 3.3 Candidate Scoring based on Frequency Correlation Names of the same entity that occur in different languages often have correlated frequency patterns due to common triggers such as a major event . Thus if we have comparable news articles over a sufficiently long time period , it is possible to exploit such correlations to learn the associations of names in different languages . The idea of exploiting frequency correlation has been well studied . ( See the previous work section . ) We adopt the method proposed in ( Tao and Zhai , 2005 ) , which works as follows : We pool all documents in a single day to form a large pseudo-document . Then , for each transliteration candidate ( both Chinese and English ) , we compute its frequency in each of those pseudo-documents and obtain a raw frequency vector . We further normalize the raw frequency vector so that it becomes a frequency distribution over all the time points ( days ) . In order to compute the similarity between two distribution vectors , The Pearson correlation coefficient was used in ( Tao and Zhai , 2005 ) ; here we also considered two other commonly used measures cosine ( Salton and McGill , 1983 ) , and Jensen-Shannon divergence ( Lin , 1991 ) , though our results show that Pearson correlation coefficient performs better than these two other methods . 3.4 Score Propagation In both scoring methods described above , scoring of each candidate transliteration pair is independent of the other . As we have noted , document pairs that contain lots of plausible transliteration pairs should be viewed as more plausible document pairs ; at the same time , in such a situation we should also trust the putative transliteration pairs more . Thus these document pairs and transliteration pairs mutually reinforce each other , and this can be exploited to further optimize our transliteration scores by allowing transliteration pairs to propagate their scores to each other according to their co-occurrence strengths . Formally , suppose the current generation of transliteration scores are ( ei , ci , wi ) i = 1 , ... , n , where ( ei , ci ) is a distinct pair of English and Chinese names . Note that although for any i = 6 j , we have ( ei , ci ) = 6 ( ej , cj ) , it is possible that ei = ej or ci = cj for some i = 6 j. wi is the transliteration score of ( ei , ci ) . These pairs along with their co-occurrence relation computed based on our comparable corpora can be formally represented by a graph as shown in Figure 2 . In such a graph , a node represents ( ei , ci , wi ) . An edge between ( ei , ci , wi ) and ( ej , cj , wj ) is constructed iff ( ei , ci ) and ( ej , cj ) co-occur in a certain document pair ( Et , Ct ) , i.e. there exists a document pair ( Et , Ct ) , such that ei , ej Et and ci , cj Ct. . Given a node ( ei , ci , wi ) , we refer to all its directly-connected nodes as its neighbors . The documents do not appear explicitly in the graph , but they implicitly affect the graphs topology and the weight of each edge . Our idea of score propagation can now be formulated as the following recursive equation for updating the scores of all the transliteration pairs . where w ( k ) i is the new score of the pair ( ei , ci ) after an iteration , while w ( k1 ) is its old score i before updating ; [ 0 , 1 ] is a parameter to control the overall amount of propagation ( when = 1 , no propagation occurs ) ; P ( j | i ) is the conditional probability of propagating a score from node ( ej , cj , wj ) to node ( ei , ci , wi ) . We estimate P ( j | i ) in two different ways : 1 ) The number of cooccurrences in the whole collection ( Denote as CO ) . P ( j | i ) = C ( i , j ) where MI ( i , j ) is the mutual information of ( ei , ci ) and ( ej , cj ) . As we will show , the CO method works better . Note that the transition probabilities between indirect neighbors are always 0 . Thus propagation only happens between direct neighbors . This formulation is very similar to PageRank , a link-based ranking algorithm for Web retrieval ( Brin and Page , 1998 ) . However , our motivation is propagating scores to exploit cooccurrences , so we do not necessarily want the equation to converge . Indeed , our results show that although the initial iterations always help improve accuracy , too many iterations actually would decrease the performance . 4 Evaluation We use a comparable English-Chinese corpus to evaluate our methods for Chinese transliteration . We take one days worth of comparable news articles ( 234 Chinese stories and 322 English stories ) , generate about 600 English names with the entity recognizer ( Li et al. , 2004 ) as described above , and find potential Chinese transliterations also as previously described . We generated 627 Chinese candidates . In principle , all these 600 x 627 pairs are potential transliterations . We then apply the phonetic and time correlation methods to score and rank all the candidate Chinese-English correspondences . To evaluate the proposed transliteration methods quantitatively , we measure the accuracy of the ranked list by Mean Reciprocal Rank ( MRR ) , a measure commonly used in information retrieval when there is precisely one correct answer ( Kantor and Voorhees , 2000 ) . The reciprocal rank is the reciprocal of the rank of the correct answer . For example , if the correct answer is ranked as the first , the reciprocal rank would be 1.0 , whereas if it is ranked the second , it would be 0.5 , and so forth . To evaluate the results for a set of English names , we take the mean of the reciprocal rank of each English name . We attempted to create a complete set of answers for all the English names in our test set , but a small number of English names do not seem to have any standard transliteration according to the resources that we consulted . We ended up with a list of about 490 out of the 600 English names judged . We further notice that some answers ( about 20 % ) are not in our Chinese candidate set . This could be due to two reasons : ( 1 ) The answer does not occur in the Chinese news articles we look at . ( 2 ) The answer is there , but our candidate generation method has missed it . In order to see more clearly how accurate each method is for ranking the candidates , we also compute the MRR for the subset of English names whose transliteration answers are in our candidate list . We distinguish the MRRs computed on these two sets of English names as AllMRR and CoreMRR . Below we first discuss the results of each of the two methods . We then compare the two methods and discuss results from combining the two methods . 4.1 Phonetic Correspondence We show sample results for the phonetic scoring method in Table 1 . This table shows the 10 highest scoring transliterations for each Chinese character sequence based on all texts in the Chinese and English Xinhua newswire for the 13th of August , 2001 . 8 out of these 10 are correct . For all the English names the MRR is 0.3 , and for the hua corpus for 8/13/01 . The final column is the log P estimate for the transliteration . Starred entries are incorrect . core names it is 0.89 . Thus on average , the correct answer , if it is included in our candidate list , is ranked mostly as the first one . 4.2 Frequency correlation We proposed three similarity measures for the frequency correlation method , i.e . , the Cosine , Pearson coefficient , and Jensen-Shannon divergence . In Table 2 , we show their MRRs . Given that the only resource the method needs is comparable text documents over a sufficiently long period , these results are quite encouraging . For example , with Pearson correlation , when the Chinese transliteration of an English name is included in our candidate list , the correct answer is , on average , ranked at the 3rd place or better . The results thus show that the idea of exploiting frequency correlation does work . We also see that among the three similarity measures , Pearson correlation performs the best ; it performs better than Cosine , which is better than JS-divergence . Compared with the phonetic correspondence method , the performance of the frequency correlation method is in general much worse , which is not surprising , given the fact that terms may be correlated merely because they are topically related . Since the two methods exploit complementary resources , it is natural to see if we can improve performance by combining the two methods . Indeed , intuitively the best candidate is the one that has a good pronunciation alignment as well as a correlated frequency distribution with the English name . We evaluated two strategies for combining the two methods . The first strategy is to use the phonetic model to filter out ( clearly impossible ) candidates and then use the frequency correlation method to rank the candidates . The second is to combine the scores of these two methods . Since the correlation coefficient has a maximum value of 1 , we normalize the phonetic correspondence score by dividing all scores by the maximum score so that the maximum normalized value is also 1 . We then take the average of the two scores and rank the candidates based on their average scores . Note that the second strategy implies the application of the first strategy . The results of these two combination strategies are shown in Table 3 along with the results of the two individual methods . We see that both combination strategies are effective and the MRRs of the combined results are all better than those of the two individual methods . It is interesting to see that the benefit of applying the phonetic correspondence model as a filter is quite significant . Indeed , although the performance of the frequency correlation method alone is much worse than that of the phonetic correspondence method , when working on the subset of candidates passing the phonetic filter ( i.e . , those candidates that have a reasonable phonetic alignment with the English name ) , it can outperform the phonetic correspondence method . This once again indicates that exploiting the frequency correlation can be effective . When combining the scores of these two methods , we not only ( implicitly ) apply the phonetic filter , but also exploit the discriminative power provided by the phonetic correspondence scores and this is shown to bring in additional benefit , giving the best performance among all the methods . 4.4 Error Analysis From the results above , we see that the MRRs for the core English names are substantially higher than those for all the English names . This means that our methods perform very well whenever we have the answer in our candidate list , but we have also missed the answers for many English names . The missing of an answer in the candidate list is thus a major source of errors . To further understand the upper bound of our method , we manually add the missing correct answers to our candidate set and apply all the methods to rank this augmented set of candidates . The performance is reported in Table 4 with the corresponding performance on the original candidate set . We see that , as expected , the performance on the augmented candidate list , which can be interpreted as an upper bound of our method , is indeed much better , suggesting that if we can somehow improve the candidate generation method to include the answers in the list , we can expect to significantly improve the performance for all the methods . This is clearly an interesting topic for further research . The relative performance of different methods on this augmented candidate list is roughly the same as on the original candidate list , except that the Freq + PhoneticFilter is slightly worse than that of the phonetic method alone , though it is still much better than the performance of the frequency correlation alone . One possible explanation may be that since these names do not necessarily occur in our comparable corpora , we may not have sufficient frequency observations for some of the names . 4.5 Experiments on score propagation To demonstrate that score propagation can further help transliteration , we use the combination scores in Table 3 as the initial scores , and apply our propagation algorithm to iteratively update them . We remove the entries when they do not co-occur with others . There are 25 such English name candidates . Thus , the initial scores are actually slightly different from the values in Table 3 . We show the new scores and the best propagation scores in Table 5 . In the table , init . refers to the initial scores . and CO and MI stand for best scores obtained using either the co-occurrence or mutual information method . While both methods result in gains , CO very slightly outperforms the MI approach . In the score propagation process , we introduce two additional parameters : the interpolation parameter and the number of iterations k. Figure 3 and Figure 4 show the effects of these parameters . Intuitively , we want to preserve the initial score of a pair , but add a slight boost from its neighbors . Thus , we set very close to 1 ( 0.9 and 0.95 ) , and allow the system to perform 20 iterations . In both figures , the first few iterations certainly leverage the transliteration , demonstrating that the propagation method works . However , we observe that the performance drops when more iterations are used , presumably due to noise introduced from more distantly connected nodes . Thus , a relatively conservative approach is to choose a high value , and run only a few iterations . Note , finally , that the CO method seems to be more stable than the MI method . MRR values 5 Conclusions and Future Work In this paper we have discussed the problem of Chinese-English name transliteration as one component of a system to find matching names in comparable corpora . We have proposed two methods for transliteration , one that is more traditional and based on phonetic correspondences , and one that is based on word distributions and adopts methods from information retrieval . We have shown that both methods yield good results , and that even better results can be achieved by combining the methods . We have further showed that one can improve upon the combined model by using reinforcement via score propagation when transliteration pairs cluster together in document pairs . The work we report is ongoing . We are investigating transliterations among several language pairs , and are extending these methods to Korean , Arabic , Russian and Hindi see ( Tao et al. , 2006 ) . "}
  },
    {
    "id": "P06-1037",
    "result":     [
            {
        "value":         {
          "start": 528,
          "end": 535,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 575,
          "end": 582,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 1238,
          "end": 1281,
          "text": "Lexicalized Tree-Adjoining Grammars ( LTAG )",
          "labels": ["Method"]
        },
        "id": 344
      },
            {
        "value":         {
          "start": 1822,
          "end": 1829,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 3005,
          "end": 3051,
          "text": "Weighted Constraint Dependency Grammar ( WCDG )",
          "labels": ["Method"]
        },
        "id": 352
      },
            {
        "value":         {
          "start": 4470,
          "end": 4477,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 5212,
          "end": 5215,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 8112,
          "end": 8116,
          "text": "NEGRA",
          "labels": ["Dataset"]
        },
        "id": 347
      },
            {
        "value":         {
          "start": 8122,
          "end": 8134,
          "text": "TIGER corpora",
          "labels": ["Dataset"]
        },
        "id": 348
      },
            {
        "value":         {
          "start": 8268,
          "end": 8272,
          "text": "DepSy",
          "labels": ["Tool"]
        },
        "id": 349
      },
            {
        "value":         {
          "start": 8354,
          "end": 8365,
          "text": "NEGRA corpus",
          "labels": ["Dataset"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 8696,
          "end": 8698,
          "text": "TnT",
          "labels": ["Tool"]
        },
        "id": 350
      },
            {
        "value":         {
          "start": 8829,
          "end": 8832,
          "text": "TnTs",
          "labels": ["Tool"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 10605,
          "end": 10612,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 11219,
          "end": 11230,
          "text": "n-gram model",
          "labels": ["Method"]
        },
        "id": 351
      },
            {
        "value":         {
          "start": 11976,
          "end": 11983,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 12095,
          "end": 12102,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 12940,
          "end": 12947,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 13119,
          "end": 13126,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 13229,
          "end": 13236,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 13300,
          "end": 13307,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 13348,
          "end": 13394,
          "text": "Weighted Constraint Dependency Grammar ( WCDG )",
          "labels": ["Method"]
        },
        "id": 352
      },
            {
        "value":         {
          "start": 13975,
          "end": 13978,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 14418,
          "end": 14421,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 14948,
          "end": 14951,
          "text": "WDCG",
          "labels": ["Method"]
        },
        "id": 352
      },
            {
        "value":         {
          "start": 15083,
          "end": 15090,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15246,
          "end": 15253,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17755,
          "end": 17758,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 17856,
          "end": 17867,
          "text": "NEGRA corpus",
          "labels": ["Dataset"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 18002,
          "end": 18009,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18105,
          "end": 18112,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18255,
          "end": 18260,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 18266,
          "end": 18274,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 18293,
          "end": 18300,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18739,
          "end": 18746,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18943,
          "end": 18950,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19285,
          "end": 19292,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19330,
          "end": 19337,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19356,
          "end": 19363,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19657,
          "end": 19664,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19937,
          "end": 19940,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 21537,
          "end": 21540,
          "text": "WCDG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 21608,
          "end": 21611,
          "text": "TnTs",
          "labels": ["Tool"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 21683,
          "end": 21690,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21944,
          "end": 21951,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21983,
          "end": 21990,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22039,
          "end": 22046,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22581,
          "end": 22588,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22647,
          "end": 22655,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23119,
          "end": 23126,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23148,
          "end": 23155,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23631,
          "end": 23634,
          "text": "LTAG",
          "labels": ["Method"]
        },
        "id": 353
      },
            {
        "value":         {
          "start": 23975,
          "end": 23996,
          "text": "Tree-Adjoining Grammar",
          "labels": ["Method"]
        },
        "id": 354
      },
            {
        "value":         {
          "start": 24046,
          "end": 24053,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24080,
          "end": 24087,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24677,
          "end": 24685,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24698,
          "end": 24703,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 25574,
          "end": 25579,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 25693,
          "end": 25700,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 25967,
          "end": 25975,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 26002,
          "end": 26007,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 26470,
          "end": 26477,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 26657,
          "end": 26664,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 26971,
          "end": 26978,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 27391,
          "end": 27398,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 28127,
          "end": 28134,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 28375,
          "end": 28382,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 28457,
          "end": 28464,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 28541,
          "end": 28548,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      }
    ],
    "data": {"text": "Guiding a Constraint Dependency Parser with Supertags Abstract We investigate the utility of supertag information for guiding an existing dependency parser of German . Using weighted constraints to integrate the additionally available information , the decision process of the parser is influenced by changing its preferences , without excluding alternative structural interpretations from being considered . The paper reports on a series of experiments using varying models of supertags that significantly increase the parsing accuracy . In addition , an upper bound on the accuracy that can be achieved with perfect supertags is estimated . 1 Introduction Supertagging is based on the combination of two powerful and influential ideas of natural language processing : On the one hand , parsing is ( at least partially ) reduced to a decision on the optimal sequence of categories , a problem for which efficient and easily trainable procedures exist . On the other hand , supertagging exploits complex categories , i.e. tree fragments which much better reflect the mutual compatibility between neighbouring lexical items than say part-of-speech tags . Bangalore and Joshi ( 1999 ) derived the notion of supertag within the framework of Lexicalized Tree-Adjoining Grammars ( LTAG ) ( Schabes and Joshi , 1991 ) . They considered supertagging a process of almost parsing , since all that needs to be done after having a sufficiently reliable sequence of supertags available is to decide on their combination into a spanning tree for the complete sentence . Thus the approach lends itself easily to preprocessing sentences or filtering parsing results with the goal of guiding the parser or reducing its output ambiguity . Nasr and Rambow ( 2004 ) estimated that perfect supertag information already provides for a parsing accuracy of 98 % if a correct supertag assignment were available . Unfortunately , perfectly reliable supertag information can not be expected ; usually this uncertainty is compensated by running the tagger in multi-tagging mode , expecting that the reliability can be increased by not forcing the tagger to take unreliable decisions but instead offering a set of alternatives from which a subsequent processing component can choose . A grammar formalism which seems particularly well suited to decompose structural descriptions into lexicalized tree fragments is dependency grammar . It allows us to define supertags on different levels of granularity ( White , 2000 ; Wang and Harper , 2002 ) , thus facilitating a fine grained analysis of how the different aspects of supertag information influence the parsing behaviour . In the following we will use this characteristic to study in more detail the utility of different kinds of supertag information for guiding the parsing process . Usually supertags are combined with a parser in a filtering mode , i.e. parsing hypotheses which are not compatible with the supertag predictions are simply discarded . Drawing on the ability of Weighted Constraint Dependency Grammar ( WCDG ) ( Schroder et al . , 2000 ) to deal with defeasible constraints , here we try another option for making available supertag information : Using a score to estimate the general reliability of unique supertag decisions , the information can be combined with evidence derived from other constraints of the grammar in a soft manner . It makes possible to rank parsing hypotheses according to their plausibility and allows the parser to even override potentially wrong supertag decisions . Starting from a range of possible supertag models , Section 2 explores the reliability with which dependency-based supertags can be determined on es mag sein , da die Franzosen kein schlssiges Konzept fr eine echte Partnerschaft besitzen . different levels of granularity . Then , Section 3 describes how supertags are integrated into the existing parser for German . The complex nature of supertags as we define them makes it possible to separate the different structural predictions made by a single supertag into components and study their contributions independently ( c.f. Section 4 ) . We can show that indeed the parser is robust enough to tolerate supertag errors and that even with a fairly low tagger performance it can profit from the additional , though unreliable information . 2 Supertagging German text In defining the nature of supertags for dependency parsing , a trade-off has to be made between expressiveness and accuracy . A simple definition with very small number of supertags will not be able to capture the full variety of syntactic contexts that actually occur , while an overly expressive definition may lead to a tag set that is so large that it can not be accurately learnt from the training data . The local context of a word to be encoded in a supertag could include its edge label , the attachment direction , the occurrence of obligatory1 or of all dependents , whether each predicted dependent occurs to the right or to the left of the word , and the relative order among different dependents . The simplest useful task that could be asked of a supertagger would be to predict the dependency relation that each word enters . In terms of the WCDG formalism , this means associating each word at least with one of the syntactic labels that decorate dependency edges , such as SUBJ or DET ; in other words , the supertag set would be identical to the label set . The example sentence Following ( Wang and Harper , 2002 ) , we further classify dependencies into Left ( L ) , Right ( R ) , and No attachments ( N ) , depending on whether a word is attached to its left or right , or not at all . We combine the label with the attachment direction to obtain composite supertags . The sequence of supertags describing the example sentence would then begin with EXPL/R S/N AUX/L ... Although this kind of supertag describes the role of each word in a sentence , it still does not specify the entire local context ; for instance , it associates the information that a word functions as a subject only with the subject and not with the verb that takes the subject . In other words , it does not predict the relations under a given word . Greater expressivity is reached by also encoding the labels of these relations into the supertag . For instance , the word mag in the example sentence is modified by an expletive ( EXPL ) on its left side and by an auxiliary ( AUX ) and a subject clause ( SUBJC ) dependency on its right side . To capture this extended local context , these labels must be encoded into the supertag . We add the local context of a word to the end of its supertag , separated with the delimiter + . This yields the expression S/N + AUX , EXPL , SUBJC . If we also want to express that the EXPL precedes the word but the AUX follows it , we can instead add two new fields to the left and to the right of the supertag , which leads to the new supertag EXPL+S / N+AUX , SUBJC . Table 1 shows the annotation of the example us ing the most sophisticated supertag model . Note that the notation + EXPL/R + explicitly represents the fact that the word labelled EXPL has no dependents of its own , while the simpler EXPL/R made no assertion of this kind . The extended context specification with two + delimiters expresses the complete set of dependents of a word and whether they occur to its left or right . However , it does not distinguish the order of the left or right dependents among each other ( we order the labels on either side alphabetically for consistency ) . Also , duplicate labels among the dependents on either side are not represented . For instance , a verb with two post-modifying prepositions would still list PP only once in its right context . This ensures that the set of possible supertags is finite . The full set of different supertag models we used is given in Table 2 . Note that the more complicated models G , H , I and J predict all dependents of each word , while the others predict obligatory dependents only , which should be an easier task . To obtain and evaluate supertag predictions , we used the NEGRA and TIGER corpora ( Brants et al . , 1997 ; Brants et al . , 2002 ) , automatically transformed into dependency format with the freely available tool DepSy ( Daum et al . , 2004 ) . As our test set we used sentences 18,60219,601 of the NEGRA corpus , for comparability to earlier work . All other sentences ( 59,622 sentences with 1,032,091 words ) were used as the training set . For each word in the training set , the local context was extracted and expressed in our supertag notation . The word / supertag pairs were then used to train the statistical part-of-speech tagger TnT ( Brants , 2000 ) , which performs trigram tagging efficiently and allows easy retraining on different data . However , a few of TnTs limitations had to be worked around : since it can not deal with words that have more than 510 different possible tags , we systematically replaced the rarest tags in the training set with a generic OTHER tag until the limit was met . Also , in tagging mode it can fail to process sentences with many unknown words in close succession . In such cases , we simply ran it on shorter fragments of the sentence until no error occurred . Fewer than 0.5 % of all sentences were affected by this problem even with the largest tag set . A more serious problem arises when using a stochastic process to assign tags that partially predict structure : the tags emitted by the model may contradict each other . Consider , for instance , the following supertagger output for the previous example sentence : The supertagger correctly predicts that the first three labels are EXPL , S , and AUX . It also predicts that the word sein has a preceding PRED complement , but this is impossible if the two preceding words are labelled EXPL and S . Such contradictory information is not fatal in a robust system , but it is likely to cause unnecessary work for the parser when some rules demand the impossible . We therefore decided simply to ignore context predictions when they contradict the basic label predictions made for the same sentence ; in other words , we pretend that the prediction for the third word was just + AUX/L + rather than PRED+AUX / L + . Up to 13 % of all predictions were simplified in this way for the most complex supertag model . The last columns of Table 2 give the number of different supertags in the training set and the performance of the retrained TnT on the test set in single-tagging mode . Although the number of oc curring tags rises and the prediction accuracy falls with the supertag complexity , the correlation is not absolute : It seems markedly easier to predict supertags with complements but no direction information ( C ) than supertags with direction information but no complements ( B ) , although the tag set is larger by an order of magnitude . In fact , the prediction of attachment direction seems much more difficult than that of undirected supertags in every case , due to the semi-free word order of German . The greater tag set size when predicting complements of each words is at least partly offset by the contextual information available to the n-gram model , since it is much more likely that a word will have , e.g . , a SUBJ complement when an adjacent SUBJ supertag is present . For the simplest model A , all 35 possible supertags actually occur , while in the most complicated model J , only 12,947 different supertags are observed in the training data ( out of a theoretically possible 1024 for a set of 35 edge labels ) . Note that this is still considerably larger than most other reported supertag sets . The prediction quality falls to rather low values with the more complicated models ; however , our goal in this paper is not to optimize the supertagger , but to estimate the effect that an imperfect one has on an existing parser . Altogether most results fall into a range of 7080 % of accuracy ; as we will see later , this is in fact enough to provide a benefit to automatic parsing . Although supertag accuracy is usually determined by simply counting matching and nonmatching predictions , a more accurate measure should take into account how many of the individual predictions that are combined into a supertag are correct or wrong . For instance , a word that is attached to its left as a subject , is preceded by a preposition and an attributive adjective , and followed by an apposition would bear the supertag PP , ATTR+SUBJ / L+APP . Since the prepositional attachment is notoriously difficult to predict , a supertagger might miss it and emit the slightly different tag ATTR+SUBJ / L+APP . Although this supertag is technically wrong , it is in fact much more right than wrong : of the four predictions of label , direction , preceding and following dependents , three are correct and only one is wrong . We therefore define the component accuracy for a given model as the ratio of correct predictions among the possible ones , which results in a value of 0.75 rather than 0 for the example prediction . The component accuracy of the supertag model J e . g . is in fact 84.5 % rather than 67.6 % . We would expect the component accuracy to match the effect on parsing more closely than the supertag accuracy . 3 Using supertag information in WCDG Weighted Constraint Dependency Grammar ( WCDG ) is a formalism in which declarative constraints can be formulated that describe well-formed dependency trees in a particular natural language . A grammar composed of such constraints can be used for parsing by feeding it to a constraint-solving component that searches for structures that satisfy the constraints . Each constraint carries a numeric score or penalty between 0 and 1 that indicates its importance . The penalties of all instances of constraint violations are multiplied to yield a score for an entire analysis ; hence , an analysis that satisfies all rules of the WCDG bears the score 1 , while lower values indicate small or large aberrations from the language norm . A constraint penalty of 0 , then , corresponds to a hard constraint , since every analysis that violates such a constraint will always bear the worst possible score of 0 . This means that of two constraints , the one with the lower penalty is more important to the grammar . Since constraints can be soft as well as hard , parsing in the WCDG formalism amounts to multidimensional optimization . Of two possible analyses of an utterance , the one that satisfies more ( or more important ) constraints is always preferred . All knowledge about grammatical rules is encoded in the constraints that ( together with the lexicon ) constitute the grammar . Adding a constraint which is sensitive to supertag predictions will therefore change the objective function of the optimization problem , hopefully leading to a higher share of correct attachments . Details about the WDCG parser can be found in ( Foth and Menzel , 2006 ) . A grammar of German is available ( Foth et al . , 2004 ) that achieves a good accuracy on written German input . Despite its good results , it seems probable that the information provided by a supertag prediction component could improve the accuracy further . First , because the optimization problem that WCDG defines is infeasible to solve exactly , the parser must usually use incomplete , heuristic algorithms to try to compute the optimal analysis . This means that it sometimes fails to find the correct analysis even if the language model accurately defines it , because of search errors during heuristic optimization . A component that makes specific predictions about local structure could guide the process so that the correct alternative is tried first in more cases , and help prevent such search errors . Second , the existing grammar rules deal mainly with structural compatibility , while supertagging exploits patterns in the sequence of words in its input , i. e. both models contribute complementary information . Moreover , the parser can be expected to profit from supertags providing highly lexicalized pieces of information . To make the information from the supertag sequence available to the parser , we treat the complex supertags as a set of predictions and write constraints to prefer those analyses that satisfy them . The predictions of label and direction made by models A and B are mapped onto two constraints which demand that each word in the analysis should exhibit the predicted label and direction . The more complicated supertag models constrain the local context of each word further . Effectively , they predict that the specified dependents of a word occur , and that no other dependents occur . The former prediction equates to an existence condition , so constraints are added which demand the presence of the predicted relation types under that word ( one for left dependents and one for right dependents ) . The latter prediction disallows all other dependents ; it is implemented by two constraints that test the edge label of each word-to-word attachment against the set of predicted dependents of the regent ( again , separately for left and right dependents ) . Altogether six new constraints are added to the grammar which refer to the output of the supertagger on the current sentence . Note that in contrast to most other approaches we do not perform multi-supertagging ; exactly one supertag is assumed for each word . Alternatives could be integrated by computing the logical disjunctions of the predictions made by each supertag , and then adapting the new constraints accordingly . 4 Experiments We tested the effect of supertag predictions on a full parser by adding the new constraints to the WCDG of German described in ( Foth et al . , 2004 ) and re-parsing the same 1,000 sentences from the NEGRA corpus . The quality of a dependency parser such as this can be measured as the ratio of correctly attached words to all words ( structural accuracy ) or the ratio of the correctly attached and correctly labelled words to all words ( labelled accuracy ) . Note that because the parser always finds exactly one analysis with exactly one subordination per word , there is no distinction between recall and precision . The structural accuracy without any supertags is 89.6 % . To determine the best trade-off between complexity and prediction quality , we tested all 10 supertag models against the baseline case of no supertags at all . The results are given in Table 3 . Two observations can be made about the effect of the supertag model on parsing . Firstly , all types of supertag prediction , even the very basic model A which predicts only edge labels , improve the overall accuracy of parsing , although the baseline is already quite high . Second , the richer models of supertags appear to be more suitable for guiding the parser than the simpler ones , even though their own accuracy is markedly lower ; almost one third of the supertag predictions according to the most compli cated definition J are wrong , but nevertheless their inclusion reduces the remaining error rate of the parser by over 20 % . This result confirms the assumption that if supertags are integrated as individual constraints , their component accuracy is more important than the supertag accuracy . The decreasing accuracy of more complex supertags is more than counterbalanced by the additional information that they contribute to the analysis . Obviously , this trend can not continue indefinitely ; a supertag definition that predicted even larger parts of the dependency tree would certainly lead to much lower accuracy by even the most lenient measure , and a prediction that is mostly wrong must ultimately degrade parsing performance . Since the most complex model J shows no parsing improvement over its successor I , this point might already have been reached . The use of supertags in WCDG is comparable to previous work which integrated POS tagging and chunk parsing . ( Foth and Hagenstrom , 2002 ; Daum et al. , 2003 ) showed that the correct balance between the new knowledge and the existing grammar is crucial for successful integration . This is achieved by means of an additional parameter , modeling how trustworthy supertag predictions are considered . Its effect is shown in Table 4 . As expected , making supertag constraints hard ( with a value of 0.0 ) over-constrains most parsing problems , so that hardly any analyses can be computed . Other values near 0 avoid this problem but still lead to much worse overall performance , as wrong or even impossible predictions too often overrule the normal syntax constraints . The previously used value of 0.9 actually yields the best results with this particular grammar . The fact that a statistical model can improve parsing performance when superimposed on a sophisticated hand-written grammar is of particular interest because the statistical model we used is so simple , and in fact not particularly accurate ; it certainly does not represent the state of the art in supertagging . This gives rise to the hope that as better supertaggers for German become available , parsing results will continue to see additional improvements , i.e. , future supertagging research will directly benefit parsing . The obvious question is how great this benefit might conceivably become under optimal conditions . To obtain this upper limit of the utility of supertags we repeated the process of translating each supertag into additional WCDG constraints , but this time using the test set itself rather than TnTs predictions . Table 5 again gives the unlabelled and labelled parsing accuracy for all 10 different supertag models with the integration strengths of 0 and 0.9 . ( Note that since all our models predict the edge label of each word , hard integration of perfect predictions eliminates the difference between labelled und unlabelled accuracy . ) As expected , an improved accuracy of supertagging would lead to improved parsing accuracy in each case . In fact , knowing the correct supertag would solve the parsing problem almost completely with the more complex models . This confirms earlier findings for English ( Nasr and Rambow , 2004 ) . Since perfect supertaggers are not available , we have to make do with the imperfect ones that do exist . One method of avoiding some errors introduced by supertagging would be to reject supertag predictions that tend to be wrong . To this end , we ran the supertagger on its training set and determined the average component accuracy of each occurring supertag . The supertags whose average precision fell below a variable threshold were not considered during parsing as if the supertagger had not made a prediction . This means that a threshold of 100 % corresponds to the baseline of not using supertags at all , while a threshold of 0 % prunes nothing , so that these two cases duplicate the first and last line from Table 2 . As Table 6 shows , pruning supertags that are wrong more often than they are right results in a further small improvement in parsing accuracy : unlabelled syntax accuracy rises up to 92.1 % against the 91.8 % if all supertags of model J are used . However , the effect is not very noticeable , so that it would be almost certainly more useful to improve the supertagger itself rather than secondguess its output . 5 Related work Supertagging was originally suggested as a method to reduce lexical ambiguity , and thereby the amount of disambiguation work done by the parser . Sakar et al . ( 2000 ) report that this increases the speed of their LTAG parser by a factor of 26 ( from 548k to 21k seconds ) but at the price of only being able to parse 59 % of the sentences in their test data ( of 2250 sentences ) , because too often the correct supertag is missing from the output of the supertagger . Chen et al . ( 2002 ) investigate different supertagging methods as pre-processors to a Tree-Adjoining Grammar parser , and they claim a 1 - best supertagging accuracy of 81.47 % , and a 4best accuracy of 91.41 % . With the latter they reach the highest parser coverage , about three quarters of the 1700 sentences in their test data . Clark and Curran ( 2004a ; 2004b ) describe a combination of supertagger and parser for parsing Combinatory Categorial Grammar , where the tagger is used to filter the parses produced by the grammar , before the computation of the model parameters . The parser uses an incremental method : the supertagger first assigns a small number of categories to each word , and the parser requests more alternatives only if the analysis fails . They report 91.4 % precision and 91.0 % recall of unlabelled dependencies and a speed of 1.6 minutes to parse 2401 sentences , and claim a parser speedup of a factor of 77 thanks to supertagging . The supertagging approach that is closest to ours in terms of linguistic representations is probably ( Wang and Harper , 2002 ; Wang and Harper , 2004 ) whose Super Abstract Role Values are very similar to our model F supertags ( Table 2 ) . It is interesting to note that they only report between 328 and 791 SuperARVs for different corpora , whereas we have 2026 category F supertags . Part of the difference is explained by our larger label set : 35 , the same as the number of model A supertags in table 2 against their 24 ( White , 2000 , p. 50 ) . Also , we are not using the same corpus . In addition to determining the optimal SuperARV sequence in isolation , Wang and Harper ( 2002 ) also combine the SuperARV n-gram probabilities with a dependency assignment probability into a dependency parser for English . A maximum tagging accuracy of 96.3 % ( for sentences up to 100 words ) is achieved using a 4 - gram n-best tagger producing the 100 best SuperARV sequences for a sentence . The tightly integrated model is able to determine 96.6 % of SuperARVs correctly . The parser itself reaches a labelled precision of 92.6 % and a labelled recall of 92.2 % ( Wang and Harper , 2004 ) . In general , the effect of supertagging in the other systems mentioned here is to reduce the ambiguity in the input to the parser and thereby increase its speed , in some cases dramatically . For us , supertagging decreases the speed slightly , because additional constraints means more work for the parser , and because our supertagger-parser integration is not yet optimal . On the other hand it gives us better parsing accuracy . Using a constraint penalty of 0.0 for the supertagger integration ( c.f . Table 5 ) does speed up our parser several times , but would only be practical with very high tagging accuracy . An important point is that for some other systems , like ( Sarkar et al. , 2000 ) and ( Chen et al. , 2002 ) , parsing is not actually feasible without the supertagging speedup . 6 Conclusions and future work We have shown that a statistical supertagging component can significantly improve the parsing accuracy of a general-purpose dependency parser for German . The error rate among syntactic attachments can be reduced by 24 % over an already competitive baseline . After all , the integration of the supertagging results helped to reach a quality level which compares favourably with the state-of-the-art in probabilistic dependency parsing for German as defined with 87.34 % / 90.38 % labelled / unlabelled attachment accuracy on this years shared CoNLL task by ( McDonald et al . , 2005 ) ( see ( Foth and Menzel , 2006 ) for a more detailed comparison ) . Although the statistical model used in our system is rather simple-minded , it clearly captures at least some distributional char acteristics of German text that the hand-written rules do not . A crucial factor for success is the defeasible integration of the supertagging predictions via soft constraints . Rather than pursuing a strict filtering approach where supertagging errors are partially compensated by an n-best selection , we commit to only one supertag per word , but reduce its influence . Treating supertag predictions as weak preferences yields the best results . By measuring the accuracy of the different types of predictions made by complex supertags , different weights could also be assigned to the six new constraints . Of the investigated supertag models , the most complex ones guide the parser best , although their own accuracy is not the best one , even when measured by the more pertinent component accuracy . Since purely statistical parsing methods do not reach comparable parsing accuracy on the same data , we assume that this trend does not continue indefinitely , but would stop at some point , perhaps already reached . "}
  },
    {
    "id": "P07-1007",
    "result":     [
            {
        "value":         {
          "start": 197,
          "end": 204,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 353,
          "end": 376,
          "text": "active learning approach",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 500,
          "end": 530,
          "text": "expectation-maximization ( EM )",
          "labels": ["Method"]
        },
        "id": 533
      },
            {
        "value":         {
          "start": 547,
          "end": 569,
          "text": "count-merging technique",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 659,
          "end": 682,
          "text": "active learning approach",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 1395,
          "end": 1404,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 1469,
          "end": 1487,
          "text": "Brown Corpus ( BC )",
          "labels": ["Dataset"]
        },
        "id": 359
      },
            {
        "value":         {
          "start": 1493,
          "end": 1519,
          "text": "Wall Street Journal ( WSJ )",
          "labels": ["Dataset"]
        },
        "id": 360
      },
            {
        "value":         {
          "start": 1575,
          "end": 1576,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 1581,
          "end": 1583,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 1594,
          "end": 1603,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 1655,
          "end": 1662,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 1850,
          "end": 1857,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 1963,
          "end": 1964,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 1970,
          "end": 1972,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 2044,
          "end": 2045,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 2051,
          "end": 2053,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 2174,
          "end": 2175,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 2181,
          "end": 2183,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 2187,
          "end": 2194,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2453,
          "end": 2476,
          "text": "active learning strategy",
          "labels": ["Method"]
        },
        "id": 362
      },
            {
        "value":         {
          "start": 2617,
          "end": 2631,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 2736,
          "end": 2750,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 2904,
          "end": 2918,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 3969,
          "end": 3999,
          "text": "expectation-maximization ( EM )",
          "labels": ["Method"]
        },
        "id": 533
      },
            {
        "value":         {
          "start": 4112,
          "end": 4134,
          "text": "count-merging technique",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 4213,
          "end": 4227,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 4265,
          "end": 4277,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 4303,
          "end": 4319,
          "text": "EMbased algorithm",
          "labels": ["Method"]
        },
        "id": 365
      },
            {
        "value":         {
          "start": 4409,
          "end": 4423,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 4429,
          "end": 4441,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 4555,
          "end": 4572,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 5018,
          "end": 5027,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 5127,
          "end": 5128,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5134,
          "end": 5136,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5150,
          "end": 5151,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5287,
          "end": 5296,
          "text": "WSJ corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 5456,
          "end": 5465,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 5476,
          "end": 5477,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5483,
          "end": 5485,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5640,
          "end": 5649,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 5782,
          "end": 5787,
          "text": "SEMCOR",
          "labels": ["Dataset"]
        },
        "id": 369
      },
            {
        "value":         {
          "start": 5855,
          "end": 5860,
          "text": "SEMCOR",
          "labels": ["Dataset"]
        },
        "id": 369
      },
            {
        "value":         {
          "start": 5877,
          "end": 5878,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 5913,
          "end": 5914,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 6088,
          "end": 6089,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 6094,
          "end": 6096,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 6160,
          "end": 6161,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 6207,
          "end": 6209,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 6335,
          "end": 6344,
          "text": "WSJ corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 6401,
          "end": 6415,
          "text": "WordNet Domains",
          "labels": ["Dataset"]
        },
        "id": 369
      },
            {
        "value":         {
          "start": 6747,
          "end": 6749,
          "text": "DSO",
          "labels": ["Dataset"]
        },
        "id": 370
      },
            {
        "value":         {
          "start": 7201,
          "end": 7203,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 7283,
          "end": 7285,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 7381,
          "end": 7404,
          "text": "WordNet Domains resource",
          "labels": ["Dataset"]
        },
        "id": 371
      },
            {
        "value":         {
          "start": 7687,
          "end": 7694,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 7763,
          "end": 7764,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 7781,
          "end": 7788,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 7843,
          "end": 7845,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8227,
          "end": 8228,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8248,
          "end": 8250,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8537,
          "end": 8539,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8659,
          "end": 8666,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8705,
          "end": 8712,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8776,
          "end": 8777,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8805,
          "end": 8807,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 8887,
          "end": 8897,
          "text": "naive Bayes",
          "labels": ["Method"]
        },
        "id": 372
      },
            {
        "value":         {
          "start": 9187,
          "end": 9208,
          "text": "naive Bayes classifier",
          "labels": ["Method"]
        },
        "id": 373
      },
            {
        "value":         {
          "start": 9408,
          "end": 9409,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 9495,
          "end": 9497,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 9543,
          "end": 9545,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 9585,
          "end": 9599,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 9773,
          "end": 9775,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 9811,
          "end": 9813,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 9864,
          "end": 9873,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 10169,
          "end": 10171,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 10207,
          "end": 10216,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 10457,
          "end": 10468,
          "text": "countmerging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 10503,
          "end": 10514,
          "text": "Countmerging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 10660,
          "end": 10672,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 10913,
          "end": 10925,
          "text": "Count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 11156,
          "end": 11168,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 11433,
          "end": 11435,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 11492,
          "end": 11493,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 11606,
          "end": 11618,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 11681,
          "end": 11698,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 12657,
          "end": 12668,
          "text": "EM algorithm",
          "labels": ["Method"]
        },
        "id": 375
      },
            {
        "value":         {
          "start": 13339,
          "end": 13340,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 13459,
          "end": 13470,
          "text": "EM algorithm",
          "labels": ["Method"]
        },
        "id": 375
      },
            {
        "value":         {
          "start": 14676,
          "end": 14677,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 14730,
          "end": 14732,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 14955,
          "end": 14957,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 15028,
          "end": 15030,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 15341,
          "end": 15348,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15476,
          "end": 15483,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15720,
          "end": 15722,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 15819,
          "end": 15833,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 15882,
          "end": 15894,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 15901,
          "end": 15915,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 16005,
          "end": 16012,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16078,
          "end": 16085,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16291,
          "end": 16303,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 16377,
          "end": 16391,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 16412,
          "end": 16419,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16558,
          "end": 16559,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 16601,
          "end": 16615,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 16633,
          "end": 16635,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 16691,
          "end": 16693,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 16743,
          "end": 16750,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16784,
          "end": 16798,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 16812,
          "end": 16825,
          "text": "paired t-tests",
          "labels": ["Method"]
        },
        "id": 375
      },
            {
        "value":         {
          "start": 17044,
          "end": 17051,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17076,
          "end": 17077,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17083,
          "end": 17094,
          "text": "WSJ datasets",
          "labels": ["Dataset"]
        },
        "id": 376
      },
            {
        "value":         {
          "start": 17181,
          "end": 17182,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17188,
          "end": 17190,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17218,
          "end": 17219,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17264,
          "end": 17265,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17315,
          "end": 17317,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17454,
          "end": 17456,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17491,
          "end": 17492,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17576,
          "end": 17578,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17630,
          "end": 17632,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17686,
          "end": 17688,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17706,
          "end": 17707,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17825,
          "end": 17826,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17912,
          "end": 17914,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 17965,
          "end": 17966,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 18069,
          "end": 18070,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 18178,
          "end": 18192,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 18315,
          "end": 18316,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 18386,
          "end": 18388,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 18428,
          "end": 18435,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18624,
          "end": 18626,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 18660,
          "end": 18661,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19038,
          "end": 19039,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19053,
          "end": 19062,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 19154,
          "end": 19156,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19170,
          "end": 19179,
          "text": "DSO corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 19350,
          "end": 19359,
          "text": "WSJ corpus",
          "labels": ["Dataset"]
        },
        "id": 377
      },
            {
        "value":         {
          "start": 19390,
          "end": 19391,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19449,
          "end": 19451,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19523,
          "end": 19524,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19549,
          "end": 19551,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19626,
          "end": 19627,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19633,
          "end": 19635,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19707,
          "end": 19708,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 19714,
          "end": 19721,
          "text": "WSJ data",
          "labels": ["Dataset"]
        },
        "id": 378
      },
            {
        "value":         {
          "start": 20022,
          "end": 20029,
          "text": "WSJ data",
          "labels": ["Dataset"]
        },
        "id": 378
      },
            {
        "value":         {
          "start": 20049,
          "end": 20051,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20117,
          "end": 20123,
          "text": "BC data",
          "labels": ["Dataset"]
        },
        "id": 380
      },
            {
        "value":         {
          "start": 20142,
          "end": 20143,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20183,
          "end": 20185,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20234,
          "end": 20235,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20314,
          "end": 20315,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20381,
          "end": 20382,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20414,
          "end": 20415,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20469,
          "end": 20471,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20563,
          "end": 20575,
          "text": "KL-divergence",
          "labels": ["Metric"]
        },
        "id": 379
      },
            {
        "value":         {
          "start": 20618,
          "end": 20624,
          "text": "BC data",
          "labels": ["Dataset"]
        },
        "id": 380
      },
            {
        "value":         {
          "start": 20630,
          "end": 20632,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20724,
          "end": 20725,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20750,
          "end": 20752,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20811,
          "end": 20812,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20859,
          "end": 20861,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 20942,
          "end": 20956,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 21164,
          "end": 21171,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21275,
          "end": 21282,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21945,
          "end": 21958,
          "text": "EMbased method",
          "labels": ["Method"]
        },
        "id": 380
      },
            {
        "value":         {
          "start": 22095,
          "end": 22112,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 22150,
          "end": 22152,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22372,
          "end": 22373,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22379,
          "end": 22381,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22389,
          "end": 22406,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 22576,
          "end": 22577,
          "text": "BC",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22583,
          "end": 22585,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22654,
          "end": 22671,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 22696,
          "end": 22698,
          "text": "WSJ",
          "labels": ["Dataset"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 22852,
          "end": 22859,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22999,
          "end": 23016,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 23030,
          "end": 23042,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 23342,
          "end": 23354,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 23402,
          "end": 23422,
          "text": "active learning-based",
          "labels": ["Method"]
        },
        "id": 381
      },
            {
        "value":         {
          "start": 23482,
          "end": 23491,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 23615,
          "end": 23622,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23650,
          "end": 23657,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23805,
          "end": 23814,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 23852,
          "end": 23859,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24159,
          "end": 24166,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24371,
          "end": 24385,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 24471,
          "end": 24485,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 24709,
          "end": 24731,
          "text": "count-merging technique",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 24762,
          "end": 24776,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 25110,
          "end": 25122,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 25435,
          "end": 25449,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 25738,
          "end": 25752,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 25757,
          "end": 25768,
          "text": "countmerging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 26005,
          "end": 26019,
          "text": "active learning",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 26155,
          "end": 26172,
          "text": "EM-based algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 26335,
          "end": 26347,
          "text": "count-merging",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 26468,
          "end": 26491,
          "text": "active learning approach",
          "labels": ["Method"]
        },
        "id": 383
      }
    ],
    "data": {"text": "Domain Adaptation with Active Learning for Word Sense Disambiguation Abstract When a word sense disambiguation ( WSD ) system is trained on one domain but applied to a different domain , a drop in accuracy is frequently observed . This highlights the importance of domain adaptation for word sense disambiguation . In this paper , we first show that an active learning approach can be successfully used to perform domain adaptation of WSD systems . Then , by using the predominant sense predicted by expectation-maximization ( EM ) and adopting a count-merging technique , we improve the effectiveness of the original adaptation process achieved by the basic active learning approach . 1 Introduction In natural language , a word often assumes different meanings , and the task of determining the correct meaning , or sense , of a word in different contexts is known as word sense disambiguation ( WSD ) . To date , the best performing systems in WSD use a corpus-based , supervised learning approach . With this approach , one would need to collect a text corpus , in which each ambiguous word occurrence is first tagged with its correct sense to serve as training data . The reliance of supervised WSD systems on annotated corpus raises the important issue of domain dependence . To investigate this , Escudero et al . ( 2000 ) and Martinez and Agirre ( 2000 ) conducted experiments using the DSO corpus , which contains sentences from two different corpora , namely Brown Corpus ( BC ) and Wall Street Journal ( WSJ ) . They found that training a WSD system on one part ( BC or WSJ ) of the DSO corpus , and applying it to the other , can result in an accuracy drop of more than 10 % , highlighting the need to perform domain adaptation of WSD systems to new domains . Escudero et al . ( 2000 ) pointed out that one of the reasons for the drop in accuracy is the difference in sense priors ( i.e . , the proportions of the different senses of a word ) between BC and WSJ . When the authors assumed they knew the sense priors of each word in BC and WSJ , and adjusted these two datasets such that the proportions of the different senses of each word were the same between BC and WSJ , accuracy improved by 9 % . In this paper , we explore domain adaptation of WSD systems , by adding training examples from the new domain as additional training data to a WSD system . To reduce the effort required to adapt a WSD system to a new domain , we employ an active learning strategy ( Lewis and Gale , 1994 ) to select examples to annotate from the new domain of interest . To our knowledge , our work is the first to use active learning for domain adaptation for WSD . A similar work is the recent research by Chen et al . ( 2006 ) , where active learning was used successfully to reduce the annotation effort for WSD of 5 English verbs using coarse-grained evaluation . In that work , the authors only used active learning to reduce the annotation effort and did not deal with the porting of a WSD system to a new domain . Domain adaptation is necessary when the training and target domains are different . In this paper , we perform domain adaptation for WSD of a set of its BC and WSJ parts to investigate the domain denouns using fine-grained evaluation . The contribu - pendence of several WSD algorithms . Following the tion of our work is not only in showing that active setup of ( Escudero et al. , 2000 ) , we similarly made learning can be successfully employed to reduce the use of the DSO corpus to perform our experiments annotation effort required for domain adaptation in on domain adaptation . More importantly , our Among the few currently available manually main focus and contribution is in showing how we sense-annotated corpora for WSD , the SEMCOR can improve the effectiveness of a basic active learn - ( SC ) corpus ( Miller et al. , 1994 ) is the most widely ing approach when it is used for domain adaptation . Using the sense priors estimated by expectation-maximization ( EM ) , the predominant sense in the new domain is predicted . Using this predicted predominant sense and adopting a count-merging technique , we improve the effectiveness of the adaptation process . We then introduce active learning for domain adaptation , followed by count-merging . Next , we describe an EMbased algorithm to estimate the sense priors in the new domain . Performance of domain adaptation using active learning and count-merging is then presented . Next , we show that by using the predominant sense of the target domain as predicted by the EM-based algorithm , we improve the effectiveness of the adaptation process . Our empirical results show that for the set of nouns which have different predominant senses between the training and target domains , we are able to reduce the annotation effort by 71 % . 2 Experimental Setting In this section , we discuss the motivations for choosing the particular corpus and the set of nouns to conduct our domain adaptation experiments . 2.1 Choice of Corpus The DSO corpus ( Ng and Lee , 1996 ) contains 192,800 annotated examples for 121 nouns and 70 verbs , drawn from BC and WSJ . While the BC is built as a balanced corpus , containing texts in various categories such as religion , politics , humanities , fiction , etc , the WSJ corpus consists primarily of business and financial news . Exploiting the difference in coverage between these two corpora , Escudero et al . ( 2000 ) separated the DSO corpus into its BC and WSJ parts to investigate the domain dependence of several WSD algorithms . Following the setup of ( Escudero et al . , 2000 ) , we similarly made use of the DSO corpus to perform our experiments on domain adaptation . Among the few currently available manually sense-annotated corpora for WSD , the SEMCOR ( SC ) corpus ( Miller et al . , 1994 ) is the most widely used . SEMCOR is a subset of BC which is sense-annotated . Since BC is a balanced corpus , and since performing adaptation from a general corpus to a more specific corpus is a natural scenario , we focus on adapting a WSD system trained on BC to WSJ in this paper . Henceforth , out-of-domain data will refer to BC examples , and in-domain data will refer to WSJ examples . In the next section , we discuss the choice of corpus and nouns used in our experiments . Since the focus of the WSJ corpus is on business and financial news , we can make use of WordNet Domains to select the set of nouns having at least one synset labeled with a business or finance related domain label . This is similar to the approach taken in ( Koeling et al . , 2005 ) where they focus on determining the predominant sense of words in corpora drawn from finance versus sports domains .1 Hence , we select the subset of DSO nouns that have at least one synset labeled with any of these domain labels : commerce , enterprise , money , finance , banking , and economy . This gives a set of 21 nouns : book , business , center , community , condition , field , figure , house , interest , land , line , money , need , number , order , part , power , society , term , use , value .2 For each noun , all the BC examples are used as out-of-domain training data . One-third of the WSJ examples for each noun are set aside as evaluation data , and the rest of the WSJ examples are designated as in-domain adaptation data . 1Note however that the coverage of the WordNet Domains resource is not comprehensive , as about 31 % of the synsets are simply labeled with factotum , indicating that the synset does not belong to a specific domain . 225 nouns have at least one synset labeled with the listed domain labels . In our experiments , 4 out of these 25 nouns have an accuracy of more than 90 % before adaptation ( i.e . , training on just the BC examples ) and accuracy improvement is less than 1 % after all the available WSJ adaptation examples are added as additional training data . To obtain a clearer picture of the adaptation process , we discard these 4 nouns , leaving a set of data , and the rest of the WSJ examples are designated as in-domain adaptation data . The row 21 nouns in Table 1 shows some information about these 21 nouns . For instance , these nouns have an average of 6.7 senses in BC and 6.8 senses in WSJ . This is slightly higher than the 5.8 senses per verb in ( Chen et al. , 2006 ) , where the experiments were conducted using coarse-grained evaluation . Assuming we have access to an oracle which determines the predominant sense , or most frequent sense ( MFS ) , of each noun in our WSJ test data perfectly , and we assign this most frequent sense to each noun in the test data , we will have achieved an accuracy of 61.1 % as shown in the column MFS accuracy of Table 1 . Finally , we note that we have an average of 310 BC training examples and 406 WSJ adaptation examples per noun . 3 Active Learning For our experiments , we use naive Bayes as the learning algorithm . The knowledge sources we use include parts-of-speech , local collocations , and surrounding words . These knowledge sources were effectively used to build a state-of-the-art WSD program in one of our prior work ( Lee and Ng , 2002 ) . In performing WSD with a naive Bayes classifier , the sense s assigned to an example with features f1 , . . . , fn is chosen so as to maximize : In our domain adaptation study , we start with a WSD system built using training examples drawn from BC . We then investigate the utility of adding additional in-domain training data from WSJ . In the baseline approach , the additional WSJ examples are randomly selected . With active learning ( Lewis and Gale , 1994 ) , we use uncertainty sampling as shown in Figure 1 . In each iteration , we train a WSD system on the available training data and apply it on the WSJ adaptation examples . Among these WSJ examples , the example predicted with the lowest confidence is selected and removed from the adaptation data . The correct label is then supplied for this example and it is added to the training data . Note that in the experiments reported in this paper , all the adaptation examples are already preannotated before the experiments start , since all the WSJ adaptation examples come from the DSO corpus which have already been sense-annotated . Hence , the annotation of an example needed during each adaptation iteration is simulated by performing a lookup without any manual annotation . 4 Count-merging We also employ a technique known as countmerging in our domain adaptation study . Countmerging assigns different weights to different examples to better reflect their relative importance . Roark and Bacchiani ( 2003 ) showed that weighted count-merging is a special case of maximum a posteriori ( MAP ) estimation , and successfully used it for probabilistic context-free grammar domain adaptation ( Roark and Bacchiani , 2003 ) and language model adaptation ( Bacchiani and Roark , 2003 ) . Count-merging can be regarded as scaling of counts obtained from different data sets . We let c denote the counts from out-of-domain training data , c denote the counts from in-domain adaptation data , and p denote the probability estimate by count-merging . We can scale the out-of-domain and in-domain counts with different factors , or just use a single weight parameter : Obtaining an optimum value for is not the focus of this work . Instead , we are interested to see if assigning a higher weight to the in-domain WSJ adaptation examples , as compared to the out-of-domain BC examples , will improve the adaptation process . Hence , we just use a value of 3 in our experiments involving count-merging . 5 Estimating Sense Priors In this section , we describe an EM-based algorithm that was introduced by Saerens et al . ( 2002 ) , which can be used to estimate the sense priors , or a priori probabilities of the different senses in a new dataset . We have recently shown that this algorithm is effective in estimating the sense priors of a set of nouns ( Chan and Ng , 2005 ) . Most of this section is based on ( Saerens et al. , 2002 ) . Assume we have a set of labeled data DL with n classes and a set of N independent instances ( x1 , ... , xN ) from a new data set . The likelihood of these N instances can be defined as : Assuming the within-class densities p ( xk | i ) , i.e. , the probabilities of observing xk given the class i , do not change from the training set DL to the new data set , we can define : p ( xk | i ) = pL ( xk | i ) . To determine the a priori probability estimates bp ( i ) of the new data set that will maximize the likelihood of ( 3 ) with respect to p ( i ) , we can apply the iterative procedure of the EM algorithm . In effect , through maximizing the likelihood of ( 3 ) , we obtain the a priori probability estimates as a by-product . Let us now define some notations . When we apply a classifier trained on DL on an instance xk drawn from the new data set DU , we get bpL ( i | xk ) , which we define as the probability of instance xk being classified as class i by the classifier trained on DL . Further , let us define bpL ( i ) as the a priori probability of class i in DL . This can be estimated by the class frequency of i in DL . We also define bp ( s ) ( i ) and bp ( s ) ( i | xk ) as estimates of the new a priori and a posteriori probabilities at step s of the iterative EM procedure . Assuming we initialize bp ( ) ( i ) = bpL ( i ) , then for each instance xk in DU and each class i , the EM algorithm provides the following iterative steps : where Equation ( 4 ) represents the expectation Estep , Equation ( 5 ) represents the maximization Mstep , and N represents the number of instances in DU . Note that the probabilities bpL ( i | xk ) and bpL ( i ) in Equation ( 4 ) will stay the same throughout the iterations for each particular instance xk and class i . The new a posteriori probabilities bp ( s ) ( i | xk ) at step s in Equation ( 4 ) are simply the a posteriori probabilities in the conditions of the labeled data , bpL ( i | xk ) , weighted by the ratio of the new priors bp ( s ) ( i ) to the old priors bpL ( i ) . The denominator in Equation ( 4 ) is simply a normalizing factor . The a posteriori bp ( s ) ( i | xk ) and a priori probabilities bp ( s ) ( i ) are re-estimated sequentially during each iterations for each new instance xk and each class i , until the convergence of the estimated probabilities bp ( s ) ( i ) , which will be our estimated sense priors . This iterative procedure will increase the likelihood of ( 3 ) at each step . 6 Experimental Results For each adaptation experiment , we start off with a classifier built from an initial training set consisting of the BC training examples . At each adaptation iteration , WSJ adaptation examples are selected one at a time and added to the training set . The adaptation process continues until all the adaptation examples are added . Classification accuracies averaged over 3 random trials on the WSJ test examples at each iteration are calculated . Since the number of WSJ adaptation examples differs for each of the 21 nouns , the learning curves we will show in the various figures are plotted in terms of different percentage of adaptation examples added , varying from 0 to 100 percent in steps of 1 percent . To obtain these curves , we first calculate for each noun , the WSD accuracy when different percentages of adaptation examples are added . Then , for each percentage , we calculate the macro-average WSD accuracy over all the nouns to obtain a single learning curve representing all the nouns . 6.1 Utility of Active Learning and Count-merging In Figure 2 , the curve r represents the adaptation process of the baseline approach , where additional WSJ examples are randomly selected during each adaptation iteration . The adaptation process using active learning is represented by the curve a , while applying count-merging with active learning is represented by the curve a-c . Note that random selection r achieves its highest WSD accuracy after all the adaptation examples are added . To reach the same accuracy , the a approach requires the addition of only 57 % of adaptation examples . The a-c approach is even more effective and requires only 42 % of adaptation examples . This demonstrates the effectiveness of count-merging in further reducing the annotation effort , when compared to using only active learning . To reach the MFS accuracy of 61.1 % as shown earlier in Table 1 , a-c requires just 4 % of the adaptation examples . To determine the utility of the out-of-domain BC examples , we have also conducted three active learning runs using only WSJ adaptation examples . Using 10 % , 20 % , and 30 % of WSJ adaptation examples to build a classifier , the accuracy of these runs is lower than the active learning a curve and paired t-tests show that the difference is statistically significant at the level of significance 0.01 . 6.2 Using Sense Priors Information As mentioned in section 1 , research in ( Escudero et al . , 2000 ) noted an improvement in accuracy when they adjusted the BC and WSJ datasets such that the proportions of the different senses of each word were the same between BC and WSJ . We can similarly choose BC examples such that the sense priors in the BC training data adhere to the sense priors in the WSJ evaluation data . To gauge the effectiveness of this approach , we first assume that we know the true sense priors of each noun in the WSJ evaluation data . We then gather BC training examples for a noun to adhere as much as possible to the sense priors in WSJ . Assume sense si is the predominant sense in the WSJ evaluation data , si has a sense prior of pi in the WSJ data and has ni BC training examples . Taking ni examples to represent a sense prior of pi , we proportionally determine the number of BC examples to gather for other senses s according to their respective sense priors in WSJ . If there are insufficient training examples in BC for some sense s , whatever available examples of s are used . This approach gives an average of 195 BC training examples for the 21 nouns . With this new set of training examples , we perform adaptation using active learning and obtain the a-truePrior curve in Figure 2 . The a-truePrior curve shows that by ensuring that the sense priors in the BC training data adhere as much as possible to the sense priors in the WSJ data , we start off with a higher WSD accuracy . However , the performance is no different from the a curve after 35 % of adaptation examples are added . A possible reason might be that by strictly adhering to the sense priors in the WSJ data , we have removed too many BC training examples , from an average of 310 examples per noun as shown in Table 1 , to an average of 195 examples . 6.3 Using Predominant Sense Information Research by McCarthy et al. ( 2004 ) and Koeling et al. ( 2005 ) pointed out that a change of predominant sense is often indicative of a change in domain . For example , the predominant sense of the noun interest in the BC part of the DSO corpus has the meaning a sense of concern with and curiosity about someone or something . In the WSJ part of the DSO corpus , the noun interest has a different predominant sense with the meaning a fixed charge for borrowing money , which is reflective of the business and finance focus of the WSJ corpus . Instead of restricting the BC training data to adhere strictly to the sense priors in WSJ , another alternative is just to ensure that the predominant sense in BC is the same as that of WSJ . Out of the 21 nouns , 12 nouns have the same predominant sense in both BC and WSJ . The remaining 9 nouns that have different predominant senses in the BC and WSJ data are : center , field , figure , interest , line , need , order , term , value . The row 9 nouns in Table 1 gives some information for this set of 9 nouns . To gauge the utility of this approach , we conduct experiments on these nouns by first assuming that we know the true predominant sense in the WSJ data . Assume that the WSJ predominant sense of a noun is sz and sz has nz examples in the BC data . We then gather BC examples for a noun to adhere to this WSJ predominant sense , by gathering only up to nz BC examples for each sense of this noun . This approach gives an average of 190 BC examples for the 9 nouns . This is higher than an average of 83 BC examples for these 9 nouns if BC examples are selected to follow the sense priors of WSJ evaluation data as described in the last subsection 6.2 . For these 9 nouns , the average KL-divergence between the sense priors of the original BC data and WSJ evaluation data is 0.81 . This drops to 0.51 after ensuring that the predominant sense in BC is the same as that of WSJ , confirming that the sense priors in the newly gathered BC data more closely follow the sense priors in WSJ . Using this new set of training examples , we perform domain adaptation using active learning to obtain the curve a-truePred in Figure 3 . For comparison , we also plot the curves a and a-truePrior for this set of 9 nouns in Figure 3 . Results in Figure 3 show that a-truePred starts off at a higher accuracy and performs consistently better than the a curve . In contrast , though a-truePrior starts at a high accuracy , its performance is lower than a-truePred and a after 50 % of adaptation examples are added . The approach represented by atruePred is a compromise between ensuring that the sense priors in the training data follow as closely as possible the sense priors in the evaluation data , while retaining enough training examples . These results highlight the importance of striking a balance between these two goals . In ( McCarthy et al. , 2004 ) , a method was presented to determine the predominant sense of a word in a corpus . However , in ( Chan and Ng , 2005 ) , we showed that in a supervised setting where one has access to some annotated training data , the EMbased method in section 5 estimates the sense priors more effectively than the method described in ( McCarthy et al . , 2004 ) . Hence , we use the EM-based algorithm to estimate the sense priors in the WSJ evaluation data for each of the 21 nouns . The sense with the highest estimated sense prior is taken as the predominant sense of the noun . For the set of 12 nouns where the predominant sense remains unchanged between BC and WSJ , the EM-based algorithm is able to predict that the predominant sense remains unchanged for all 12 nouns . Hence , we will focus on the 9 nouns which have different predominant senses between BC and WSJ for our remaining adaptation experiments . For these 9 nouns , the EM-based algorithm correctly predicts the WSJ predominant sense for 6 nouns . Hence , the algorithm is able to predict the correct predominant sense for 18 out of 21 nouns overall , representing an accuracy of 86 % . Figure 4 plots the curve a-estPred , which is similar to a-truePred , except that the predominant sense is now estimated by the EM-based algorithm . Employing count-merging with a-estPred produces the curve a-c-estPred . For comparison , the curves r , a , and a-truePred are also plotted . The results show that a-estPred performs consistently better than a , and a-c-estPred in turn performs better than aestPred . Hence , employing the predicted predominant sense and count-merging , we further improve the effectiveness of the active learning-based adaptation process . With reference to Figure 4 , the WSD accuracies of the r and a curves before and after adaptation are 43.7 % and 78.4 % respectively . Starting from the mid-point 61.1 % accuracy , which represents a 50 % accuracy increase from 43.7 % , we show in Table 2 the percentage of adaptation examples required by the various approaches to reach certain levels of WSD accuracies . For instance , to reach the final accuracy of 78.4 % , r , a , a-estPred , and ac-estPred require the addition of 100 % , 51 % , 38 % , and 29 % adaptation examples respectively . The numbers in brackets give the ratio of adaptation examples needed by a , a-estPred , and a-c-estPred versus random selection r. For instance , to reach a WSD accuracy of 78.4 % , a-c-estPred needs only 29 % adaptation examples , representing a ratio of 0.29 and an annotation saving of 71 % . Note that this represents a more effective adaptation process than the basic active learning a approach , which requires 51 % adaptation examples . Hence , besides showing that active learning can be used to reduce the annotation effort required for domain adaptation , we have further improved the effectiveness of the adaptation process by using the predicted predominant sense of the new domain and adopting the count-merging technique . 7 Related Work In applying active learning for domain adaptation , Zhang et al . ( 2003 ) presented work on sentence boundary detection using generalized Winnow , while Tur et al . ( 2004 ) performed language model adaptation of automatic speech recognition systems . In both papers , out-of-domain and indomain data were simply mixed together without MAP estimation such as count-merging . For WSD , Fujii et al. ( 1998 ) used selective sampling for a Japanese language WSD system , Chen et al. ( 2006 ) used active learning for 5 verbs using coarse-grained evaluation , and H. T. Dang ( 2004 ) employed active learning for another set of 5 verbs . However , their work only investigated the use of active learning to reduce the annotation effort necessary for WSD , but did not deal with the porting of a WSD system to a different domain . Escudero et al . ( 2000 ) used the DSO corpus to highlight the importance of the issue of domain dependence of WSD systems , but did not propose methods such as active learning or countmerging to address the specific problem of how to perform domain adaptation for WSD . 8 Conclusion Domain adaptation is important to ensure the general applicability of WSD systems across different domains . In this paper , we have shown that active learning is effective in reducing the annotation effort required in porting a WSD system to a new domain . Also , we have successfully used an EM-based algorithm to detect a change in predominant sense between the training and new domain . With this information on the predominant sense of the new domain and incorporating count-merging , we have shown that we are able to improve the effectiveness of the original adaptation process achieved by the basic active learning approach . "}
  },
    {
    "id": "P07-1040",
    "result":     [
            {
        "value":         {
          "start": 726,
          "end": 748,
          "text": "weight tuning algorithm",
          "labels": ["Method"]
        },
        "id": 383
      },
            {
        "value":         {
          "start": 1348,
          "end": 1355,
          "text": "boosting",
          "labels": ["Method"]
        },
        "id": 384
      },
            {
        "value":         {
          "start": 2432,
          "end": 2452,
          "text": "Levenshtein alignment",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 2595,
          "end": 2615,
          "text": "Levenshtein alignment",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 2848,
          "end": 2855,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 3035,
          "end": 3042,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 3068,
          "end": 3088,
          "text": "Levenshtein alignment",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 3131,
          "end": 3159,
          "text": "translation edit rate ( TER )",
          "labels": ["Metric"]
        },
        "id": 396
      },
            {
        "value":         {
          "start": 3265,
          "end": 3267,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 3785,
          "end": 3810,
          "text": "Minimum Bayes risk ( MBR )",
          "labels": ["Method"]
        },
        "id": 389
      },
            {
        "value":         {
          "start": 3884,
          "end": 3886,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 3975,
          "end": 3977,
          "text": "MBR",
          "labels": ["Method"]
        },
        "id": 469
      },
            {
        "value":         {
          "start": 4026,
          "end": 4028,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 4106,
          "end": 4108,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 4555,
          "end": 4557,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 5282,
          "end": 5295,
          "text": "Powells method",
          "labels": ["Method"]
        },
        "id": 400
      },
            {
        "value":         {
          "start": 5945,
          "end": 5974,
          "text": "weights optimization algorithm",
          "labels": ["Method"]
        },
        "id": 392
      },
            {
        "value":         {
          "start": 6182,
          "end": 6194,
          "text": "NIST BLEU - 4",
          "labels": ["Metric"]
        },
        "id": 393
      },
            {
        "value":         {
          "start": 6271,
          "end": 6280,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 6390,
          "end": 6399,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 6515,
          "end": 6524,
          "text": "precisions",
          "labels": ["Metric"]
        },
        "id": 1059
      },
            {
        "value":         {
          "start": 6643,
          "end": 6646,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6701,
          "end": 6704,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6749,
          "end": 6752,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6781,
          "end": 6784,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6855,
          "end": 6858,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6886,
          "end": 6891,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 6955,
          "end": 6960,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 6967,
          "end": 6975,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7009,
          "end": 7014,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 7062,
          "end": 7070,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7076,
          "end": 7081,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 7461,
          "end": 7473,
          "text": "METEOR script",
          "labels": ["Tool"]
        },
        "id": 394
      },
            {
        "value":         {
          "start": 7549,
          "end": 7562,
          "text": "Porter stemmer",
          "labels": ["Tool"]
        },
        "id": 395
      },
            {
        "value":         {
          "start": 7604,
          "end": 7610,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 7815,
          "end": 7820,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 7938,
          "end": 7966,
          "text": "Translation edit rate ( TER )",
          "labels": ["Metric"]
        },
        "id": 396
      },
            {
        "value":         {
          "start": 8149,
          "end": 8151,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 8265,
          "end": 8267,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 8412,
          "end": 8422,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 8657,
          "end": 8659,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 8711,
          "end": 8713,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 8772,
          "end": 8774,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10105,
          "end": 10125,
          "text": "Levenshtein alignment",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 10470,
          "end": 10490,
          "text": "Levenshtein alignment",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 10501,
          "end": 10503,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10627,
          "end": 10629,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10686,
          "end": 10688,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 10992,
          "end": 10995,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 11001,
          "end": 11006,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 11507,
          "end": 11509,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 14780,
          "end": 14802,
          "text": "n - gram language model",
          "labels": ["Method"]
        },
        "id": 397
      },
            {
        "value":         {
          "start": 15090,
          "end": 15103,
          "text": "n - gram model",
          "labels": ["Method"]
        },
        "id": 398
      },
            {
        "value":         {
          "start": 15697,
          "end": 15699,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 16386,
          "end": 16388,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 18127,
          "end": 18129,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 18336,
          "end": 18349,
          "text": "Powells method",
          "labels": ["Method"]
        },
        "id": 400
      },
            {
        "value":         {
          "start": 18528,
          "end": 18565,
          "text": "grid-based line minimization algorithm",
          "labels": ["Method"]
        },
        "id": 399
      },
            {
        "value":         {
          "start": 19077,
          "end": 19080,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19085,
          "end": 19090,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 19120,
          "end": 19133,
          "text": "Powells method",
          "labels": ["Method"]
        },
        "id": 400
      },
            {
        "value":         {
          "start": 19213,
          "end": 19222,
          "text": "MT decoder",
          "labels": ["Tool"]
        },
        "id": 400
      },
            {
        "value":         {
          "start": 19275,
          "end": 19291,
          "text": "log-linear models",
          "labels": ["Method"]
        },
        "id": 402
      },
            {
        "value":         {
          "start": 19423,
          "end": 19439,
          "text": "log-linear models",
          "labels": ["Method"]
        },
        "id": 402
      },
            {
        "value":         {
          "start": 20078,
          "end": 20080,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 20118,
          "end": 20121,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20232,
          "end": 20253,
          "text": "bi-gram language model",
          "labels": ["Method"]
        },
        "id": 402
      },
            {
        "value":         {
          "start": 20532,
          "end": 20540,
          "text": "bigram LM",
          "labels": ["Method"]
        },
        "id": 403
      },
            {
        "value":         {
          "start": 20654,
          "end": 20660,
          "text": "bi-gram",
          "labels": ["Method"]
        },
        "id": 1405
      },
            {
        "value":         {
          "start": 20666,
          "end": 20697,
          "text": "5 - gram English language models",
          "labels": ["Method"]
        },
        "id": 405
      },
            {
        "value":         {
          "start": 21469,
          "end": 21474,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 21505,
          "end": 21507,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21517,
          "end": 21520,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21576,
          "end": 21581,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 21595,
          "end": 21603,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 21646,
          "end": 21651,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 21673,
          "end": 21678,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 21757,
          "end": 21762,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 21805,
          "end": 21813,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 21872,
          "end": 21874,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21880,
          "end": 21883,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22104,
          "end": 22106,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22155,
          "end": 22158,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22175,
          "end": 22177,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22260,
          "end": 22262,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22270,
          "end": 22273,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22321,
          "end": 22326,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 22344,
          "end": 22349,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 22611,
          "end": 22614,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22722,
          "end": 22727,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 22742,
          "end": 22744,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22782,
          "end": 22787,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 22900,
          "end": 22905,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 22995,
          "end": 22997,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23041,
          "end": 23043,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23051,
          "end": 23054,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23074,
          "end": 23077,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23089,
          "end": 23094,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 23114,
          "end": 23119,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 23154,
          "end": 23157,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23172,
          "end": 23175,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23236,
          "end": 23241,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 23766,
          "end": 23768,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24292,
          "end": 24295,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24404,
          "end": 24406,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24410,
          "end": 24413,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24419,
          "end": 24424,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 24432,
          "end": 24434,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24492,
          "end": 24495,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24555,
          "end": 24560,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 24626,
          "end": 24634,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24831,
          "end": 24833,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24889,
          "end": 24923,
          "text": "confusion network decoding approach",
          "labels": ["Method"]
        },
        "id": 406
      }
    ],
    "data": {"text": "Improved Word-Level System Combination for Machine Translation Antti-Veikko I. Rosti and Spyros Matsoukas and Richard Schwartz Abstract Recently , confusion network decoding has been applied in machine translation system combination . Due to errors in the hypothesis alignment , decoding may result in ungrammatical combination outputs . This paper describes an improved confusion network based method to combine outputs from multiple MT systems . In this approach , arbitrary features may be added log-linearly into the objective function , thus allowing language model expansion and re-scoring . Also , a novel method to automatically select the hypothesis which other hypotheses are aligned against is proposed . A generic weight tuning algorithm may be used to optimize various automatic evaluation metrics including TER , BLEU and METEOR . The experiments using the 2005 Arabic to English and Chinese to English NIST MT evaluation tasks show significant improvements in BLEU scores compared to earlier confusion network decoding based methods . 1 Introduction System combination has been shown to improve classification performance in various tasks . There are several approaches for combining classifiers . In ensemble learning , a collection of simple classifiers is used to yield better performance than any single classifier ; for example boosting ( Schapire , 1990 ) . Another approach is to combine outputs from a few highly specialized classifiers . The classifiers may be based on the same basic modeling techniques but differ by , for example , alternative feature representations . Combination of speech recognition outputs is an example of this approach ( Fiscus , 1997 ) . In speech recognition , confusion network decoding ( Mangu et al. , 2000 ) has become widely used in system combination . Unlike speech recognition , current statistical machine translation ( MT ) systems are based on various different paradigms ; for example phrasal , hierarchical and syntax-based systems . The idea of combining outputs from different MT systems to produce consensus translations in the hope of generating better translations has been around for a while ( Frederking and Nirenburg , 1994 ) . Recently , confusion network decoding for MT system combination has been proposed ( Bangalore et al. , 2001 ) . To generate confusion networks , hypotheses have to be aligned against each other . In ( Bangalore et al . , 2001 ) , Levenshtein alignment was used to generate the network . As opposed to speech recognition , the word order between two correct MT outputs may be different and the Levenshtein alignment may not be able to align shifted words in the hypotheses . In ( Matusov et al . , 2006 ) , different word orderings are taken into account by training alignment models by considering all hypothesis pairs as a parallel corpus using GIZA + + ( Och and Ney , 2003 ) . The size of the test set may influence the quality of these alignments . Thus , system outputs from development sets may have to be added to improve the GIZA + + alignments . A modified Levenshtein alignment allowing shifts as in computation of the translation edit rate ( TER ) ( Snover et al . , 2006 ) was used to align hy potheses in ( Sim et al . , 2007 ) . The alignments from TER are consistent as they do not depend on the test set size . Also , a more heuristic alignment method has been proposed in a different system combination approach ( Jayaraman and Lavie , 2005 ) . A full comparison of different alignment methods would be difficult as many approaches require a significant amount of engineering . Confusion networks are generated by choosing one hypothesis as the skeleton , and other hypotheses are aligned against it . The skeleton defines the word order of the combination output . Minimum Bayes risk ( MBR ) was used to choose the skeleton in ( Sim et al . , 2007 ) . The average TER score was computed between each systems-best hypothesis and all other hypotheses . The MBR hypothesis is the one with the minimum average TER and thus , may be viewed as the closest to all other hypotheses in terms of TER . This work was extended in ( Rosti et al. , 2007 ) by introducing system weights for word confidences . However , the system weights did not influence the skeleton selection , so a hypothesis from a system with zero weight might have been chosen as the skeleton . In this work , confusion networks are generated by using the-best output from each system as the skeleton , and prior probabilities for each network are estimated from the average TER scores between the skeleton and other hypotheses . All resulting confusion networks are connected in parallel into a joint lattice where the prior probabilities are also multiplied by the system weights . The combination outputs from confusion network decoding may be ungrammatical due to alignment errors . Also the word-level decoding may break coherent phrases produced by the individual systems . In this work , log-posterior probabilities are estimated for each confusion network arc instead of using votes or simple word confidences . This allows a log-linear addition of arbitrary features such as language model ( LM ) scores . The LM scores should increase the total log-posterior of more grammatical hypotheses . Powells method ( Brent , 1973 ) is used to tune the system and feature weights simultaneously so as to optimize various automatic evaluation metrics on a development set . Tuning is fully automatic , as opposed to ( Matusov et al. , 2006 ) where global system weights were set manually . This paper is organized as follows . Three evaluation metrics used in weights tuning and reporting the test set results are reviewed in Section 2 . Section 3 describes confusion network decoding for MT system combination . The extensions to add features log-linearly and improve the skeleton selection are presented in Sections 4 and 5 , respectively . Section 6 details the weights optimization algorithm and the experimental results are reported in Section 7 . Conclusions and future work are discussed in Section 8 . 2 Evaluation Metrics Currently , the most widely used automatic MT evaluation metric is the NIST BLEU - 4 ( Papineni et al . , 2002 ) . It is computed as the geometric mean of gram precisions up to-grams between the hypothesis and reference as follows where is the brevity penalty and are the - gram precisions . When multiple references are provided , the - gram counts against all references are accumulated to compute the precisions . Similarly , full test set scores are obtained by accumulating counts over all hypothesis and reference pairs . The BLEU scores are between and , higher being better . Often BLEU scores are reported as percentages and one BLEU point gain usually means a BLEU increase of . Other evaluation metrics have been proposed to replace BLEU . It has been argued that METEOR correlates better with human judgment due to higher weight on recall than precision ( Banerjee and Lavie , 2005 ) . METEOR is based on the weighted harmonic mean of the precision and recall measured on unigram matches as follows where is the total number of unigram matches , is the hypothesis length , is the reference length and is the minimum number of - gram matches that covers the alignment . The second term is a fragmentation penalty which penalizes the harmonic mean by a factor of up to when ; i.e. , there are no matching - grams higher than . By default , METEOR script counts the words that match exactly , and words that match after a simple Porter stemmer . Additional matching modules including WordNet stemming and synonymy may also be used . When multiple references are provided , the lowest score is reported . Full test set scores are obtained by accumulating statistics over all test sentences . The METEOR scores are also between and , higher being better . The scores in the results section are reported as percentages . Translation edit rate ( TER ) ( Snover et al . , 2006 ) has been proposed as more intuitive evaluation metric since it is based on the rate of edits required to transform the hypothesis into the reference . The TER score is computed as follows where is the reference length . The only difference to word error rate is that the TER allows shifts . A shift of a sequence of words is counted as a single edit . The minimum translation edit alignment is usually found through a beam search . When multiple references are provided , the edits from the closest reference are divided by the average reference length . Full test set scores are obtained by accumulating the edits and the average reference lengths . The perfect TER score is 0 , and otherwise higher than zero . The TER score may also be higher than 1 due to insertions . Also TER is reported as a percentage in the results section . 3 Confusion Network Decoding Confusion network decoding in MT has to pick one hypothesis as the skeleton which determines the word order of the combination . The other hypotheses are aligned against the skeleton . Either votes or some form of confidences are assigned to each word in the network . For example using cat sat the mat as the skeleton , aligning cat sitting on the mat and hat on a mat against it might yield the following alignments : where represents a NULL word . In graphical form , the resulting confusion network is shown in Figure 1 . Each arc represents an alternative word at that position in the sentence and the number of votes for each word is marked in parentheses . Confusion network decoding usually requires finding the path with the highest confidence in the network . Based on vote counts , there are three alternatives in the example : cat sat on the mat , cat on the mat and cat sitting on the mat , each having accumulated 10 votes . The alignment procedure plays an important role , as by switching the position of the word sat and the following NULL in the skeleton , there would be a single highest scoring path through the network ; that is , cat on the mat . Different alignment methods yield different confusion networks . The modified Levenshtein alignment as used in TER is more natural than simple edit distance such as word error rate since machine translation hypotheses may have different word orders while having the same meaning . As the skeleton determines the word order , the quality of the combination output also depends on which hypothesis is chosen as the skeleton . Since the modified Levenshtein alignment produces TER scores between the skeleton and the other hypotheses , a natural choice for selecting the skeleton is the minimum average TER score . The hypothesis resulting in the lowest average TER score when aligned against all other hypotheses is chosen as the skeleton as follows where is the number of systems . This is equivalent to minimum Bayes risk decoding with uniform posterior probabilities ( Sim et al. , 2007 ) . Other evaluation metrics may also be used as the MBR loss function . For BLEU and METEOR , the loss function would be and . It has been found that multiple hypotheses from each system may be used to improve the quality of cat sat the mat cat sitting on the mat hat on a mat the combination output ( Sim et al. , 2007 ) . When using - best lists from each system , the words may be assigned a different score based on the rank of the hypothesis . In ( Rosti et al. , 2007 ) , simple score was assigned to the word coming from the thbest hypothesis . Due to the computational burden of the TER alignment , only-best hypotheses were considered as possible skeletons , and hypotheses per system were aligned . Similar approach to estimate word posteriors is adopted in this work . System weights may be used to assign a system specific confidence on each word in the network . The weights may be based on the systems relative performance on a separate development set or they may be automatically tuned to optimize some evaluation metric on the development set . In ( Rosti et al. , 2007 ) , the total confidence of the th best confusion network hypothesis , including NULL words , given the th source sentence was given by ( 5 ) word-level decoding . For example , two synonymous words may be aligned to other words not already aligned , which may result in repetitive output . Second , the additive confidence scores in Equation 5 have no probabilistic meaning and can not therefore be combined with language model scores . Language model expansion and re-scoring may help by increasing the probability of more grammatical hypotheses in decoding . Third , the system weights are independent of the skeleton selection . Therefore , a hypothesis from a system with a low or zero weight may be chosen as the skeleton . 4 Log-Linear Combination with Arbitrary Features To address the issue with ungrammatical hypotheses and allow language model expansion and re-scoring , the hypothesis confidence computation is modified . Instead of summing arbitrary confidence scores as in Equation 5 , word posterior probabilities are used as follows where is the number of nodes in the confusion network for the source sentence , is the number of translation systems , is the th system weight , is the accumulated confidence for word produced by system between nodes and , and is a weight for the number of NULL links along the hypothesis . The word confidences were increased by if the word aligns between nodes and in the network . If no word aligns between nodes and , the NULL word confidence at that position was increased by . The last term controls the number of NULL words generated in the output and may be viewed as an insertion penalty . Each arc in the confusion network carries the word label and scores . The decoder outputs the hypothesis with the highest given the current set of weights . 3.1 Discussion There are several problems with the previous confusion network decoding approaches . First , the decoding can generate ungrammatical hypotheses due to alignment errors and phrases broken by the where is the language model weight , is the LM log-probability and is the number of words in the hypothesis . The word posteriors are estimated by scaling the confidences to sum to one for each system over all words in between nodes and . The system weights are also constrained to sum to one . Equation 6 may be viewed as a log-linear sum of sentencelevel features . The first feature is the sum of word log-posteriors , the second is the LM log-probability , the third is the log-NULL score and the last is the log-length score . The last two terms are not completely independent but seem to help based on experimental results . The number of paths through a confusion network grows exponentially with the number of nodes . Therefore expanding a network with a n - gram language model may result in huge lattices if is high . Instead of high order - grams with heavy pruning , a bi-gram may first be used to expand the lattice . After optimizing one set of weights for the expanded confusion network , a second set of weights for best list re-scoring with a higher order n - gram model may be optimized . On a test set , the first set of weights is used to generate an - best list from the bi-gram expanded lattice . This - best list is then re-scored with the higher order - gram . The second set of weights is used to find the final-best from the re-scored - best list . 5 Multiple Confusion Network Decoding As discussed in Section 3 , there is a disconnect between the skeleton selection and confidence estimation . To prevent the-best from a system with a low or zero weight being selected as the skeleton , confusion networks are generated for each system and the average TER score in Equation 4 is used to estimate a prior probability for the corresponding network . All confusion networks are connected to a single start node with NULL arcs which contain the prior probability from the system used as the skeleton for that network . All confusion network are connected to a common end node with NULL arcs . The final arcs have a probability of one . The prior probabilities in the arcs leaving the first node will be multiplied by the corresponding system weights which guarantees that a path through a network generated around a-best from a system with a zero weight will not be chosen . The prior probabilities are estimated by viewing the negative average TER scores between the skeleton and other hypotheses as log-probabilities . These log-probabilities are scaled so that the priors sum to one . There is a concern that the prior probabilities estimated this way may be inaccurate . Therefore , the priors may have to be smoothed by a tunable exponent . However , the optimization experiments showed that the best performance was obtained by having a smoothing factor of 1 which is equivalent to the original priors . Thus , no smoothing was used in the experiments presented later in this paper . An example joint network with the priors is shown in Figure 2 . This example has three confusion networks with priors , and . The total number of nodes in the network is represented by . Similar combination of multiple confusion networks was presented in ( Matusov et al. , 2006 ) . However , this approach did not include sentence specific prior estimates , word posterior estimates , and did not allow joint optimization of the system and feature weights . 6 Weights Optimization The optimization of the system and feature weights may be carried out using - best lists as in ( Ostendorf et al. , 1991 ) . A confusion network may be represented by a word lattice and standard tools may be used to generate - best hypothesis lists including word confidence scores , language model scores and other features . The - best list may be re-ordered using the sentence-level posteriors from Equation 6 for the th source sentence and the corresponding th hypothesis . The current - best hypothesis given a set of weights may be represented as follows The objective is to optimize the-best score on a development set given a set of reference translations . For example , estimating weights which minimize TER between a set of-best hypothesis and reference translations can be written as This objective function is very complicated , so gradient-based optimization methods may not be used . In this work , modified Powells method as proposed by ( Brent , 1973 ) is used . The algorithm explores better weights iteratively starting from a set of initial weights . First , each dimension is optimized using a grid-based line minimization algorithm . Then , a new direction based on the changes in the objective function is estimated to speed up the search . To improve the chances of finding a global optimum , 19 random perturbations of the initial weights are used in parallel optimization runs . Since the - best list represents only a small portion of all hypotheses in the confusion network , the optimized weights from one iteration may be used to generate a new - best list from the lattice for the next iteration . Similarly , weights which maximize BLEU or METEOR may be optimized . The same Powells method has been used to estimate feature weights of a standard feature-based phrasal MT decoder in ( Och , 2003 ) . A more efficient algorithm for log-linear models was also proposed . In this work , both the system and feature weights are jointly optimized , so the efficient algorithm for the log-linear models can not be used . 7 Results The improved system combination method was compared to a simple confusion network decoding without system weights and the method proposed in ( Rosti et al. , 2007 ) on the Arabic to English and Chinese to English NIST MT05 tasks . Six MT systems were combined : three ( A , C , E ) were phrasebased similar to ( Koehn , 2004 ) , two ( B , D ) were hierarchical similar to ( Chiang , 2005 ) and one ( F ) was syntax-based similar to ( Galley et al. , 2006 ) . All systems were trained on the same data and the outputs used the same tokenization . The decoder weights for systems A and B were tuned to optimize TER , and others were tuned to optimize BLEU . All decoder weight tuning was done on the NIST MT02 task . The joint confusion network was expanded with a bi-gram language model and a - best list was generated from the lattice for each tuning iteration . The system and feature weights were tuned on the union of NIST MT03 and MT04 tasks . All four reference translations available for the tuning and test sets were used . A first set of weights with the bigram LM was optimized with three iterations . A second set of weights was tuned for 5-gram - best list re-scoring . The bi-gram and 5 - gram English language models were trained on about 7 billion words . The final combination outputs were detokenized and cased before scoring . The tuning set results on the Arabic to English NIST MT03 + MT04 task are shown in Table 1 . The best score on each metric is shown in bold face fonts . The row labeled as no weights corresponds to Equation 5 with uniform system weights and zero NULL weight . The baseline corresponds to Equation 5 with TER tuned weights . The following three rows correspond to the improved confusion network decoding with different optimization metrics . As expected , the scores on the metric used in tuning are the best on that metric . Also , the combination results are better than any single system on all metrics in the case of TER and BLEU tuning . However , the METEOR tuning yields extremely high TER and low BLEU scores . This must be due to the higher weight on the recall compared to precision in the harmonic mean used to compute the METEOR score . Even though METEOR has been shown to be a good metric on a given MT output , tuning to optimize METEOR results in a high insertion rate and low precision . The Arabic test set results are shown in Table 2 . The TER and BLEU optimized combination results beat all single system scores on all metrics . The best results on a given metric are again obtained by the combination optimized for the corresponding metric . It should be noted that the TER optimized combination has significantly higher BLEU score than the TER optimized baseline . Compared to the baseline system which is also optimized for TER , the BLEU score is improved by 0.97 points . Also , the METEOR score using the METEOR optimized weights is very high . However , the other scores are worse in common with the tuning set results . The tuning set results on the Chinese to English NIST MT03 + MT04 task are shown in Table 3 . The baseline combination weights were tuned to optimize BLEU . Again , the best scores on each metric are obtained by the combination tuned for that metric . Only the METEOR score of the TER tuned combination is worse than the METEOR scores of systems E and F - other combinations are better than any single system on all metrics apart from the METEOR tuned combinations . The test set results follow clearly the tuning results again - the TER tuned combination is the best in terms of TER , the BLEU tuned in terms of BLEU , and the METEOR tuned in terms of METEOR . Compared to the baseline , the BLEU score of the BLEU tuned combination is improved by 1.47 points . Again , the METEOR tuned weights hurt the other metrics significantly . 8 Conclusions An improved confusion network decoding method combining the word posteriors with arbitrary features was presented . This allows the addition of language model scores by expanding the lattices or re-scoring - best lists . The LM integration should result in more grammatical combination outputs . Also , confusion networks generated by using the - best hypothesis from all systems as the skeleton were used with prior probabilities derived from the average TER scores . This guarantees that the best path will not be found from a network generated for a system with zero weight . Compared to the earlier system combination approaches , this method is fully automatic and requires very little additional information on top of the development set outputs from the individual systems to tune the weights . The new method was evaluated on the Arabic to English and Chinese to English NIST MT05 tasks . Compared to the baseline from ( Rosti et al . , 2007 ) , the new method improves the BLEU scores significantly . The combination weights were tuned to optimize three automatic evaluation metrics : TER , BLEU and METEOR . The TER tuning seems to yield very good results on Arabic - the BLEU tuning seems to be better on Chinese . It also seems like METEOR should not be used in tuning due to high insertion rate and low precision . It would be interesting to know which tuning metric results in the best translations in terms of human judgment . However , this would require time consuming evaluations such as human mediated TER post-editing ( Snover et al . , 2006 ) . The improved confusion network decoding approach allows arbitrary features to be used in the combination . New features may be added in the future . Hypothesis alignment is also very important in confusion network generation . Better alignment methods which take synonymy into account should be investigated . This method could also benefit from more sophisticated word posterior estimation . "}
  },
    {
    "id": "P08-1025",
    "result":     [
            {
        "value":         {
          "start": 150,
          "end": 182,
          "text": "synchronous context-free grammars",
          "labels": ["Method"]
        },
        "id": 594
      },
            {
        "value":         {
          "start": 213,
          "end": 234,
          "text": "n-gram language models",
          "labels": ["Method"]
        },
        "id": 440
      },
            {
        "value":         {
          "start": 260,
          "end": 280,
          "text": "bigram language model",
          "labels": ["Method"]
        },
        "id": 462
      },
            {
        "value":         {
          "start": 365,
          "end": 386,
          "text": "trigram language model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 686,
          "end": 689,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 1102,
          "end": 1122,
          "text": "n-gram language model",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 1140,
          "end": 1146,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 1356,
          "end": 1382,
          "text": "two-pass decoding algorithm",
          "labels": ["Method"]
        },
        "id": 445
      },
            {
        "value":         {
          "start": 1455,
          "end": 1475,
          "text": "bigram language model",
          "labels": ["Method"]
        },
        "id": 462
      },
            {
        "value":         {
          "start": 1560,
          "end": 1586,
          "text": "bigram-to-trigram technique",
          "labels": ["Method"]
        },
        "id": 446
      },
            {
        "value":         {
          "start": 1671,
          "end": 1690,
          "text": "bigram-based decoder",
          "labels": ["Method"]
        },
        "id": 447
      },
            {
        "value":         {
          "start": 1713,
          "end": 1734,
          "text": "trigram language model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 1854,
          "end": 1860,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 2185,
          "end": 2188,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2623,
          "end": 2626,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2664,
          "end": 2667,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2791,
          "end": 2823,
          "text": "Synchronous Context Free Grammars",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 2863,
          "end": 2883,
          "text": "n-gram language model",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 2937,
          "end": 2960,
          "text": "synchronous CFG ( SCFG )",
          "labels": ["Method"]
        },
        "id": 449
      },
            {
        "value":         {
          "start": 3079,
          "end": 3081,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 3141,
          "end": 3143,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 3187,
          "end": 3189,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 3232,
          "end": 3235,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 3612,
          "end": 3616,
          "text": "SCFGs",
          "labels": ["Method"]
        },
        "id": 454
      },
            {
        "value":         {
          "start": 3757,
          "end": 3787,
          "text": "Inversion Transduction Grammars",
          "labels": ["Method"]
        },
        "id": 453
      },
            {
        "value":         {
          "start": 3838,
          "end": 3841,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 4191,
          "end": 4195,
          "text": "SCFGs",
          "labels": ["Method"]
        },
        "id": 454
      },
            {
        "value":         {
          "start": 4224,
          "end": 4257,
          "text": "synchronous binarization technique",
          "labels": ["Method"]
        },
        "id": 454
      },
            {
        "value":         {
          "start": 4635,
          "end": 4638,
          "text": "CFGs",
          "labels": ["Method"]
        },
        "id": 455
      },
            {
        "value":         {
          "start": 4722,
          "end": 4724,
          "text": "ITG",
          "labels": ["Method"]
        },
        "id": 482
      },
            {
        "value":         {
          "start": 4764,
          "end": 4766,
          "text": "ITG",
          "labels": ["Method"]
        },
        "id": 482
      },
            {
        "value":         {
          "start": 4865,
          "end": 4885,
          "text": "n-gram language model",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 4904,
          "end": 4907,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 4936,
          "end": 4938,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 4965,
          "end": 4967,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 5033,
          "end": 5035,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 5478,
          "end": 5498,
          "text": "n-gram language model",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 5605,
          "end": 5610,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 6979,
          "end": 6982,
          "text": "HMMs",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 7746,
          "end": 7749,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 7919,
          "end": 7930,
          "text": "MaxEnt model",
          "labels": ["Method"]
        },
        "id": 457
      },
            {
        "value":         {
          "start": 7988,
          "end": 8011,
          "text": "trigram integrated model",
          "labels": ["Method"]
        },
        "id": 458
      },
            {
        "value":         {
          "start": 8043,
          "end": 8054,
          "text": "bigram model",
          "labels": ["Method"]
        },
        "id": 459
      },
            {
        "value":         {
          "start": 8144,
          "end": 8149,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 8713,
          "end": 8715,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 8766,
          "end": 8768,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 8918,
          "end": 8922,
          "text": "PCFGs",
          "labels": ["Method"]
        },
        "id": 461
      },
            {
        "value":         {
          "start": 8949,
          "end": 8952,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 8991,
          "end": 8993,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 8999,
          "end": 9001,
          "text": "ITG",
          "labels": ["Method"]
        },
        "id": 482
      },
            {
        "value":         {
          "start": 9108,
          "end": 9110,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 9481,
          "end": 9493,
          "text": "trigram model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 9503,
          "end": 9523,
          "text": "bigram language model",
          "labels": ["Method"]
        },
        "id": 462
      },
            {
        "value":         {
          "start": 9531,
          "end": 9552,
          "text": "trigram language model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 10040,
          "end": 10052,
          "text": "A * algorithm",
          "labels": ["Method"]
        },
        "id": 462
      },
            {
        "value":         {
          "start": 10099,
          "end": 10101,
          "text": "CKY",
          "labels": ["Method"]
        },
        "id": 463
      },
            {
        "value":         {
          "start": 10106,
          "end": 10108,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 11879,
          "end": 11885,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 12722,
          "end": 12727,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13078,
          "end": 13083,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13764,
          "end": 13770,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 13795,
          "end": 13801,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 13845,
          "end": 13850,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13997,
          "end": 14000,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 14413,
          "end": 14415,
          "text": "CYK",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 14928,
          "end": 14953,
          "text": "two-pass decoding approach",
          "labels": ["Method"]
        },
        "id": 466
      },
            {
        "value":         {
          "start": 16049,
          "end": 16052,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 16066,
          "end": 16071,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 16073,
          "end": 16081,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 16147,
          "end": 16154,
          "text": "4 - gram",
          "labels": ["Method"]
        },
        "id": 467
      },
            {
        "value":         {
          "start": 16270,
          "end": 16273,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 16328,
          "end": 16356,
          "text": "Minimum Bayesian Risk ( MBR )",
          "labels": ["Method"]
        },
        "id": 468
      },
            {
        "value":         {
          "start": 16430,
          "end": 16432,
          "text": "MBR",
          "labels": ["Method"]
        },
        "id": 469
      },
            {
        "value":         {
          "start": 16590,
          "end": 16603,
          "text": "trigram forest",
          "labels": ["Method"]
        },
        "id": 469
      },
            {
        "value":         {
          "start": 16680,
          "end": 16685,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 17121,
          "end": 17127,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 17223,
          "end": 17229,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 17331,
          "end": 17337,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 17389,
          "end": 17394,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 17431,
          "end": 17437,
          "text": "trigram",
          "labels": ["Method"]
        },
        "id": 980
      },
            {
        "value":         {
          "start": 17712,
          "end": 17742,
          "text": "LDC 2002 MT evaluation data set",
          "labels": ["Dataset"]
        },
        "id": 472
      },
            {
        "value":         {
          "start": 18034,
          "end": 18062,
          "text": "language-model-integrated ITG",
          "labels": ["Method"]
        },
        "id": 473
      },
            {
        "value":         {
          "start": 18174,
          "end": 18177,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18271,
          "end": 18281,
          "text": "IBM Model 4",
          "labels": ["Method"]
        },
        "id": 474
      },
            {
        "value":         {
          "start": 18353,
          "end": 18360,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 18492,
          "end": 18494,
          "text": "ISI",
          "labels": ["Dataset"]
        },
        "id": 475
      },
            {
        "value":         {
          "start": 18518,
          "end": 18526,
          "text": "FBIS data",
          "labels": ["Dataset"]
        },
        "id": 476
      },
            {
        "value":         {
          "start": 18625,
          "end": 18627,
          "text": "ITG",
          "labels": ["Method"]
        },
        "id": 482
      },
            {
        "value":         {
          "start": 18647,
          "end": 18648,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 19055,
          "end": 19069,
          "text": "CYK bigram pass",
          "labels": ["Method"]
        },
        "id": 477
      },
            {
        "value":         {
          "start": 19172,
          "end": 19182,
          "text": "bigram pass",
          "labels": ["Method"]
        },
        "id": 478
      },
            {
        "value":         {
          "start": 19192,
          "end": 19195,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19629,
          "end": 19636,
          "text": "trigrams",
          "labels": ["Method"]
        },
        "id": 973
      },
            {
        "value":         {
          "start": 19785,
          "end": 19788,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20203,
          "end": 20206,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20619,
          "end": 20627,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 20661,
          "end": 20663,
          "text": "CYK",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 20886,
          "end": 20888,
          "text": "cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 20897,
          "end": 20918,
          "text": "trigram-integrated CYK",
          "labels": ["Method"]
        },
        "id": 481
      },
            {
        "value":         {
          "start": 21202,
          "end": 21204,
          "text": "ITG",
          "labels": ["Method"]
        },
        "id": 482
      },
            {
        "value":         {
          "start": 21645,
          "end": 21653,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 21659,
          "end": 21661,
          "text": "cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 21854,
          "end": 21857,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21892,
          "end": 21900,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 21917,
          "end": 21919,
          "text": "CYK",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 22343,
          "end": 22345,
          "text": "CYK",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 22633,
          "end": 22641,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 22645,
          "end": 22656,
          "text": "bitri agenda",
          "labels": ["Method"]
        },
        "id": 485
      },
            {
        "value":         {
          "start": 22660,
          "end": 22673,
          "text": "bitri cyk hook",
          "labels": ["Method"]
        },
        "id": 483
      },
            {
        "value":         {
          "start": 22679,
          "end": 22695,
          "text": "bitri agenda hook",
          "labels": ["Method"]
        },
        "id": 485
      },
            {
        "value":         {
          "start": 22727,
          "end": 22729,
          "text": "CYK",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 22900,
          "end": 22916,
          "text": "bitri agenda hook",
          "labels": ["Method"]
        },
        "id": 485
      },
            {
        "value":         {
          "start": 22944,
          "end": 22955,
          "text": "bitri agenda",
          "labels": ["Method"]
        },
        "id": 485
      },
            {
        "value":         {
          "start": 23127,
          "end": 23135,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 23291,
          "end": 23294,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23580,
          "end": 23586,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 23741,
          "end": 23744,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23905,
          "end": 23908,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 23959,
          "end": 23981,
          "text": "bitri cyk epass me cons",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 23985,
          "end": 24007,
          "text": "bitri cyk epass me cons",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24020,
          "end": 24028,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24034,
          "end": 24036,
          "text": "cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24050,
          "end": 24053,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24174,
          "end": 24177,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24187,
          "end": 24209,
          "text": "bitri cyk epass me cons",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24230,
          "end": 24238,
          "text": "bitri cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24244,
          "end": 24246,
          "text": "cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24354,
          "end": 24357,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24470,
          "end": 24472,
          "text": "cyk",
          "labels": ["Method"]
        },
        "id": 486
      },
            {
        "value":         {
          "start": 24603,
          "end": 24606,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 24666,
          "end": 24672,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 24690,
          "end": 24695,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 24756,
          "end": 24762,
          "text": "trigram",
          "labels": ["Method"]
        },
        "id": 980
      },
            {
        "value":         {
          "start": 25042,
          "end": 25045,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25263,
          "end": 25266,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25423,
          "end": 25426,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25437,
          "end": 25442,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      }
    ],
    "data": {"text": "Efficient Multi-pass Decoding for Synchronous Context Free Grammars Abstract We take a multi-pass approach to machine translation decoding when using synchronous context-free grammars as the translation model and n-gram language models : the first pass uses a bigram language model , and the resulting parse forest is used in the second pass to guide search with a trigram language model . The trigram pass closes most of the performance gap between a bigram decoder and a much slower trigram decoder , but takes time that is insignificant in comparison to the bigram pass . An additional fast decoding pass maximizing the expected count of correct translation hypotheses increases the BLEU score significantly . 1 Introduction Statistical machine translation systems based on synchronous grammars have recently shown great promise , but one stumbling block to their widespread adoption is that the decoding , or search , problem during translation is more computationally demanding than in phrase-based systems . This complexity arises from the interaction of the tree-based translation model with an n-gram language model . Use of longer n-grams improves translation results , but exacerbates this interaction . In this paper , we present three techniques for attacking this problem in order to obtain fast , high-quality decoders . First , we present a two-pass decoding algorithm , in which the first pass explores states resulting from an integrated bigram language model , and the second pass expands these states into trigram-based states . The general bigram-to-trigram technique is common in speech recognition ( Murveit et al . , 1993 ) , where lattices from a bigram-based decoder are re-scored with a trigram language model . We examine the question of whether , given the reordering inherent in the machine translation problem , lower order n-grams will provide as valuable a search heuristic as they do for speech recognition . Second , we explore heuristics for agenda-based search , and present a heuristic for our second pass that combines precomputed language model information with information derived from the first pass . With this heuristic , we achieve the same BLEU scores and model cost as a trigram decoder with essentially the same speed as a bigram decoder . Third , given the significant speedup in the agenda-based trigram decoding pass , we can rescore the trigram forest to maximize the expected count of correct synchronous constituents of the model , using the product of inside and outside probabilities . Maximizing the expected count of synchronous constituents approximately maximizes BLEU . We find a significant increase in BLEU in the experiments , with minimal additional time . 2 Language Model Integrated Decoding for SCFG We begin by introducing Synchronous Context Free Grammars and their decoding algorithms when an n-gram language model is integrated into the grammatical search space . A synchronous CFG ( SCFG ) is a set of contextfree rewriting rules for recursively generating string pairs . Each synchronous rule is a pair of CFG rules with the nonterminals on the right hand side of one CFG rule being one-to-one mapped to the other CFG rule via a permutation 7r . We adopt the SCFG notation of Satta and Peserico ( 2005 ) . Superscript indices in the right-hand side of grammar rules : indicate that the nonterminals with the same index are linked across the two languages , and will eventually be rewritten by the same rule application . Each Xi is a variable which can take the value of any nonterminal in the grammar . In this paper , we focus on binary SCFGs and without loss of generality assume that only the preterminal unary rules can generate terminal string pairs . Thus , we are focusing on Inversion Transduction Grammars ( Wu , 1997 ) which are an important subclass of SCFG . Formally , the rules in our grammar include preterminal unary rules : for pairing up words or phrases in the two languages and binary production rules with straight or inverted orders that are responsible for building up upperlevel synchronous structures . They are straight rules written : and inverted rules written : Most practical non-binary SCFGs can be binarized using the synchronous binarization technique by Zhang et al . ( 2006 ) . The Hiero-style rules of ( Chiang , 2005 ) , which are not strictly binary but binary only on nonterminals : can be handled similarly through either offline binarization or allowing a fixed maximum number of gap words between the right hand side nonterminals in the decoder . For these reasons , the parsing problems for more realistic synchronous CFGs such as in Chiang ( 2005 ) and Galley et al . ( 2006 ) are formally equivalent to ITG . Therefore , we believe our focus on ITG for the search efficiency issue is likely to generalize to other SCFG-based methods . Without an n-gram language model , decoding using SCFG is not much different from CFG parsing . At each time a CFG rule is applied on the input string , we apply the synchronized CFG rule for the output language . From a dynamic programming point of view , the DP states are X [ i , j ] , where X ranges over all possible nonterminals and i and j range over 0 to the input string length | w | . Each state stores the best translations obtainable . When we reach the top state 5 [ 0 , | w | ] , we can get the best translation for the entire sentence . The algorithm is O ( | w | 3 ) . However , when we want to integrate an n-gram language model into the search , our goal is searching for the derivation whose total sum of weights of productions and n-gram log probabilities is maximized . Now the adjacent span-parameterized states X [ i , k ] and X [ k , j ] can interact with each other by peeping into the leading and trailing n 1 words on the output side for each state . Different boundary words differentiate the spanparameterized states . Thus , to preserve the dynamic programming property , we need to refine the states by adding the boundary words into the parameterization . The LM-integrated states are represented as X [ i , j , u1 , . . , n1 , v1 , . . , n1 ] . Since the number of variables involved at each DP step has increased to 3 + 4 ( n 1 ) , the decoding algorithm is asymptotically O ( | w | 3 +4 ( n1 ) ) . Although it is possible to use the hook trick of Huang et al. ( 2005 ) to factorize the DP operations to reduce the complexity to O ( | w | 3 +3 ( n1 ) ) , when n is greater than 2 , the complexity is still prohibitive . 3 Multi-pass LM-Integrated Decoding In this section , we describe a multi-pass progressive decoding technique that gradually augments the LM-integrated states from lower orders to higher orders . For instance , a bigram-integrated state [ X , i , j , u , v ] is said to be a coarse-level state of a trigram-integrate state [ X , i , j , u , u , v , v ] , because the latter state refines the previous by specifying more inner words . Progressive search has been used for HMMs in speech recognition ( Murveit et al . , 1993 ) . The gen eral idea is to use a simple and fast decoding algorithm to constrain the search space of a following more complex and slower technique . More specifically , a bigram decoding pass is executed forward and backward to figure out the probability of each state . Then the states can be pruned based on their global score using the product of inside and outside probabilities . The advanced decoding algorithm will use the constrained space ( a lattice in the case of speech recognition ) as a grammatical constraint to help it focus on a smaller search space on which more discriminative features are brought in . The same idea has been applied to forests for parsing . Charniak and Johnson ( 2005 ) use a PCFG to do a pass of inside-outside parsing to reduce the state space of a subsequent lexicalized n-best parsing algorithm to produce parses that are further re-ranked by a MaxEnt model . We take the same view as in speech recognition that a trigram integrated model is a finer-grained model than bigram model and in general we can do an n 1 - gram decoding as a predicative pass for the following n-gram pass . We need to do insideoutside parsing as coarse-to-fine parsers do . However , we use the outside probability or cost information differently . We do not combine the inside and outside costs of a simpler model to prune the space for a more complex model . Instead , for a given finergained state , we combine its true inside cost with the outside cost of its coarse-level counter-part to estimate its worthiness of being explored . The use of the outside cost from a coarser-level as the outside estimate makes our method naturally fall in the framework of A * parsing . Klein and Manning ( 2003 ) describe an A * parsing framework for monolingual parsing and admissible outside estimates that are computed using inside / outside parsing algorithm on simplified PCFGs compared to the original PCFG . Zhang and Gildea ( 2006 ) describe A * for ITG and develop admissible heuristics for both alignment and decoding . Both have shown the effectiveness of A * in situations where the outside estimate approximates the true cost closely such as when the sentences are short . For decoding long sentences , it is difficult to come up with good admissible ( or inadmissible ) heuristics . If we can afford a bigram decoding pass , the outside cost from a bigram model is conceivably a very good estimate of the outside cost using a trigram model since a bigram language model and a trigram language model must be strongly correlated . Although we lose the guarantee that the bigram-pass outside estimate is admissible , we expect that it approximates the outside cost very closely , thus very likely to effectively guide the heuristic search . 3.1 Inside-outside Coarse Level Decoding We describe the coarse level decoding pass in this section . The decoding algorithms for the coarse level and the fine level do not necessarily have to be the same . The fine level decoding algorithm is an A * algorithm . The coarse level decoding algorithm can be CKY or A * or other alternatives . Conceptually , the algorithm is finding the shortest hyperpath in the hypergraph in which the nodes are states like X [ i , j , u1 , . . , n1 , v1 , . . , n1 ] , and the hyperedges are the applications of the synchronous rules to go from right-hand side states to left-hand side states . The root of the hypergraph is a special node 5 [ 0 , jwj , ( s ) , ( / s ) ] which means the entire input sentence has been translated to a string starting with the beginning-of-sentence symbol and ending at the end-of-sentence symbol . If we imagine a starting node that goes to all possible basic translation pairs , i.e. , the instances of the terminal translation rules for the input , we are searching the shortest hyper path from the imaginary bottom node to the root . To help our outside parsing pass , we store the backpointers at each step of exploration . The outside parsing pass , however , starts from the root 5 [ jwj , ( s ) , ( / s ) ] and follows the back-pointers downward to the bottom nodes . The nodes need to be visited in a topological order so that whenever a node is visited , its parents have been visited and its outside cost is over all possible outside parses . The algorithm is described in pseudocode in Algorithm 1 . The number of hyperedges to traverse is much fewer than in the inside pass because not every state explored in the bottom up inside pass can finally reach the goal . As for normal outside parsing , the operations are the reverse of inside parsing . We propagate the outside cost of the parent to its children by combining with the inside cost of the other children and the interaction cost , i.e. , the language model cost between the focused child and the other children . Since we want to approximate the Viterbi outside cost , it makes sense to maximize over all possible outside costs for a given node , to be consistent with the maximization of the inside pass . For the nodes that have been explored in the bottom up pass but not in the top-down pass , we set their outside cost to be infinity so that their exploration is preferred only when the viable nodes from the first pass have all been explored in the fine pass . 3.2 Heuristics for Fine-grained Decoding In this section , we summarize the heuristics for finer level decoding . The motivation for combining the true inside cost of the fine-grained model and the outside estimate given by the coarse-level parsing is to approximate the true global cost of a fine-grained state as closely as possible . We can make the approximation even closer by incorporating local higherorder outside n-gram information for a state of X [ i , j , u1 , . . , n1 , v1 , . . , n1 ] into account . We call this the best-border estimate . For example , the bestborder estimate for trigram states is : where S ( i , j ) is the set of candidate target language words outside the span of ( i , j ) . hBB is the product of the upper bounds for the two on-the-border n-grams . This heuristic function was one of the admissible heuristics used by Zhang and Gildea ( 2006 ) . The benefit of including the best-border estimate is to refine the outside estimate with respect to the inner words which refine the bigram states into the trigram states . If we do not take the inner words into consideration when computing the outside cost , all states that map to the same coarse level state would have the same outside cost . When the simple best-border estimate is combined with the coarse-level outside estimate , it can further boost the search as will be shown in the experiments . To summarize , our recipe for faster decoding is that using where is the Viterbi inside cost and is the Viterbi outside cost , to globally prioritize the n-gram integrated states on the agenda for exploration . 3.3 Alternative Efficient Decoding Algorithms The complexity of n-gram integrated decoding for SCFG has been tackled using other methods . The hook trick of Huang et al. ( 2005 ) factorizes the dynamic programming steps and lowers the asymptotic complexity of the n-gram integrated decoding , but has not been implemented in large-scale systems where massive pruning is present . The cube-pruning by Chiang ( 2007 ) and the lazy cube-pruning of Huang and Chiang ( 2007 ) turn the computation of beam pruning of CYK decoders into a top-k selection problem given two columns of translation hypotheses that need to be combined . The insight for doing the expansion top-down lazily is that there is no need to uniformly explore every cell . The algorithm starts with requesting the first best hypothesis from the root . The request translates into requests for the k-bests of some of its children and grandchildren and so on , because re-ranking at each node is needed to get the top ones . Venugopal et al . ( 2007 ) also take a two-pass decoding approach , with the first pass leaving the language model boundary words out of the dynamic programming state , such that only one hypothesis is retained for each span and grammar symbol . 4 Decoding to Maximize BLEU if X → [Y Z] then D the two children are Y [i, k, u, u′] and Z[k, j, v′, v] α(Y [i, k, u, u′]) = max {α(Y [i, k, u, u′]), The ultimate goal of efficient decoding to find the translation that has a highest evaluation score using the least time possible . Section 3 talks about utilizing the outside cost of a lower-order model to estimate the outside cost of a higher-order model , boosting the search for the higher-order model . By doing so , we hope the intrinsic metric of our model agrees with the extrinsic metric of evaluation so that fast search for the model is equivalent to efficient decoding . But the mismatch between the two is evident , as we will see in the experiments . In this section , we deal with the mismatch by introducing another decoding pass that maximizes the expected count of synchronous constituents in the tree corresponding to the translation returned . BLEU is based on n-gram precision , and since each synchronous constituent in the tree adds a new 4 - gram to the translation at the point where its children are concatenated , the additional pass approximately maximizes BLEU . Kumar and Byrne ( 2004 ) proposed the framework of Minimum Bayesian Risk ( MBR ) decoding that minimizes the expected loss given a loss function . Their MBR decoding is a reranking pass over an nbest list of translations returned by the decoder . Our algorithm is another dynamic programming decoding pass on the trigram forest , and is similar to the parsing algorithm for maximizing expected labelled recall presented by Goodman ( 1996 ) . 4.1 Maximizing the expected count of correct synchronous constituents We introduce an algorithm that maximizes the expected count of correct synchronous constituents . Given a synchronous constituent specified by the state [ X , i , j , u , u , v , v ] , its probability of being correct in the model is where is the outside probability and O is the inside probability . We approximate O and using the Viterbi probabilities . Since decoding from bottom up in the trigram pass already gives us the inside Viterbi scores , we only have to visit the nodes in the reverse order once we reach the root to compute the Viterbi outside scores . The outside-pass Algorithm 1 for bigram decoding can be generalized to the trigram case . We want to maximize over all translations ( synchronous trees ) T in the forest after the trigram decoding pass according to The expression can be factorized and computed using dynamic programming on the forest . 5 Experiments We did our decoding experiments on the LDC 2002 MT evaluation data set for translation of Chinese newswire sentences into English . The evaluation data set has 10 human translation references for each sentence . There are a total of 371 Chinese sentences of no more than 20 words in the data set . These sentences are the test set for our different versions of language-model-integrated ITG decoders . We evaluate the translation results by comparing them against the reference translations using the BLEU metric . max T The word-to-word translation probabilities are from the translation model of IBM Model 4 trained on a 160 - million-word English-Chinese parallel corpus using GIZA + + . The phrase-to-phrase translation probabilities are trained on 833K parallel sentences . 758K of this was data made available by ISI , and another 75K was FBIS data . The language model is trained on a 30-million-word English corpus . The rule probabilities for ITG are trained using EM on a corpus of 18,773 sentence pairs with a total of 276,113 Chinese words and 315,415 English words . 5.1 Bigram-pass Outside Cost as Trigram-pass Outside Estimate We first fix the beam for the bigram pass , and change the outside heuristics for the trigram pass to show the difference before and after using the first-pass outside cost estimate and the border estimate . We choose the beam size for the CYK bigram pass to be 10 on the log scale . The first row of Table 1 shows the number of explored hyperedges for the bigram pass and its BLEU score . In the rows below , we compare the additional numbers of hyperedges that need to be explored in the trigram pass using different outside heuristics . It takes too long to finish using uniform outside estimate ; we have to use a tight beam to control the agenda-based exploration . Using the bigram outside cost estimate makes a huge difference . Furthermore , using Equation 1 , adding the additional heuristics on the best trigrams that can appear on the borders of the current hypothesis , on average we only need to explore 2700 additional hyperedges per sentence to boost the BLEU score from 21.77 to 23.46 . The boost is so significant that overall the dominant part of search time is no longer the second pass but the first bigram pass ( inside pass actually ) which provides a constrained space and outside heuristics for the second pass . 5.2 Two-pass decoding versus One-pass decoding By varying the beam size for the first pass , we can plot graphs of model scores versus search time and BLEU scores versus search time as shown in Figure 1 . We use a very large beam for the second pass due to the reason that the outside estimate for the second pass is discriminative enough to guide the search . We sum up the total number of seconds for both passes to compare with the baseline systems . On average , less than 5 % of time is spent in the second pass . In Figure 1 , we have four competing decoders . bitri cyk is our two-pass decoder , using CYK as the first pass decoding algorithm and using agendabased decoding in the second pass which is guided by the first pass . agenda is our trigram-integrated agenda-based decoder . The other two systems are also one-pass . cyk is our trigram-integrated CYK decoder . lazy kbest is our top-down k-best-style decoder .1 Figure 1 ( left ) compares the search efficiencies of the four systems . bitri cyk at the top ranks first . cyk follows it . The curves of lazy kbest and agenda cross 1In our implementation of the lazy-cube-pruning based ITG decoder , we vary the re-ranking buffer size and the the top-k list size which are the two controlling parameters for the search space . But we did not use any LM estimate to achieve early stopping as suggested by Huang and Chiang ( 2007 ) . Also , we did not have a translation-model-only pruning pass . So the results shown in this paper for the lazy cube pruning method is not of its best performance . and are both below the curves of bitri cyk and cyk . This figure indicates the advantage of the two-pass decoding strategy in producing translations with a high model score in less time . However , model scores do not directly translate into BLEU scores . In Figure 1 ( right ) , bitri cyk is better than CYK only in a certain time window when the beam is neither too small nor too large . But the window is actually where we are interested it ranges from 5 seconds per sentence to 20 seconds per sentence . Table 2 summarizes the performance of the four decoders when the decoding speed is at 10 seconds per sentence . 5.3 Does the hook trick help? We have many choices in implementing the bigram decoding pass . We can do either CYK or agendabased decoding . We can also use the dynamic programming hook trick . We are particularly interested in the effect of the hook trick in a large-scale system with aggressive pruning . Figure 2 compares the four possible combinations of the decoding choices for the first pass : bitri cyk , bitri agenda , bitri cyk hook and bitri agenda hook . bitri cyk which simply uses CYK as the first pass decoding algorithm is the best in terms of performance and time trade-off . The hook-based decoders do not show an advantage in our experiments . Only bitri agenda hook gets slightly better than bitri agenda when the beam size increases . So , it is very likely the overhead of building hooks offsets its benefit when we massively prune the hypotheses . 5.4 Maximizing BLEU The bitri cyk decoder spends little time in the agenda-based trigram pass , quickly reaching the goal item starting from the bottom of the chart . In order to maximize BLEU score using the algorithm described in Section 4 , we need a sizable trigram forest as a starting point . Therefore , we keep popping off more items from the agenda after the goal is reached . Simply by exploring more ( 200 times the log beam ) after-goal items , we can optimize the Viterbi synchronous parse significantly , shown in Figure 3 ( left ) in terms of model score versus search time . However , the mismatch between model score and BLEU score persists . So , we try our algorithm of maximizing expected count of synchronous constituents on the trigram forest . We find significant improvement in BLEU , as shown in Figure 3 ( right ) by the curve of bitri cyk epass me cons . bitri cyk epass me cons beats both bitri cyk and cyk in terms of BLEU versus time if using more than 1.5 seconds on average to decode each sentence . At each time point , the difference in BLEU between bitri cyk epass me cons and the highest of bitri cyk and cyk is around .5 points consistently as we vary the beam size for the first pass . We achieve the record-high BLEU score 24.34 using on average 21 seconds per sentence , compared to the next-highest score of 23.92 achieved by cyk using on average 78 seconds per sentence . 6 Conclusion We present a multi-pass method to speed up ngram integrated decoding for SCFG . We use an inside / outside parsing algorithm to get the Viterbi outside cost of bigram integrated states which is used as an outside estimate for trigram integrated states . The coarse-level outside cost plus the simple estimate for border trigrams speeds up the trigram decoding pass hundreds of times compared to using no outside estimate . Maximizing the probability of the synchronous derivation is not equivalent to maximizing BLEU . We use a rescoring decoding pass that maximizes the expected count of synchronous constituents . This technique , together with the progressive search at previous stages , gives a decoder that produces the highest BLEU score we have obtained on the data in a very reasonable amount of time . As future work , new metrics for the final pass may be able to better approximate BLEU . As the bigram decoding pass currently takes the bulk of the decoding time , better heuristics for this phase may speed up the system further . Acknowledgments This work was supported by NSF ITR-0428020 and NSF IIS-0546554 . "}
  },
    {
    "id": "P09-1057",
    "result":     [
            {
        "value":         {
          "start": 271,
          "end": 272,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 711,
          "end": 751,
          "text": "Expectation Maximization ( EM ) algorithm",
          "labels": ["Method"]
        },
        "id": 529
      },
            {
        "value":         {
          "start": 847,
          "end": 862,
          "text": "Bayesian methods",
          "labels": ["Method"]
        },
        "id": 540
      },
            {
        "value":         {
          "start": 1150,
          "end": 1157,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 1455,
          "end": 1467,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 1661,
          "end": 1673,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 2112,
          "end": 2127,
          "text": "n-gram tag model",
          "labels": ["Method"]
        },
        "id": 531
      },
            {
        "value":         {
          "start": 2217,
          "end": 2236,
          "text": "word-given-tag model",
          "labels": ["Method"]
        },
        "id": 532
      },
            {
        "value":         {
          "start": 2329,
          "end": 2359,
          "text": "expectation-maximization ( EM )",
          "labels": ["Method"]
        },
        "id": 533
      },
            {
        "value":         {
          "start": 2534,
          "end": 2541,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2547,
          "end": 2548,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 2557,
          "end": 2574,
          "text": "3 - gram tag model",
          "labels": ["Method"]
        },
        "id": 540
      },
            {
        "value":         {
          "start": 2661,
          "end": 2677,
          "text": "Bayesian approach",
          "labels": ["Method"]
        },
        "id": 534
      },
            {
        "value":         {
          "start": 2901,
          "end": 2932,
          "text": "contrastive estimation technique",
          "labels": ["Method"]
        },
        "id": 535
      },
            {
        "value":         {
          "start": 2999,
          "end": 3001,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 3077,
          "end": 3111,
          "text": "Bayesian LDA-based generative model",
          "labels": ["Method"]
        },
        "id": 537
      },
            {
        "value":         {
          "start": 3251,
          "end": 3258,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 3340,
          "end": 3352,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 3430,
          "end": 3431,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4054,
          "end": 4066,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 4146,
          "end": 4147,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4156,
          "end": 4173,
          "text": "2 - gram tag model",
          "labels": ["Method"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 4199,
          "end": 4206,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 4235,
          "end": 4248,
          "text": "3 - gram model",
          "labels": ["Method"]
        },
        "id": 539
      },
            {
        "value":         {
          "start": 4266,
          "end": 4267,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4276,
          "end": 4293,
          "text": "3 - gram tag model",
          "labels": ["Method"]
        },
        "id": 540
      },
            {
        "value":         {
          "start": 4382,
          "end": 4399,
          "text": "2 - gram tag model",
          "labels": ["Method"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 4477,
          "end": 4478,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4501,
          "end": 4502,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4560,
          "end": 4561,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4739,
          "end": 4754,
          "text": "Bayesian methods",
          "labels": ["Method"]
        },
        "id": 540
      },
            {
        "value":         {
          "start": 4874,
          "end": 4875,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 4902,
          "end": 4903,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 5103,
          "end": 5104,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 5351,
          "end": 5352,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 5474,
          "end": 5475,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 5586,
          "end": 5587,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 5770,
          "end": 5771,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 6097,
          "end": 6098,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 7842,
          "end": 7849,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8091,
          "end": 8104,
          "text": "CPLEX software",
          "labels": ["Tool"]
        },
        "id": 540
      },
            {
        "value":         {
          "start": 8192,
          "end": 8199,
          "text": "lp solve",
          "labels": ["Tool"]
        },
        "id": 541
      },
            {
        "value":         {
          "start": 8327,
          "end": 8331,
          "text": "CPLEX",
          "labels": ["Tool"]
        },
        "id": 547
      },
            {
        "value":         {
          "start": 8468,
          "end": 8476,
          "text": "IP solver",
          "labels": ["Tool"]
        },
        "id": 544
      },
            {
        "value":         {
          "start": 8703,
          "end": 8707,
          "text": "CPLEX",
          "labels": ["Tool"]
        },
        "id": 547
      },
            {
        "value":         {
          "start": 8877,
          "end": 8885,
          "text": "IP solver",
          "labels": ["Tool"]
        },
        "id": 544
      },
            {
        "value":         {
          "start": 8977,
          "end": 8984,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 9020,
          "end": 9027,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 9059,
          "end": 9063,
          "text": "CPLEX",
          "labels": ["Tool"]
        },
        "id": 547
      },
            {
        "value":         {
          "start": 9281,
          "end": 9289,
          "text": "IP method",
          "labels": ["Method"]
        },
        "id": 544
      },
            {
        "value":         {
          "start": 9526,
          "end": 9537,
          "text": "CPLEX solver",
          "labels": ["Tool"]
        },
        "id": 545
      },
            {
        "value":         {
          "start": 9688,
          "end": 9689,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 9716,
          "end": 9717,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 9879,
          "end": 9880,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 9913,
          "end": 9920,
          "text": "accurate",
          "labels": ["Metric"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 10347,
          "end": 10351,
          "text": "CPLEX",
          "labels": ["Tool"]
        },
        "id": 547
      },
            {
        "value":         {
          "start": 10361,
          "end": 10362,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 10387,
          "end": 10394,
          "text": "accurate",
          "labels": ["Metric"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 10486,
          "end": 10492,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 10516,
          "end": 10523,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 10719,
          "end": 10720,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 10854,
          "end": 10862,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 10868,
          "end": 10873,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 10954,
          "end": 10962,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 11010,
          "end": 11011,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11025,
          "end": 11031,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 11171,
          "end": 11176,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 11180,
          "end": 11181,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11192,
          "end": 11198,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 11302,
          "end": 11310,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 11314,
          "end": 11315,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11326,
          "end": 11332,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 11346,
          "end": 11351,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 11355,
          "end": 11356,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11367,
          "end": 11373,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 11393,
          "end": 11394,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11531,
          "end": 11532,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11654,
          "end": 11655,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11700,
          "end": 11701,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 11936,
          "end": 11944,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 12074,
          "end": 12081,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 12177,
          "end": 12178,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 12292,
          "end": 12293,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 12449,
          "end": 12454,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 12654,
          "end": 12660,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 12682,
          "end": 12683,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 12892,
          "end": 12893,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 13019,
          "end": 13020,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 13041,
          "end": 13042,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 13290,
          "end": 13291,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 13552,
          "end": 13559,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 13734,
          "end": 13741,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 14168,
          "end": 14169,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 14473,
          "end": 14481,
          "text": "precision",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14518,
          "end": 14523,
          "text": "recall",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 14657,
          "end": 14665,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14669,
          "end": 14674,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 14810,
          "end": 14818,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14853,
          "end": 14858,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 14944,
          "end": 14952,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14956,
          "end": 14961,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 15090,
          "end": 15091,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 15192,
          "end": 15193,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 15226,
          "end": 15243,
          "text": "2 - gram tag model",
          "labels": ["Method"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 15256,
          "end": 15263,
          "text": "accurate",
          "labels": ["Metric"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 15373,
          "end": 15380,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15426,
          "end": 15427,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 15497,
          "end": 15504,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 15715,
          "end": 15732,
          "text": "Penn Treebank data",
          "labels": ["Dataset"]
        },
        "id": 548
      },
            {
        "value":         {
          "start": 16151,
          "end": 16152,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 16257,
          "end": 16269,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 16296,
          "end": 16297,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 16318,
          "end": 16324,
          "text": "Model 5",
          "labels": ["Method"]
        },
        "id": 549
      },
            {
        "value":         {
          "start": 16423,
          "end": 16430,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16989,
          "end": 17001,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 17159,
          "end": 17166,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17316,
          "end": 17325,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 17561,
          "end": 17577,
          "text": "InitEM-HMM system",
          "labels": ["Method"]
        },
        "id": 550
      },
            {
        "value":         {
          "start": 17621,
          "end": 17628,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17658,
          "end": 17671,
          "text": "LDA + AC model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 17809,
          "end": 17835,
          "text": "Bayesian HMM ( BHMM ) model",
          "labels": ["Method"]
        },
        "id": 552
      },
            {
        "value":         {
          "start": 17877,
          "end": 17939,
          "text": "CE + spl model ( Contrastive Estimation with a spelling model )",
          "labels": ["Method"]
        },
        "id": 553
      },
            {
        "value":         {
          "start": 17985,
          "end": 17994,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 18048,
          "end": 18054,
          "text": "IP + EM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 18093,
          "end": 18094,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 18115,
          "end": 18122,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18141,
          "end": 18148,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18171,
          "end": 18178,
          "text": "Init-HMM",
          "labels": ["Method"]
        },
        "id": 554
      },
            {
        "value":         {
          "start": 18184,
          "end": 18191,
          "text": "LDA + AC",
          "labels": ["Method"]
        },
        "id": 555
      },
            {
        "value":         {
          "start": 18270,
          "end": 18282,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 18290,
          "end": 18303,
          "text": "IP + EM models",
          "labels": ["Method"]
        },
        "id": 556
      },
            {
        "value":         {
          "start": 18386,
          "end": 18398,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 18516,
          "end": 18525,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 18535,
          "end": 18547,
          "text": "IP + EM model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 18598,
          "end": 18599,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 18823,
          "end": 18830,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20223,
          "end": 20254,
          "text": "trained P ( tag I suffix ) model",
          "labels": ["Method"]
        },
        "id": 558
      },
            {
        "value":         {
          "start": 20831,
          "end": 20832,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 21485,
          "end": 21498,
          "text": "IP + EM method",
          "labels": ["Method"]
        },
        "id": 559
      },
            {
        "value":         {
          "start": 21562,
          "end": 21575,
          "text": "LDA + AC model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 21583,
          "end": 21596,
          "text": "LDA + AC model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 21847,
          "end": 21859,
          "text": "IP + EM model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 22135,
          "end": 22136,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 24397,
          "end": 24404,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24460,
          "end": 24467,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24598,
          "end": 24599,
          "text": "EM",
          "labels": ["Method"]
        },
        "id": 560
      }
    ],
    "data": {"text": "Minimized Models for Unsupervised Part-of-Speech Tagging Abstract We describe a novel method for the task of unsupervised POS tagging with a dictionary , one that uses integer programming to explicitly search for the smallest model that explains the data , and then uses EM to set parameter values . We evaluate our method on a standard test corpus using different standard tagsets ( a 45-tagset as well as a smaller 17-tagset ) , and show that our approach performs better than existing state-of-the-art systems in both settings . 1 Introduction In recent years , we have seen increased interest in using unsupervised methods for attacking different NLP tasks like part-of-speech ( POS ) tagging . The classic Expectation Maximization ( EM ) algorithm has been shown to perform poorly on POS tagging , when compared to other techniques , such as Bayesian methods . In this paper , we develop new methods for unsupervised part-of-speech tagging . We adopt the problem formulation of Merialdo ( 1994 ) , in which we are given a raw word sequence and a dictionary of legal tags for each word type . The goal is to tag each word token so as to maximize accuracy against a gold tag sequence . Whether this is a realistic problem set-up is arguable , but an interesting collection of methods and results has accumulated around it , and these can be clearly compared with one another . We use the standard test set for this task , a 24,115 - word subset of the Penn Treebank , for which a gold tag sequence is available . There are 5,878 word types in this test set . We use the standard tag dictionary , consisting of 57,388 word / tag pairs derived from the entire Penn Treebank . 8,910 dictionary entries are relevant to the 5,878 word types in the test set . Per-token ambiguity is about 1.5 tags/token , yielding approximately 106425 possible ways to tag the data . There are 45 distinct grammatical tags . In this set-up , there are no unknown words . Figure 1 shows prior results for this problem . While the methods are quite different , they all make use of two common model elements . One is a probabilistic n-gram tag model P ( ti | tin + 1 . . . ti1 ) , which we call the grammar . The other is a probabilistic word-given-tag model P ( wi | ti ) , which we call the dictionary . The classic approach ( Merialdo , 1994 ) is expectation-maximization ( EM ) , where we estimate grammar and dictionary probabilities in order to maximize the probability of the observed word sequence : Goldwater and Griffiths ( 2007 ) report 74.5 % accuracy for EM with a 3 - gram tag model , which we confirm by replication . They improve this to 83.9 % by employing a fully Bayesian approach which integrates over all possible parameter values , rather than estimating a single distribution . They further improve this to 86.8 % by using priors that favor sparse distributions . Smith and Eisner ( 2005 ) employ a contrastive estimation technique , in which they automatically generate negative examples and use CRF training . In more recent work , Toutanova and Johnson ( 2008 ) propose a Bayesian LDA-based generative model that in addition to using sparse priors , explicitly groups words into ambiguity classes . They show considerable improvements in tagging accuracy when using a coarser-grained version ( with 17 - tags ) of the tag set from the Penn Treebank . Goldberg et al . ( 2008 ) depart from the Bayesian framework and show how EM can be used to learn good POS taggers for Hebrew and English , when provided with good initial conditions . They use language specific information ( like word contexts , syntax and morphology ) for learning initial P ( t | w ) distributions and also use linguistic knowledge to apply constraints on the tag sequences allowed by their models ( e.g. , the tag sequence V V is disallowed ) . Also , they make other manual adjustments to reduce noise from the word/tag dictionary ( e.g. , reducing the number of tags for the from six to just one ) . In contrast , we keep all the original dictionary entries derived from the Penn Treebank data for our experiments . The literature omits one other baseline , which is EM with a 2 - gram tag model . Here we obtain 81.7 % accuracy , which is better than the 3 - gram model . It seems that EM with a 3 - gram tag model runs amok with its freedom . For the rest of this paper , we will limit ourselves to a 2 - gram tag model . 2 What goes wrong with EM? We analyze the tag sequence output produced by EM and try to see where EM goes wrong . The overall POS tag distribution learnt by EM is relatively uniform , as noted by Johnson ( 2007 ) , and it tends to assign equal number of tokens to each tag label whereas the real tag distribution is highly skewed . The Bayesian methods overcome this effect by using priors which favor sparser distributions . But it is not easy to model such priors into EM learning . As a result , EM exploits a lot of rare tags ( like FW = foreign word , or SYM = symbol ) and assigns them to common word types ( in , of , etc . ) . We can compare the tag assignments from the gold tagging and the EM tagging ( Viterbi tag sequence ) . The table below shows tag assignments ( and their counts in parentheses ) for a few word types which occur frequently in the test corpus . We see how the rare tag labels ( like FW , SYM , etc . ) are abused by EM . As a result , many word tokens which occur very frequently in the corpus are incorrectly tagged with rare tags in the EM tagging output . We also look at things more globally . We investigate the Viterbi tag sequence generated by EM training and count how many distinct tag bigrams there are in that sequence . We call this the observed grammar size , and it is 915 . That is , in tagging the 24,115 test tokens , EM uses 915 of the available 45 x 45 = 2025 tag bigrams . The advantage of the observed grammar size is that we sequence . Here , we show a sample word sequence and the corresponding IP network generated for that sequence . can compare it with the gold taggings observed grammar size , which is 760 . So we can safely say that EM is learning a grammar that is too big , still abusing its freedom . 3 Small Models Bayesian sparse priors aim to create small models . We take a different tack in the paper and directly ask : What is the smallest model that explains the text ? Our approach is related to minimum description length ( MDL ) . We formulate our question precisely by asking which tag sequence ( of the 106425 available ) has the smallest observed grammar size . The answer is 459 . That is , there exists a tag sequence that contains 459 distinct tag bigrams , and no other tag sequence contains fewer . We obtain this answer by formulating the problem in an integer programming ( IP ) framework . Figure 2 illustrates this with a small sample word sequence . We create a network of possible taggings , and we assign a binary variable to each link in the network . We create constraints to ensure that those link variables receiving a value of 1 form a left-to-right path through the tagging network , and that all other link variables receive a value of 0 . We accomplish this by requiring the sum of the links entering each node to equal to the sum of the links leaving each node . We also create variables for every possible tag bigram and word/tag dictionary entry . We constrain link variable assignments to respect those grammar and dictionary variables . For example , we do not allow a link variable to activate unless the corresponding grammar variable is also activated . Finally , we add an objective function that minimizes the number of grammar variables that are assigned a value of 1 . Figure 3 shows the IP solution for the example word sequence from Figure 2 . Of course , a small grammar size does not necessarily correlate with higher tagging accuracy . For the small toy example shown in Figure 3 , the correct tagging is PRO AUX V . PRO V ( with 5 tag pairs ) , whereas the IP tries to minimize the grammar size and picks another solution instead . For solving the integer program , we use CPLEX software ( a commercial IP solver package ) . Alternatively , there are other programs such as lp solve , which are free and publicly available for use . Once we create an integer program for the full test corpus , and pass it to CPLEX , the solver returns an sponding grammar sizes for the sample word sequence from Figure 2 using the given dictionary and grammar . The IP solver finds the smallest grammar set that can explain the given word sequence . In this example , there exist two solutions that each contain only 4 tag pair entries , and IP returns one of them . objective function value of 459.3 CPLEX also returns a tag sequence via assignments to the link variables . However , there are actually 104378 tag sequences compatible with the 459 - sized grammar , and our IP solver just selects one at random . We find that of all those tag sequences , the worst gives an accuracy of 50.8 % , and the best gives an accuracy of 90.3 % . We also note that CPLEX takes 320 seconds to return the optimal solution for the integer program corresponding to this particular test data ( 24,115 tokens with the 45 - tag set ) . It might be interesting to see how the performance of the IP method ( in terms of time complexity ) is affected when scaling up to larger data and bigger tagsets . We leave this as part of future work . But we do note that it is possible to obtain less than optimal solutions faster by interrupting the CPLEX solver . 4 Fitting the Model Our IP formulation can find us a small model , but it does not attempt to fit the model to the data . Fortunately , we can use EM for that . We still give EM the full word / tag dictionary , but now we constrain its initial grammar model to the 459 tag bigrams identified by IP . Starting with uniform probabilities , EM finds a tagging that is 84.5 % accurate , substantially better than the 81.7 % originally obtained with the fully-connected grammar . So we see a benefit to our explicit small-model approach . While EM does not find the most accurate 3Note that the grammar identified by IP is not uniquely minimal . For the same word sequence , there exist other minimal grammars having the same size ( 459 entries ) . In our experiments , we choose the first solution returned by CPLEX . While EM does not find the most accurate sequence consistent with the IP grammar ( 90.3 % ) , it finds a relatively good one . The IP + EM tagging ( with 84.5 % accuracy ) has some interesting properties . First , the dictionary we observe from the tagging is of higher quality ( with fewer spurious tagging assignments ) than the one we observe from the original EM tagging . Figure 4 shows some examples . We also measure the quality of the two observed grammars / dictionaries by computing their precision and recall against the grammar / dictionary we observe in the gold tagging . We find that precision of the observed grammar increases from 0.73 ( EM ) to 0.94 ( IP + EM ) . In addition to removing many bad tag bigrams from the grammar , IP minimization also removes some of the good ones , leading to lower recall ( EM = 0.87 , IP + EM = 0.57 ) . In the case of the observed dictionary , using a smaller grammar model does not affect the precision ( EM = 0.91 , IP + EM = 0.89 ) or recall ( EM = 0.89 , IP + EM = 0.89 ) . During EM training , the smaller grammar with fewer bad tag bigrams helps to restrict the dictionary model from making too many bad choices that EM made earlier . Here are a few examples of bad dictionary entries that get removed when we use the minimized grammar for EM training : in FW a SYM of RP In RBR During EM training , the minimized grammar helps to eliminate many incorrect entries ( i.e . , zero out model parameters ) from the dictionary , thereby yielding an improved dictionary model . So using the minimized grammar ( which has higher precision ) helps to improve the quality of the chosen dictionary ( examples shown in Figure 4 ) . This in turn helps improve the tagging accuracy from 81.7 % to 84.5 % . It is clear that the IP-constrained grammar is a better choice to run EM on than the full grammar . Note that we used a very small IP-grammar ( containing only 459 tag bigrams ) during EM training . In the process of minimizing the grammar size , IP ends up removing many good tag bigrams from our grammar set ( as seen from the low measured recall of 0.57 for the observed grammar ) . Next , we proceed to recover some good tag bigrams and expand the grammar in a restricted fashion by making use of the higher-quality dictionary produced by the IP + EM method . We now run EM again on the full grammar ( all possible tag bigrams ) in combination with this good dictionary ( containing fewer entries than the full dictionary ) . Unlike the original training with full grammar , where EM could choose any tag bigram , now the choice of grammar entries is constrained by the good dictionary model that we provide EM with . This allows EM to recover some of the good tag pairs , and results in a good grammardictionary combination that yields better tagging performance . With these improvements in mind , we embark on an alternating scheme to find better models and taggings . We run EM for multiple passes , and in each pass we alternately constrain either the grammar model or the dictionary model . The procedure is simple and proceeds as follows : We notice significant gains in tagging performance when applying this technique . The tagging accuracy increases at each step and finally settles at a high of 91.6 % , which outperforms the existing state-of-the-art systems for the 45 - tag set . The system achieves a better accuracy than the 88.6 % from Smith and Eisner ( 2005 ) , and even surpasses the 91.4 % achieved by Goldberg et al . ( 2008 ) without using any additional linguistic constraints or manual cleaning of the dictionary . Figure 5 shows the tagging performance achieved at each step . We found that it is the elimination of incorrect entries from the dictionary ( and grammar ) and not necessarily the initialization weights from previous EM training , that results in the tagging improvements . Initializing the last trained dictionary or grammar at each step with uniform weights also yields the same tagging improvements as shown in Figure 5 . We find that the observed grammar also improves , growing from 459 entries to 603 entries , with precision increasing from 0.94 to 0.96 , and recall increasing from 0.57 to 0.76 . The figure also shows the models internal grammar and dictionary sizes . Figure 6 and 7 show how the precision / recall of the observed grammar and dictionary varies for different models from Figure 5 . In the case of the observed grammar ( Figure 6 ) , precision increases at each step , whereas recall drops initially ( owing to the grammar minimization ) but then picks up again . The precision / recall of the observed dictionary on the other hand , is not affected by much . 5 Restarts and More Data Multiple random restarts for EM , while not often emphasized in the literature , are key in this domain . Recall that our original EM tagging with a fully-connected 2 - gram tag model was 81.7 % accurate . When we execute 100 random restarts and select the model with the highest data likelihood , we get 83.8 % accuracy . Likewise , when we extend our alternating EM scheme to 100 random restarts at each step , we improve our tagging accuracy from 91.6 % to 91.8 % ( Figure 8 ) . As noted by Toutanova and Johnson ( 2008 ) , there is no reason to limit the amount of unlabeled data used for training the models . Their models are trained on the entire Penn Treebank data ( instead of using only the 24,115 - token test data ) , and so are the tagging models used by Goldberg et al . ( 2008 ) . But previous results from Smith and Eisner ( 2005 ) and Goldwater and Griffiths ( 2007 ) show that their models do not benefit from using more unlabeled training data . Because EM is efficient , we can extend our word-sequence trainModel 1 Model 2 Model 3 Model 4 Model 5 Tagging Model Because EM is efficient , we can extend our word-sequence training data from the 24,115 - token set to the entire Penn Treebank ( 973k tokens ) . We run EM training again for Model 5 ( the best model from Figure 5 ) but this time using 973k word tokens , and further increase our accuracy to 92.3 % . This is our final result on the 45-tagset , and we note that it is higher than previously reported results . 6 Smaller Tagset and Incomplete Dictionaries Previously , researchers working on this task have also reported results for unsupervised tagging with a smaller tagset ( Smith and Eisner , 2005 ; Goldwater and Griffiths , 2007 ; Toutanova and Johnson , 2008 ; Goldberg et al. , 2008 ) . Their systems were shown to obtain considerable improvements in accuracy when using a 17 - tagset ( a coarsergrained version of the tag labels from the Penn Treebank ) instead of the 45 - tagset . When tagging the same standard test corpus with the smaller 17 - tagset , our method is able to achieve a substantially high accuracy of 96.8 % , which is the best result reported so far on this task . The table in Figure 9 shows a comparison of different systems for which tagging accuracies have been reported previously for the 17 - tagset case ( Goldberg et al . , 2008 ) . The first row in the table compares tagging results when using a full dictionary ( i.e. , a lexicon containing entries for 49,206 word types ) . The InitEM-HMM system from Goldberg et al . ( 2008 ) reports an accuracy of 93.8 % , followed by the LDA + AC model ( Latent Dirichlet Allocation model with a strong Ambiguity Class component ) from Toutanova and Johnson ( 2008 ) . In comparison , the Bayesian HMM ( BHMM ) model from Goldwater et al . ( 2007 ) and the CE + spl model ( Contrastive Estimation with a spelling model ) from Smith and Eisner ( 2005 ) report lower accuracies ( 87.3 % and 88.7 % , respectively ) . Our system ( IP + EM ) which uses integer programming and EM , gets the highest accuracy ( 96.8 % ) . The accuracy numbers reported for Init-HMM and LDA + AC are for models that are trained on all the available unlabeled data from the Penn Treebank . The IP + EM models used in the 17 - tagset experiments reported here were not trained on the entire Penn Treebank , but instead used a smaller section containing 77,963 tokens for estimating model parameters . We also include the accuracies for our IP + EM model when using only the 24,115 token test corpus for EM estimation ( shown within parenthesis in second column of the table in Figure 9 ) . We find that our performance does not degrade when the parameter estimation is done using less data , and our model still achieves a high accuracy of 96.8 % . 6.1 Incomplete Dictionaries and Unknown Words The literature also includes results reported in a different setting for the tagging problem . In some scenarios , a complete dictionary with entries for all word types may not be readily available to us and instead , we might be provided with an incomplete dictionary that contains entries for only frequent word types . In such cases , any word not appearing in the dictionary will be treated as an unknown word , and can be labeled with any of the tags from given tagset ( i.e. , for every unknown word , there are 17 tag possibilities ) . Some previous approaches ( Toutanova and Johnson , 2008 ; Goldberg et al. , 2008 ) handle unknown words explicitly using ambiguity class components conditioned on various morphological features , and this has shown to produce good tagging results , especially when dealing with incomplete dictionaries . We follow a simple approach using just one of the features used in ( Toutanova and Johnson , 2008 ) for assigning tag possibilities to every unknown word . We first identify the top-100 suffixes ( up to 3 characters ) for words in the dictionary . Using the word/tag pairs from the dictionary , we train a simple probabilistic model that predicts the tag given a particular suffix ( e.g. , P ( VBG I ing ) = 0.97 , P ( N I ing ) = 0.0001 , ... ) . Next , for every unknown word w , the trained P ( tag I suffix ) model is used to predict the top 3 tag possibilities for w ( using only its suffix information ) , and subsequently this word along with its 3 tags are added as a new entry to the lexicon . We do this for every unknown word , and eventually we have a dictionary containing entries for all the words . Once the completed lexicon ( containing both correct entries for words in the lexicon and the predicted entries for unknown words ) is available , we follow the same methodology from Sections 3 and 4 using integer programming to minimize the size of the grammar and then applying EM to estimate parameter values . Figure 9 shows comparative results for the 17tagset case when the dictionary is incomplete . The second and third rows in the table shows tagging accuracies for different systems when a cutoff of 2 ( i.e. , all word types that occur with frequency counts < 2 in the test corpus are removed ) and a cutoff of 3 ( i.e. , all word types occurring with frequency counts < 3 in the test corpus are removed ) is applied to the dictionary . This yields lexicons containing 2,141 and 1,249 words respectively , which are much smaller compared to the original 49,206 word dictionary . As the results in Figure 9 illustrate , the IP + EM method clearly does better than all the other systems except for the LDA + AC model . The LDA + AC model from Toutanova and Johnson ( 2008 ) has a strong ambiguity class component and uses more features to handle the unknown words better , and this contributes to the slightly higher performance in the incomplete dictionary cases , when compared to the IP + EM model . 7 Discussion The method proposed in this paper is simple once an integer program is produced , there are solvers available which directly give us the solution . In addition , we do not require any complex parameter estimation techniques ; we train our models using simple EM , which proves to be efficient for this task . While some previous methods introduced for the same task have achieved big tagging improvements using additional linguistic knowledge or manual supervision , our models are not provided with any additional information . Figure 10 illustrates for the 45-tag set some of the common mistakes that our best tagging model ( 92.3 % ) makes . In some cases , the model actually gets a reasonable tagging but is penalized perhaps unfairly . For example , to is tagged as IN by our model sometimes when it occurs in the context of a preposition , whereas in the gold tagging it is always tagged as TO . The model also gets penalized for tagging the word U.S. as an adjective ( JJ ) , which might be considered valid in some cases such as the U.S. State Department . In other cases , the model clearly produces incorrect tags ( e.g. , New gets tagged incorrectly as NNPS ) . Our method resembles the classic Minimum Description Length ( MDL ) approach for model selection ( Barron et al. , 1998 ) . In MDL , there is a single objective function to ( 1 ) maximize the likelihood of observing the data , and at the same time ( 2 ) minimize the length of the model description ( which depends on the model size ) . However , the search procedure for MDL is usually non-trivial , and for our task of unsupervised tagging , we have not found a direct objective function which we can optimize and produce good tagging results . In the past , only a few approaches utilizing MDL have been shown to work for natural language applications . These approaches employ heuristic search methods with MDL for the task of unsupervised learning of morphology of natural languages ( Goldsmith , 2001 ; Creutz and Lagus , 2002 ; Creutz and Lagus , 2005 ) . The method proposed in this paper is the first application of the MDL idea to POS tagging , and the first to use an integer programming formulation rather than heuristic search techniques . We also note that it might be possible to replicate our models in a Bayesian framework similar to that proposed in ( Goldwater and Griffiths , 2007 ) . 8 Conclusion We presented a novel method for attacking dictionary-based unsupervised part-of-speech tagging . Our method achieves a very high accuracy ( 92.3 % ) on the 45 - tagset and a higher ( 96.8 % ) accuracy on a smaller 17 - tagset . The method works by explicitly minimizing the grammar size using integer programming , and then using EM to estimate parameter values . The entire process is fully automated and yields better performance than any existing state-of-the-art system , even though our models were not provided with any additional linguistic knowledge ( for example , explicit syntactic constraints to avoid certain tag combinations such as V V , etc. ) . However , it is easy to model some of these linguistic constraints ( both at the local and global levels ) directly using integer programming , and this may result in further improvements and lead to new possibilities for future research . For direct comparison to previous works , we also presented results for the case when the dictionaries are incomplete and find the performance of our system to be comparable with current best results reported for the same task . "}
  },
    {
    "id": "P10-2042",
    "result":     [
            {
        "value":         {
          "start": 182,
          "end": 210,
          "text": "Bayesian non-parametric model",
          "labels": ["Method"]
        },
        "id": 560
      },
            {
        "value":         {
          "start": 435,
          "end": 469,
          "text": "blocked Metropolis-Hastings sampler",
          "labels": ["Method"]
        },
        "id": 561
      },
            {
        "value":         {
          "start": 504,
          "end": 522,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 530,
          "end": 544,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 587,
          "end": 599,
          "text": "local sampler",
          "labels": ["Method"]
        },
        "id": 564
      },
            {
        "value":         {
          "start": 936,
          "end": 943,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 962,
          "end": 994,
          "text": "Tree Substitution Grammar ( TSG )",
          "labels": ["Method"]
        },
        "id": 565
      },
            {
        "value":         {
          "start": 1245,
          "end": 1248,
          "text": "TSGs",
          "labels": ["Method"]
        },
        "id": 588
      },
            {
        "value":         {
          "start": 1425,
          "end": 1427,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 1577,
          "end": 1585,
          "text": "TSG model",
          "labels": ["Method"]
        },
        "id": 576
      },
            {
        "value":         {
          "start": 1700,
          "end": 1712,
          "text": "Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 569
      },
            {
        "value":         {
          "start": 1999,
          "end": 2018,
          "text": "Local Gibbs samplers",
          "labels": ["Method"]
        },
        "id": 570
      },
            {
        "value":         {
          "start": 2512,
          "end": 2544,
          "text": "blocked MetropolisHasting sampler",
          "labels": ["Method"]
        },
        "id": 571
      },
            {
        "value":         {
          "start": 2561,
          "end": 2563,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 2777,
          "end": 2802,
          "text": "Metroplis-Hastings sampler",
          "labels": ["Method"]
        },
        "id": 572
      },
            {
        "value":         {
          "start": 3159,
          "end": 3161,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 3187,
          "end": 3214,
          "text": "Context Free Grammar ( CFG )",
          "labels": ["Method"]
        },
        "id": 573
      },
            {
        "value":         {
          "start": 3354,
          "end": 3368,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 3426,
          "end": 3444,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 3651,
          "end": 3675,
          "text": "Tree Substitution Grammar",
          "labels": ["Method"]
        },
        "id": 574
      },
            {
        "value":         {
          "start": 3679,
          "end": 3681,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 4471,
          "end": 4504,
          "text": "Tree Substitution Grammar ( PTSG )",
          "labels": ["Method"]
        },
        "id": 575
      },
            {
        "value":         {
          "start": 4783,
          "end": 4791,
          "text": "TSG model",
          "labels": ["Method"]
        },
        "id": 576
      },
            {
        "value":         {
          "start": 6713,
          "end": 6731,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 6764,
          "end": 6803,
          "text": "Markov chain Monte Carlo ( MCMC ) method",
          "labels": ["Method"]
        },
        "id": 576
      },
            {
        "value":         {
          "start": 7360,
          "end": 7385,
          "text": "MetropolisHastings sampler",
          "labels": ["Method"]
        },
        "id": 577
      },
            {
        "value":         {
          "start": 7729,
          "end": 7732,
          "text": "MCMC",
          "labels": ["Method"]
        },
        "id": 588
      },
            {
        "value":         {
          "start": 7823,
          "end": 7858,
          "text": "Metropolis-Hastings ( MH ) algorithm",
          "labels": ["Method"]
        },
        "id": 579
      },
            {
        "value":         {
          "start": 7960,
          "end": 7969,
          "text": "MH sampler",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 7977,
          "end": 7989,
          "text": "Bayesian PCFG",
          "labels": ["Method"]
        },
        "id": 581
      },
            {
        "value":         {
          "start": 8269,
          "end": 8294,
          "text": "Metropolis-Hastings ( MH )",
          "labels": ["Method"]
        },
        "id": 582
      },
            {
        "value":         {
          "start": 8761,
          "end": 8763,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 8796,
          "end": 8806,
          "text": "TSG grammar",
          "labels": ["Method"]
        },
        "id": 583
      },
            {
        "value":         {
          "start": 9107,
          "end": 9109,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 9135,
          "end": 9138,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 9164,
          "end": 9167,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 9245,
          "end": 9262,
          "text": "blocked MH sampler",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 9585,
          "end": 9587,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 9872,
          "end": 9874,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 9905,
          "end": 9908,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 10350,
          "end": 10352,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 10581,
          "end": 10583,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 11116,
          "end": 11125,
          "text": "MH sampler",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 11200,
          "end": 11202,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 11571,
          "end": 11574,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 11766,
          "end": 11768,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 12330,
          "end": 12332,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 12839,
          "end": 12841,
          "text": "TSG",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 13686,
          "end": 13688,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 13715,
          "end": 13722,
          "text": "Goodmans",
          "labels": ["Method"]
        },
        "id": 585
      },
            {
        "value":         {
          "start": 13799,
          "end": 13819,
          "text": "MER parsing algorithm",
          "labels": ["Method"]
        },
        "id": 586
      },
            {
        "value":         {
          "start": 13880,
          "end": 13882,
          "text": "CFG",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 13955,
          "end": 13967,
          "text": "Penn treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 14333,
          "end": 14340,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 14486,
          "end": 14503,
          "text": "blocked MH sampler",
          "labels": ["Method"]
        },
        "id": 587
      },
            {
        "value":         {
          "start": 14542,
          "end": 14560,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 14626,
          "end": 14640,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 14765,
          "end": 14779,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15002,
          "end": 15016,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15045,
          "end": 15063,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15128,
          "end": 15129,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 15312,
          "end": 15326,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15361,
          "end": 15369,
          "text": "F1 scores",
          "labels": ["Metric"]
        },
        "id": 1270
      },
            {
        "value":         {
          "start": 15380,
          "end": 15398,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15681,
          "end": 15684,
          "text": "TSGs",
          "labels": ["Method"]
        },
        "id": 588
      },
            {
        "value":         {
          "start": 15730,
          "end": 15742,
          "text": "Penn treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 15875,
          "end": 15889,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 15949,
          "end": 15950,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 16721,
          "end": 16724,
          "text": "MCMC",
          "labels": ["Method"]
        },
        "id": 588
      },
            {
        "value":         {
          "start": 16994,
          "end": 17012,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 17156,
          "end": 17172,
          "text": "TSG parsing model",
          "labels": ["Method"]
        },
        "id": 588
      },
            {
        "value":         {
          "start": 17181,
          "end": 17208,
          "text": "hierarchical Bayesian models",
          "labels": ["Method"]
        },
        "id": 589
      },
            {
        "value":         {
          "start": 17544,
          "end": 17584,
          "text": "Hierarchical Bayesian segmentation models",
          "labels": ["Method"]
        },
        "id": 590
      },
            {
        "value":         {
          "start": 18092,
          "end": 18110,
          "text": "local Gibbs sampler",
          "labels": ["Method"]
        },
        "id": 591
      },
            {
        "value":         {
          "start": 18185,
          "end": 18199,
          "text": "blocked sampler",
          "labels": ["Method"]
        },
        "id": 591
      }
    ],
    "data": {"text": "Blocked Inference in Bayesian Tree Substitution Grammars Abstract Learning a tree substitution grammar is very challenging due to derivational ambiguity . Our recent approach used a Bayesian non-parametric model to induce good derivations from treebanked input ( Cohn et al . , 2009 ) , biasing towards small grammars composed of small generalisable productions . In this paper we present a novel training method for the model using a blocked Metropolis-Hastings sampler in place of the previous methods local Gibbs sampler . The blocked sampler makes considerably larger moves than the local sampler and consequently converges in less time . A core component of the algorithm is a grammar transformation which represents an infinite tree substitution grammar in a finite context free grammar . This enables efficient blocked inference for training and also improves the parsing algorithm . Both algorithms are shown to improve parsing accuracy . 1 Introduction Tree Substitution Grammar ( TSG ) is a compelling grammar formalism which allows nonterminal rewrites in the form of trees , thereby enabling the modelling of complex linguistic phenomena such as argument frames , lexical agreement and idiomatic phrases . A fundamental problem with TSGs is that they are difficult to estimate , even in the supervised scenario where treebanked data is available . This is because treebanks are typically not annotated with their TSG derivations ( how to decompose a tree into elementary tree fragments ) ; instead the derivation needs to be inferred . In recent work we proposed a TSG model which infers an optimal decomposition under a nonparametric Bayesian prior ( Cohn et al . , 2009 ) . This used a Gibbs sampler for training , which repeatedly samples for every node in every training tree a binary value indicating whether the node is or is not a substitution point in the trees derivation . Aggregated over the whole corpus , these values and the underlying trees specify the weighted grammar . Local Gibbs samplers , although conceptually simple , suffer from slow convergence ( a.k.a . poor mixing ) . The sampler can get easily stuck because many locally improbable decisions are required to escape from a locally optimal solution . This problem manifests itself both locally to a sentence and globally over the training sample . The net result is a sampler that is non-convergent , overly dependent on its initialisation and can not be said to be sampling from the posterior . In this paper we present a blocked MetropolisHasting sampler for learning a TSG , similar to Johnson et al . ( 2007 ) . The sampler jointly updates all the substitution variables in a tree , making much larger moves than the local single-variable sampler . A critical issue when developing a Metroplis-Hastings sampler is choosing a suitable proposal distribution , which must have the same support as the true distribution . For our model the natural proposal distribution is a MAP point estimate , however this can not be represented directly as it is infinitely large . To solve this problem we develop a grammar transformation which can succinctly represent an infinite TSG in an equivalent finite Context Free Grammar ( CFG ) . The transformed grammar can be used as a proposal distribution , from which samples can be drawn in polynomial time . Empirically , the blocked sampler converges in fewer iterations and in less time than the local Gibbs sampler . In addition , we also show how the transformed grammar can be used for parsing , which yields theoretical and empirical improvements over our previous method which truncated the grammar . 2 Background A Tree Substitution Grammar ( TSG ; Bod et al . ( 2003 ) ) is a 4 - tuple , G = ( T , N , S , R ) , where T is a set of terminal symbols , N is a set of nonterminal symbols , S E N is the distinguished root nonterminal and R is a set of productions ( rules ) . The productions take the form of tree fragments , called elementary trees ( ETs ) , in which each internal node is labelled with a nonterminal and each leaf is labelled with either a terminal or a nonterminal . The frontier nonterminal nodes in each ET form the sites into which other ETs can be substituted . A derivation creates a tree by recursive substitution starting with the root symbol and finishing when there are no remaining frontier nonterminals . Figure 1 ( left ) shows an example derivation where the arrows denote substitution . A Probabilistic Tree Substitution Grammar ( PTSG ) assigns a probability to each rule in the grammar , where each production is assumed to be conditionally independent given its root nonterminal . A derivations probability is the product of the probabilities of the rules therein . In this work we employ the same nonparametric TSG model as Cohn et al . ( 2009 ) , which we now summarise . The inference problem within this model is to identify the posterior distribution of the elementary trees e given whole trees t . The model is characterised by the use of a Dirichlet Process ( DP ) prior over the grammar . We define the distribution over elementary trees e with root nonterminal symbol c as where P0 ( ' | c ) ( the base distribution ) is a distribution over the infinite space of trees rooted with c , and c ( the concentration parameter ) controls the models tendency towards either reusing elementary trees or creating novel ones as each training instance is encountered . Rather than representing the distribution Gc explicitly , we integrate over all possible values of Gc . The key result required for inference is that the conditional distribution of ei , given ei , = e1 ... en \\ ei and the root category c is : where ni ei , c is the number number of times ei has been used to rewrite c in ei , and ni is the total count of rewriting c. Henceforth we omit the i sub - / super-script for brevity . A primary consideration is the definition of P0 . Each ei can be generated in one of two ways : by drawing from the base distribution , where the probability of any particular tree is proportional to cP0 ( ei | c ) , or by drawing from a cache of previous expansions of c , where the probability of any particular expansion is proportional to the number of times that expansion has been used before . In Cohn et al. ( 2009 ) we presented base distributions that favour small elementary trees which we expect will generalise well to unseen data . In this work we show that if P0 is chosen such that it decomposes with the CFG rules contained within each elementary tree ,1 then we can use a novel dynamic programming algorithm to sample derivations without ever enumerating all the elementary trees in the grammar . The model was trained using a local Gibbs sampler ( Geman and Geman , 1984 ) , a Markov chain Monte Carlo ( MCMC ) method in which random variables are repeatedly sampled conditioned on the values of all other random variables in the model . To formulate the local sampler , we associate a binary variable with each non-root internal node of each tree in the training set , indicating whether that node is a substitution point or not ( illustrated in Figure 1 ) . The sampler then visits each node in a random schedule and resamples that nodes substitution variable , where the probability of the two different configurations are given by ( 1 ) . Parsing was performed using a MetropolisHastings sampler to draw derivation samples for a string , from which the best tree was recovered . However the sampler used for parsing was biased because it used as its proposal distribution a truncated grammar which excluded all but a handful of the unseen elementary trees . Consequently the proposal had smaller support than the true model , voiding the MCMC convergence proofs . 3 Grammar Transformation We now present a blocked sampler using the Metropolis-Hastings ( MH ) algorithm to perform sentence-level inference , based on the work of Johnson et al . ( 2007 ) who presented a MH sampler for a Bayesian PCFG . This approach repeats the following steps for each sentence in the training set : 1 ) run the inside algorithm ( Lari and Young , 1990 ) to calculate marginal expansion probabilities under a MAP approximation , 2 ) sample an analysis top-down and 3 ) accept or reject using a Metropolis-Hastings ( MH ) test to correct for differences between the MAP proposal and the true model . Though our model is similar to Johnson et al. ( 2007 ) s , we have an added complication : the MAP grammar can not be estimated directly . This is a consequence of the base distribution having infinite support ( assigning non-zero probability to infinitely many unseen tree fragments ) , which means the MAP has an infinite rule set . For example , if our base distribution licences the CFG production NP * NP PP then our TSG grammar will contain the infinite set of elementary trees NP * NP PP , NP * ( NP NP PP ) PP , NP * ( NP ( NP NP PP ) PP ) PP , . . . with decreasing but non-zero probability . However , we can represent the infinite MAP using a grammar transformation inspired by Goodman ( 2003 ) , which represents the MAP TSG in an equivalent finite PCFG . Under the transformed PCFG inference is efficient , allowing its use as the proposal distribution in a blocked MH sampler . We represent the MAP using the grammar transformation in Table 1 which separates the ne , e and Po terms in ( 1 ) into two separate CFGs , A and B. Grammar A has productions for every ET with ne , e > 1 which are assigned unsmoothed probabilities : omitting the Po term from ( 1 ) . Grammar B has productions for every CFG production licensed under Po ; its productions are denoted using primed ( ) nonterminals . The rule c * c ' bridges from A to B , weighted by the smoothing term excluding Po , which is computed recursively via child productions . The remaining rules in grammar B correspond to every CFG production in the underlying PCFG base distribution , coupled with the binary decision whether or not nonterminal children should be substitution sites ( frontier nonterminals ) . This choice affects the rule probability by including a s or 1 s factor , and child substitution sites also function as a bridge back from grammar B to A . In this way there are often two equivalent paths to reach the same chart cell using the same elementary tree via grammar A using observed TSG productions and via grammar B using Po backoff ; summing these yields the desired net probability . Figure 2 shows an example of the transformation of an elementary tree with non-zero count , ne , e > 1 , into the two types of CFG rules . Both parts are capable of parsing the string NP , saw , NP into a S , as illustrated in Figure 3 ; summing the probability of both analyses gives the model probability from ( 1 ) . Note that although the probabilities exactly match the true model for a single elementary tree , the probability of derivations composed of many elementary trees may not match because the models caching behaviour has been suppressed , i.e. , the counts , n , are not incremented during the course of a derivation . For training we define the MH sampler as follows . First we estimate the MAP grammar over both encode the same TSG derivation from Figure 1 . The left tree encodes that the S -- + NP ( VP ( V hates ) NP elementary tree was drawn from the cache , while for the right tree this same elementary tree was drawn from the base distribution ( the left and right terms in ( 1 ) , respectively ) . the derivations of training corpus excluding the current tree , which we represent using the PCFG transformation . The next step is to sample derivations for a given tree , for which we use a constrained variant of the inside algorithm ( Lari and Young , 1990 ) . We must ensure that the TSG derivation produces the given tree , and therefore during inside inference we only consider spans that are constituents in the tree and are labelled with the correct nonterminal . Nonterminals are said to match their primed and signed counterparts , e.g. , NP ' and NP [ DT , NN [ car ] ] both match NP . Under the tree constraints the time complexity of inside inference is linear in the length of the sentence . A derivation is then sampled from the inside chart using a top-down traversal ( Johnson et al . , 2007 ) , and converted back into its equivalent TSG derivation . The derivation is scored with the true model and accepted or rejected using the MH test ; accepted samples then replace the current derivation for the tree , and rejected samples leave the previous derivation unchanged . These steps are then repeated for another tree in the training set , and the process is then repeated over the full training set many times . Parsing The grammar transform is not only useful for training , but also for parsing . To parse a sentence we sample a number of TSG derivations from the MAP which are then accepted or rejected into the full model using a MH step . The samples are obtained from the same transformed grammar but adapting the algorithm for an unsupervised setting where parse trees are not available . For this we use the standard inside algorithm applied to the sentence , omitting the tree constraints , which has time complexity cubic in the length of the sentence . We then sample a derivation from the inside chart and perform the MH acceptance test . This setup is theoretically more appealing than our previous approach in which we truncated the approximation grammar to exclude most of the zero count rules ( Cohn et al. , 2009 ) . We found that both the maximum probability derivation and tree were considerably worse than a tree constructed to maximise the expected number of correct CFG rules ( MER ) , based on Goodmans ( 2003 ) algorithm for maximising labelled recall . For this reason we the MER parsing algorithm using sampled Monte Carlo estimates for the marginals over CFG rules at each sentence span . 4 Experiments We tested our model on the Penn treebank using the same data setup as Cohn et al . ( 2009 ) . Specifically , we used only section 2 for training and section 22 ( devel ) for reporting results . Our models were all sampled for 5k iterations with hyperparameter inference for , and s , b c E N , but in contrast to our previous approach we did not use annealing which we did not find to help generalisation accuracy . The MH acceptance rates were in excess of 99 % across both training and parsing . All results are averages over three runs . For training the blocked MH sampler exhibits faster convergence than the local Gibbs sampler , as shown in Figure 4 . Irrespective of the initialisation the blocked sampler finds higher likelihood states in many fewer iterations ( the same trend continues until iteration 5k ) . To be fair , the blocked sampler is slower per iteration ( roughly 50 % worse ) due to the higher overheads of the grammar transform and performing dynamic programming ( despite nominal optimisation ) . Even after accounting for the time differ ence the blocked sampler is more effective than the local Gibbs sampler . Training likelihood is highly correlated with generalisation F1 ( Pearsons correlation efficient of 0.95 ) , and therefore improving the sampler convergence will have immediate effects on performance . Parsing results are shown in Table 2.5 The blocked sampler results in better generalisation F1 scores than the local Gibbs sampler , irrespective of the initialisation condition or parsing method used . The use of the grammar transform in parsing also yields better scores irrespective of the underlying model . Together these results strongly advocate the use of the grammar transform for inference in infinite TSGs . We also trained the model on the standard Penn treebank training set ( sections 221 ) . We initialised the model with the final sample from a run on the small training set , and used the blocked sampler for 6500 iterations . Averaged over three runs , the test F1 ( section 23 ) was 85.3 an improveiteration than the local sampler . ment over our earlier 84.0 ( Cohn et al. , 2009 ) although still well below state-of-the-art parsers . We conjecture that the performance gap is due to the model using an overly simplistic treatment of unknown words , and also a further mixing problems with the sampler . For the full data set the counts are much larger in magnitude which leads to stronger modes . The sampler has difficulty escaping such modes and therefore is slower to mix . One way to solve the mixing problem is for the sampler to make more global moves , e.g. , with table label resampling ( Johnson and Goldwater , 2009 ) or split-merge ( Jain and Neal , 2000 ) . Another way is to use a variational approximation instead of MCMC sampling ( Wainwright and Jordan , 2008 ) . 5 Discussion We have demonstrated how our grammar transformation can implicitly represent an exponential space of tree fragments efficiently , allowing us to build a sampler with considerably better mixing properties than a local Gibbs sampler . The same technique was also shown to improve the parsing algorithm . These improvements are in no way limited to our particular choice of a TSG parsing model , many hierarchical Bayesian models have been proposed which would also permit similar optimised samplers . In particular models which induce segmentations of complex structures stand to benefit from this work ; Examples include the word segmentation model of Goldwater et al. ( 2006 ) for which it would be trivial to adapt our technique to develop a blocked sampler . Hierarchical Bayesian segmentation models have also become popular in statistical machine translation where there is a need to learn phrasal translation structures that can be decomposed at the word level ( DeNero et al . , 2008 ; Blunsom et al . , 2009 ; Cohn and Blunsom , 2009 ) . We envisage similar representations being applied to these models to improve their mixing properties . A particularly interesting avenue for further research is to employ our blocked sampler for unsupervised grammar induction . While it is difficult to extend the local Gibbs sampler to the case where the tree is not observed , the dynamic program for our blocked sampler can be easily used for unsupervised inference by omitting the tree matching constraints . "}
  },
    {
    "id": "P10-4002",
    "result":     [
            {
        "value":         {
          "start": 127,
          "end": 130,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 266,
          "end": 282,
          "text": "word-based models",
          "labels": ["Method"]
        },
        "id": 592
      },
            {
        "value":         {
          "start": 286,
          "end": 304,
          "text": "phrase-based models",
          "labels": ["Method"]
        },
        "id": 1100
      },
            {
        "value":         {
          "start": 328,
          "end": 360,
          "text": "synchronous context-free grammars",
          "labels": ["Method"]
        },
        "id": 594
      },
            {
        "value":         {
          "start": 840,
          "end": 844,
          "text": "C + +",
          "labels": ["Tool"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 1081,
          "end": 1113,
          "text": "finite-state transducers ( FSTs )",
          "labels": ["Method"]
        },
        "id": 595
      },
            {
        "value":         {
          "start": 1127,
          "end": 1169,
          "text": "synchronous context-free grammars ( SCFGs )",
          "labels": ["Method"]
        },
        "id": 596
      },
            {
        "value":         {
          "start": 1190,
          "end": 1208,
          "text": "Phrase-based models",
          "labels": ["Method"]
        },
        "id": 1100
      },
            {
        "value":         {
          "start": 1237,
          "end": 1262,
          "text": "lexical translation models",
          "labels": ["Method"]
        },
        "id": 597
      },
            {
        "value":         {
          "start": 1295,
          "end": 1332,
          "text": "finite-state conditional random fields",
          "labels": ["Method"]
        },
        "id": 598
      },
            {
        "value":         {
          "start": 1388,
          "end": 1419,
          "text": "hierarchical phrase-based models",
          "labels": ["Method"]
        },
        "id": 599
      },
            {
        "value":         {
          "start": 1491,
          "end": 1494,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 1835,
          "end": 1838,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 2115,
          "end": 2118,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 2732,
          "end": 2735,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 3067,
          "end": 3070,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 3439,
          "end": 3442,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 3867,
          "end": 3870,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 5253,
          "end": 5257,
          "text": "cdecs",
          "labels": ["Tool"]
        },
        "id": 615
      },
            {
        "value":         {
          "start": 5795,
          "end": 5801,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 6755,
          "end": 6765,
          "text": "SCFG models",
          "labels": ["Method"]
        },
        "id": 601
      },
            {
        "value":         {
          "start": 6887,
          "end": 6905,
          "text": "phrase-based models",
          "labels": ["Method"]
        },
        "id": 1100
      },
            {
        "value":         {
          "start": 7356,
          "end": 7365,
          "text": "SCFG model",
          "labels": ["Method"]
        },
        "id": 602
      },
            {
        "value":         {
          "start": 8248,
          "end": 8251,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 8334,
          "end": 8360,
          "text": "non-SCFG translation models",
          "labels": ["Method"]
        },
        "id": 603
      },
            {
        "value":         {
          "start": 8796,
          "end": 8799,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 9251,
          "end": 9266,
          "text": "Chiang algorithm",
          "labels": ["Method"]
        },
        "id": 604
      },
            {
        "value":         {
          "start": 9383,
          "end": 9386,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 9845,
          "end": 9865,
          "text": "linear-time algorithm",
          "labels": ["Method"]
        },
        "id": 605
      },
            {
        "value":         {
          "start": 10504,
          "end": 10507,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 10593,
          "end": 10597,
          "text": "C + +",
          "labels": ["Tool"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 11121,
          "end": 11126,
          "text": "INSIDE",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 11130,
          "end": 11136,
          "text": "OUTSIDE",
          "labels": ["Method"]
        },
        "id": 607
      },
            {
        "value":         {
          "start": 11144,
          "end": 11156,
          "text": "INSIDEOUTSIDE",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 11196,
          "end": 11200,
          "text": "C + +",
          "labels": ["Tool"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 11470,
          "end": 11476,
          "text": "Viterbi",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 11482,
          "end": 11509,
          "text": "k-best extraction algorithms",
          "labels": ["Method"]
        },
        "id": 609
      },
            {
        "value":         {
          "start": 11534,
          "end": 11550,
          "text": "INSIDE algorithms",
          "labels": ["Method"]
        },
        "id": 610
      },
            {
        "value":         {
          "start": 11814,
          "end": 11840,
          "text": "k-best extraction algorithm",
          "labels": ["Method"]
        },
        "id": 611
      },
            {
        "value":         {
          "start": 12120,
          "end": 12153,
          "text": "Viterbi envelope semiring training",
          "labels": ["Method"]
        },
        "id": 612
      },
            {
        "value":         {
          "start": 12157,
          "end": 12160,
          "text": "VEST",
          "labels": ["Method"]
        },
        "id": 613
      },
            {
        "value":         {
          "start": 12179,
          "end": 12224,
          "text": "minimum error rate training ( MERT ) algorithm",
          "labels": ["Method"]
        },
        "id": 614
      },
            {
        "value":         {
          "start": 12436,
          "end": 12440,
          "text": "cdecs",
          "labels": ["Tool"]
        },
        "id": 615
      },
            {
        "value":         {
          "start": 12811,
          "end": 12826,
          "text": "INSIDE algorithm",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 12877,
          "end": 12880,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 13001,
          "end": 13009,
          "text": "MapReduce",
          "labels": ["Method"]
        },
        "id": 628
      },
            {
        "value":         {
          "start": 13142,
          "end": 13145,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 13151,
          "end": 13153,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 13308,
          "end": 13321,
          "text": "MERT algorithm",
          "labels": ["Method"]
        },
        "id": 617
      },
            {
        "value":         {
          "start": 13943,
          "end": 13971,
          "text": "SCFG-based translation models",
          "labels": ["Method"]
        },
        "id": 618
      },
            {
        "value":         {
          "start": 14017,
          "end": 14020,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 14120,
          "end": 14122,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14609,
          "end": 14624,
          "text": "INSIDE algorithm",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 14808,
          "end": 14820,
          "text": "INSIDEOUTSIDE",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 14854,
          "end": 14859,
          "text": "INSIDE",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 15238,
          "end": 15241,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 15420,
          "end": 15424,
          "text": "LBFGS",
          "labels": ["Method"]
        },
        "id": 619
      },
            {
        "value":         {
          "start": 15451,
          "end": 15455,
          "text": "RPROP",
          "labels": ["Method"]
        },
        "id": 620
      },
            {
        "value":         {
          "start": 15495,
          "end": 15521,
          "text": "stochastic gradient descent",
          "labels": ["Method"]
        },
        "id": 1039
      },
            {
        "value":         {
          "start": 15575,
          "end": 15578,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 15582,
          "end": 15586,
          "text": "Hiero",
          "labels": ["Tool"]
        },
        "id": 622
      },
            {
        "value":         {
          "start": 15594,
          "end": 15603,
          "text": "Joshua 1.3",
          "labels": ["Tool"]
        },
        "id": 623
      },
            {
        "value":         {
          "start": 15752,
          "end": 15755,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 15971,
          "end": 15997,
          "text": "SRIs language model toolkit",
          "labels": ["Tool"]
        },
        "id": 624
      },
            {
        "value":         {
          "start": 16036,
          "end": 16041,
          "text": "Joshua",
          "labels": ["Tool"]
        },
        "id": 625
      },
            {
        "value":         {
          "start": 16446,
          "end": 16449,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 16955,
          "end": 16958,
          "text": "cdec",
          "labels": ["Tool"]
        },
        "id": 626
      },
            {
        "value":         {
          "start": 17244,
          "end": 17247,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 17280,
          "end": 17283,
          "text": "MIRA",
          "labels": ["Method"]
        },
        "id": 890
      },
            {
        "value":         {
          "start": 17452,
          "end": 17457,
          "text": "Hadoop",
          "labels": ["Tool"]
        },
        "id": 627
      },
            {
        "value":         {
          "start": 17494,
          "end": 17502,
          "text": "MapReduce",
          "labels": ["Method"]
        },
        "id": 628
      }
    ],
    "data": {"text": "cdec : A Decoder , Alignment , and Learning Framework for Finite-State and Context-Free translation Models Abstract We present cdec , an open source framework for decoding , aligning with , and training a number of statistical machine translation models , including word-based models , phrase-based models , and models based on synchronous context-free grammars . Using a single unified internal representation for translation forests , the decoder strictly separates model-specific translation logic from general rescoring , pruning , and inference algorithms . From this unified representation , the decoder can extract not only the 1 - or k-best translations , but also alignments to a reference , or the quantities necessary to drive discriminative training using gradient-based or gradient-free optimization techniques . Its efficient C + + implementation means that memory use and runtime performance are significantly better than comparable decoders . 1 Introduction The dominant models used in machine translation and sequence tagging are formally based on either weighted finite-state transducers ( FSTs ) or weighted synchronous context-free grammars ( SCFGs ) ( Lopez , 2008 ) . Phrase-based models ( Koehn et al . , 2003 ) , lexical translation models ( Brown et al . , 1993 ) , and finite-state conditional random fields ( Sha and Pereira , 2003 ) exemplify the former , and hierarchical phrase-based models the latter ( Chiang , 2007 ) . We introduce a software package called cdec that manipulates both classes in a unified way . Although open source decoders for both phrasebased and hierarchical translation models have been available for several years ( Koehn et al . , 2007 ; Li et al . , 2009 ) , their extensibility to new models and algorithms is limited by two significant design flaws that we have avoided with cdec . First , their implementations tightly couple the translation , language model integration ( which we call rescoring ) , and pruning algorithms . This makes it difficult to explore alternative translation models without also re-implementing rescoring and pruning logic . In cdec , model-specific code is only required to construct a translation forest ( 3 ) . General rescoring ( with language models or other models ) , pruning , inference , and alignment algorithms then apply to the unified data structure ( 4 ) . Hence all model types benefit immediately from new algorithms ( for rescoring , inference , etc. ) ; new models can be more easily prototyped ; and controlled comparison of models is made easier . Second , existing open source decoders were designed with the traditional phrase-based parameterization using a very small number of dense features ( typically less than 10 ) . cdec has been designed from the ground up to support any parameterization , from those with a handful of dense features up to models with millions of sparse features ( Blunsom et al . , 2008 ; Chiang et al . , 2009 ) . Since the inference algorithms necessary to compute a training objective ( e.g . conditional likelihood or expected BLEU ) and its gradient operate on the unified data structure ( 5 ) , any model type can be trained using with any of the supported training criteria . The software package includes general function optimization utilities that can be used for discriminative training ( 6 ) . These features are implemented without compromising on performance . We show experimentally that cdec uses less memory and time than comparable decoders on a controlled translation task ( 7 ) . 2 Decoder workflow The decoding pipeline consists of two phases . The first ( Figure 1 ) transforms input , which may be represented as a source language sentence , lattice ( Dyer et al. , 2008 ) , or context-free forest ( Dyer and Resnik , 2010 ) , into a translation forest that has been rescored with all applicable models . In cdec , the only model-specific logic is confined to the first step in the process where an input string ( or lattice , etc . ) is transduced into the unified hypergraph representation . Since the model-specific code need not worry about integration with rescoring models , it can be made quite simple and efficient . Furthermore , prior to language model integration ( and distortion model integration , in the case of phrase based translation ) , pruning is unnecessary for most kinds of models , further simplifying the model-specific code . Once this unscored translation forest has been generated , any non-coaccessible states ( i.e. , states that are not reachable from the goal node ) are removed and the resulting structure is rescored with language models using a user-specified intersection/pruning strategy ( 4 ) resulting in a rescored translation forest and completing phase 1 . The second phase of the decoding pipeline ( depicted in Figure 2 ) computes a value from the rescored forest : 1 - or k-best derivations , feature expectations , or intersection with a target language reference ( sentence or lattice ) . The last option generates an alignment forest , from which a word alignment or feature expectations can be extracted . Most of these values are computed in a time complexity that is linear in the number of edges and nodes in the translation hypergraph using cdecs semiring framework ( 5 ) . 2.1 Alignment forests and alignment Alignment is the process of determining if and how a translation model generates a ( source , target ) string pair . To compute an alignment under a translation model , the phase 1 translation hypergraph is reinterpreted as a synchronous contextfree grammar and then used to parse the target sentence .2 This results in an alignment forest , which is a compact representation of all the derivations of the sentence pair under the translation model . From this forest , the Viterbi or maximum a posteriori word alignment can be generated . This alignment algorithm is explored in depth by Dyer ( 2010 ) . Note that if the phase 1 forest has been pruned in some way , or the grammar does not derive the sentence pair , the target intersection parse may fail , meaning that an alignment will not be recoverable . 3 Translation hypergraphs Recent research has proposed a unified representation for the various translation and tagging formalisms that is based on weighted logic programming ( Lopez , 2009 ) . In this view , translation ( or tagging ) deductions have the structure of a context-free forest , or directed hypergraph , where edges have a single head and 0 or more tail nodes ( Nederhof , 2003 ) . Once a forest has been constructed representing the possible translations , general inference algorithms can be applied . In cdecs translation hypergraph , a node represents a contiguous sequence of target language words . For SCFG models and sequential tagging models , a node also corresponds to a source span and non-terminal type , but for word-based and phrase-based models , the relationship to the source string ( or lattice ) may be more complicated . In a phrase-based translation hypergraph , the node will correspond to a source coverage vector ( Koehn et al. , 2003 ) . In word-based models , a single node may derive multiple different source language coverages since word based models impose no requirements on covering all words in the input . Figure 3 illustrates two example hypergraphs , one generated using a SCFG model and other from a phrase-based model . Edges are associated with exactly one synchronous production in the source and target language , and alternative translation possibilities are expressed as alternative edges . Edges are further annotated with feature values , and are annotated with the source span vector the edge corresponds to . An edges output label may contain mixtures of terminal symbol yields and positions indicating where a child nodes yield should be substituted . 2The parser is smart enough to detect the left-branching grammars generated by lexical translation and tagging models , and use a more efficient intersection algorithm . specifies what path is taken from the input ( one of the bold ovals ) to a unified translation hypergraph . The highlighted path is the workflow used in the test reported in 7 . Translation outputs Alignment outputs In the case of SCFG grammars , the edges correspond simply to rules in the synchronous grammar . For non-SCFG translation models , there are two kinds of edges . The first have zero tail nodes ( i.e. , an arity of 0 ) , and correspond to word or phrase translation pairs ( with all translation options existing on edges deriving the same head node ) , or glue rules that glue phrases together . For tagging , word-based , and phrase-based models , these are strictly arranged in a monotone , leftbranching structure . 4 Rescoring with weighted FSTs The design of cdec separates the creation of a translation forest from its rescoring with a language models or similar models . Since the structure of the unified search space is context free ( 3 ) , we use the logic for language model rescoring described by Chiang ( 2007 ) , although any weighted intersection algorithm can be applied . The rescor ing models need not be explicitly represented as FSTsthe state space can be inferred . Although intersection using the Chiang algorithm runs in polynomial time and space , the resulting rescored forest may still be too large to represent completely . cdec therefore supports three pruning strategies that can be used during intersection : full unpruned intersection ( useful for tagging models to incorporate , e.g . , Markov features , but not generally practical for translation ) , cube pruning , and cube growing ( Huang and Chiang , 2007 ) . 5 Semiring framework Semirings are a useful mathematical abstraction for dealing with translation forests since many useful quantities can be computed using a single linear-time algorithm but with different semirings . A semiring is a 5-tuple ( K , , , 0,1 ) that indicates the set from which the values will be drawn , K , a generic addition and multiplication operation , and , and their identities 0 and 1 . Multiplication and addition must be associative . Multiplication must distribute over addition , and v 0 must equal 0 . Values that can be computed using the semirings include the number of derivations , the expected translation length , the entropy of the translation posterior distribution , and the expected values of feature functions ( Li and Eisner , 2009 ) . Since semirings are such a useful abstraction , cdec has been designed to facilitate implementation of new semirings . Table 1 shows the C + + representation used for semirings . Note that because of our representation , built-in types like double , int , and bool ( together with their default operators ) are semirings . Beyond these , the type prob t is provided which stores the logarithm of the value it represents , which helps avoid underflow and overflow problems that may otherwise be encountered . A generic first-order expectation semiring is also provided ( Li and Eisner , 2009 ) . Three standard algorithms parameterized with semirings are provided : INSIDE , OUTSIDE , and INSIDEOUTSIDE , and the semiring is specified using C + + generics ( templates ) . Additionally , each algorithm takes a weight function that maps from hypergraph edges to a value in K , making it possible to use many different semirings without altering the underlying hypergraph . 5.1 Viterbi and k-best extraction Although Viterbi and k-best extraction algorithms are often expressed as INSIDE algorithms with the tropical semiring , cdec provides a separate derivation extraction framework that makes use of a < operator ( Huang and Chiang , 2005 ) . Thus , many of the semiring types define not only the elements shown in Table 1 but T : : operator < as well . The k-best extraction algorithm is also parameterized by an optional predicate that can filter out derivations at each node , enabling extraction of only derivations that yield different strings as in Huang et al . ( 2006 ) . 6 Model training Two training pipelines are provided with cdec . The first , called Viterbi envelope semiring training , VEST , implements the minimum error rate training ( MERT ) algorithm , a gradient-free optimization technique capable of maximizing arbitrary loss functions ( Och , 2003 ) . 6.1 VEST Rather than computing an error surface using kbest approximations of the decoder search space , cdecs implementation performs inference over the full hypergraph structure ( Kumar et al . , 2009 ) . In particular , by defining a semiring whose values are sets of line segments , having an addition operation equivalent to union , and a multiplication operation equivalent to a linear transformation of the line segments , Ochs line search can be computed simply using the INSIDE algorithm . Since the translation hypergraphs generated by cdec may be quite large making inference expensive , the logic for constructing error surfaces is factored according to the MapReduce programming paradigm ( Dean and Ghemawat , 2004 ) , enabling parallelization across a cluster of machines . Implementations of the BLEU and TER loss functions are provided ( Papineni et al . , 2002 ; Snover et al . , 2006 ) . 6.2 Large-scale discriminative training In addition to the widely used MERT algorithm , cdec also provides a training pipeline for discriminatively trained probabilistic translation models ( Blunsom et al . , 2008 ; Blunsom and Osborne , 2008 ) . In these models , the translation model is trained to maximize conditional log likelihood of the training data under a specified grammar . Since log likelihood is differentiable with respect to the feature weights in an exponential model , it is possible to use gradient-based optimization techniques to train the system , enabling the parameterization of the model using millions of sparse features . While this training approach was originally proposed for SCFG-based translation models , it can be used to train any model type in cdec . When used with sequential tagging models , this pipeline is identical to traditional sequential CRF training ( Sha and Pereira , 2003 ) . Both the objective ( conditional log likelihood ) and its gradient have the form of a difference in two quantities : each has one term that is computed over the translation hypergraph which is subtracted from the result of the same computation over the alignment hypergraph ( refer to Figures 1 and 2 ) . The conditional log likelihood is the difference in the log partition of the translation and alignment hypergraph , and is computed using the INSIDE algorithm . The gradient with respect to a particular feature is the difference in this features expected value in the translation and alignment hypergraphs , and can be computed using either INSIDEOUTSIDE or the expectation semiring and INSIDE . Since a translation forest is generated as an intermediate step in generating an alignment forest ( 2 ) this computation is straightforward . Since gradient-based optimization techniques may require thousands of evaluations to converge , the batch training pipeline is split into map and reduce components , facilitating distribution over very large clusters . Briefly , the cdec is run as the map function , and sentence pairs are mapped over . The reduce function aggregates the results and performs the optimization using standard algorithms , including LBFGS ( Liu et al . , 1989 ) , RPROP ( Riedmiller and Braun , 1993 ) , and stochastic gradient descent . 7 Experiments Table 2 compares the performance of cdec , Hiero , and Joshua 1.3 ( running with 1 or 8 threads ) decoding using a hierarchical phrase-based translation grammar and identical pruning settings . Figure 4 shows the cdec configuration and weights file used for this test . The workstation used has two 2 GHz quad-core Intel Xenon processors , 32 GB RAM , is running Linux kernel version 2.6.18 and gcc version 4.1.2 . All decoders use SRIs language model toolkit , version 1.5.9 ( Stolcke , 2002 ) . Joshua was run on the Sun HotSpot JVM , version 1.6.0 12 . A hierarchical phrase-based translation grammar was extracted for the NIST MT03 Chinese-English translation using a suffix array rule extractor ( Lopez , 2007 ) . A non-terminal span limit of 15 was used , and all decoders were configured to use cube pruning with a limit of 30 candidates at each node and no further pruning . All decoders produced a BLEU score between 31.4 and 31.6 ( small differences are accounted for by different tie-breaking behavior and OOV handling ) . formalism = scfg grammar = grammar.mt03.scfg.gz add pass through rules = true scfg max span limit = 15 feature function = LanguageModel en.3gram.pruned.lm.gz - o 3 feature function = WordPenalty intersection strategy = cube pruning cubepruning pop limit = 30 8 Future work C. Dyer . 2010 . Two monolingual parses are better than one ( synchronous parse ) . In Proc . of HLT-NAACL . cdec continues to be under active development . We are taking advantage of its modular design to study alternative algorithms for language model integration . Further training pipelines are under development , including minimum risk training using a linearly decomposable approximation of BLEU ( Li and Eisner , 2009 ) , and MIRA training ( Chiang et al . , 2009 ) . All of these will be made publicly available as the projects progress . We are also improving support for parallel training using Hadoop ( an open-source implementation of MapReduce ) . "}
  },
    {
    "id": "P11-2005",
    "result":     [
            {
        "value":         {
          "start": 124,
          "end": 128,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 322,
          "end": 344,
          "text": "modified Kneser-Ney LMs",
          "labels": ["Method"]
        },
        "id": 640
      },
            {
        "value":         {
          "start": 468,
          "end": 473,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 494,
          "end": 518,
          "text": "Kneser-Ney language model",
          "labels": ["Method"]
        },
        "id": 641
      },
            {
        "value":         {
          "start": 573,
          "end": 582,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 602,
          "end": 620,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 626,
          "end": 639,
          "text": "Jelinek-Mercer",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 720,
          "end": 725,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 841,
          "end": 846,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 857,
          "end": 866,
          "text": "Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 665
      },
            {
        "value":         {
          "start": 925,
          "end": 929,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 1701,
          "end": 1705,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 1760,
          "end": 1779,
          "text": "Kneser-Ney smoothing",
          "labels": ["Method"]
        },
        "id": 646
      },
            {
        "value":         {
          "start": 1918,
          "end": 1923,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 2105,
          "end": 2114,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 2142,
          "end": 2160,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 2224,
          "end": 2230,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 2545,
          "end": 2550,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 2845,
          "end": 2850,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 2957,
          "end": 2963,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 3213,
          "end": 3222,
          "text": "Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 665
      },
            {
        "value":         {
          "start": 3299,
          "end": 3304,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 3352,
          "end": 3370,
          "text": "Modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 3480,
          "end": 3486,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 3602,
          "end": 3608,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 3631,
          "end": 3639,
          "text": "KneserNey",
          "labels": ["Method"]
        },
        "id": 647
      },
            {
        "value":         {
          "start": 3941,
          "end": 3963,
          "text": "English Gigaword corpus",
          "labels": ["Dataset"]
        },
        "id": 648
      },
            {
        "value":         {
          "start": 3986,
          "end": 4007,
          "text": "New York Times ( NYT )",
          "labels": ["Dataset"]
        },
        "id": 648
      },
            {
        "value":         {
          "start": 4013,
          "end": 4040,
          "text": "Agence France Presse ( AFP )",
          "labels": ["Dataset"]
        },
        "id": 649
      },
            {
        "value":         {
          "start": 4135,
          "end": 4142,
          "text": "Gigaword",
          "labels": ["Dataset"]
        },
        "id": 650
      },
            {
        "value":         {
          "start": 4395,
          "end": 4399,
          "text": "NYT95",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 4405,
          "end": 4411,
          "text": "NYT95 '",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 4474,
          "end": 4481,
          "text": "trigrams",
          "labels": ["Method"]
        },
        "id": 973
      },
            {
        "value":         {
          "start": 4627,
          "end": 4631,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 4891,
          "end": 4895,
          "text": "NYT96",
          "labels": ["Dataset"]
        },
        "id": 653
      },
            {
        "value":         {
          "start": 4899,
          "end": 4903,
          "text": "NYT06",
          "labels": ["Dataset"]
        },
        "id": 654
      },
            {
        "value":         {
          "start": 4907,
          "end": 4911,
          "text": "AFP95",
          "labels": ["Dataset"]
        },
        "id": 655
      },
            {
        "value":         {
          "start": 4915,
          "end": 4919,
          "text": "AFP96",
          "labels": ["Dataset"]
        },
        "id": 656
      },
            {
        "value":         {
          "start": 4927,
          "end": 4931,
          "text": "AFP06",
          "labels": ["Dataset"]
        },
        "id": 657
      },
            {
        "value":         {
          "start": 4996,
          "end": 5011,
          "text": "NYT and AFP data",
          "labels": ["Dataset"]
        },
        "id": 658
      },
            {
        "value":         {
          "start": 5050,
          "end": 5054,
          "text": "NYT95",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 5224,
          "end": 5240,
          "text": "NYT newswire data",
          "labels": ["Dataset"]
        },
        "id": 659
      },
            {
        "value":         {
          "start": 5350,
          "end": 5352,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 5358,
          "end": 5369,
          "text": "AFP newswire",
          "labels": ["Dataset"]
        },
        "id": 661
      },
            {
        "value":         {
          "start": 5461,
          "end": 5465,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 5576,
          "end": 5581,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 5689,
          "end": 5693,
          "text": "NYT95",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 5697,
          "end": 5703,
          "text": "NYT95 '",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 6102,
          "end": 6106,
          "text": "NYT95",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 6110,
          "end": 6116,
          "text": "NYT95 '",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 6656,
          "end": 6674,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 6727,
          "end": 6732,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 6846,
          "end": 6857,
          "text": "givennn-gram",
          "labels": ["Method"]
        },
        "id": 662
      },
            {
        "value":         {
          "start": 6982,
          "end": 6989,
          "text": "trigrams",
          "labels": ["Method"]
        },
        "id": 973
      },
            {
        "value":         {
          "start": 7102,
          "end": 7109,
          "text": "trigrams",
          "labels": ["Method"]
        },
        "id": 973
      },
            {
        "value":         {
          "start": 7291,
          "end": 7296,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 7437,
          "end": 7455,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 8174,
          "end": 8180,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 8388,
          "end": 8397,
          "text": "Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 665
      },
            {
        "value":         {
          "start": 8447,
          "end": 8470,
          "text": "jackknife language model",
          "labels": ["Method"]
        },
        "id": 663
      },
            {
        "value":         {
          "start": 8532,
          "end": 8537,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 8788,
          "end": 8794,
          "text": "trigram",
          "labels": ["Method"]
        },
        "id": 980
      },
            {
        "value":         {
          "start": 9281,
          "end": 9287,
          "text": "trigram",
          "labels": ["Method"]
        },
        "id": 980
      },
            {
        "value":         {
          "start": 9352,
          "end": 9357,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 9444,
          "end": 9449,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 10410,
          "end": 10414,
          "text": "NYT95",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 10418,
          "end": 10424,
          "text": "NYT95 '",
          "labels": ["Dataset"]
        },
        "id": 664
      },
            {
        "value":         {
          "start": 10773,
          "end": 10788,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 10823,
          "end": 10829,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 10834,
          "end": 10843,
          "text": "Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 665
      },
            {
        "value":         {
          "start": 10884,
          "end": 10889,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 10953,
          "end": 10962,
          "text": "error rate",
          "labels": ["Metric"]
        },
        "id": 1535
      },
            {
        "value":         {
          "start": 11022,
          "end": 11027,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 11126,
          "end": 11135,
          "text": "Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 665
      },
            {
        "value":         {
          "start": 11313,
          "end": 11319,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 11636,
          "end": 11642,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 11724,
          "end": 11730,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 12295,
          "end": 12300,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 12328,
          "end": 12346,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 12406,
          "end": 12411,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 12686,
          "end": 12692,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 12824,
          "end": 12829,
          "text": "ngrams",
          "labels": ["Method"]
        },
        "id": 1488
      },
            {
        "value":         {
          "start": 12837,
          "end": 12855,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 12901,
          "end": 12906,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 12935,
          "end": 12938,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13034,
          "end": 13041,
          "text": "GDLM-LIN",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13090,
          "end": 13121,
          "text": "interpolated Kneser-Ney ( KNLM )",
          "labels": ["Method"]
        },
        "id": 667
      },
            {
        "value":         {
          "start": 13157,
          "end": 13162,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13176,
          "end": 13217,
          "text": "modified interpolated Kneser-Ney ( MKNLM )",
          "labels": ["Method"]
        },
        "id": 668
      },
            {
        "value":         {
          "start": 13247,
          "end": 13252,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13332,
          "end": 13364,
          "text": "Jelinek-Mercer smoothing ( JMLM )",
          "labels": ["Method"]
        },
        "id": 669
      },
            {
        "value":         {
          "start": 13404,
          "end": 13407,
          "text": "MLEs",
          "labels": ["Method"]
        },
        "id": 671
      },
            {
        "value":         {
          "start": 13558,
          "end": 13563,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13573,
          "end": 13576,
          "text": "MLEs",
          "labels": ["Method"]
        },
        "id": 671
      },
            {
        "value":         {
          "start": 13706,
          "end": 13709,
          "text": "JMLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13755,
          "end": 13758,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13782,
          "end": 13795,
          "text": "trigram models",
          "labels": ["Method"]
        },
        "id": 672
      },
            {
        "value":         {
          "start": 13919,
          "end": 13922,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13926,
          "end": 13930,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 13938,
          "end": 13941,
          "text": "KNLM",
          "labels": ["Method"]
        },
        "id": 675
      },
            {
        "value":         {
          "start": 14020,
          "end": 14023,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 14049,
          "end": 14053,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 14059,
          "end": 14062,
          "text": "KNLM",
          "labels": ["Method"]
        },
        "id": 675
      },
            {
        "value":         {
          "start": 14084,
          "end": 14087,
          "text": "JMLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 14342,
          "end": 14351,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 14678,
          "end": 14680,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 14720,
          "end": 14729,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 14757,
          "end": 14759,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 15239,
          "end": 15245,
          "text": "unigram",
          "labels": ["Method"]
        },
        "id": 1401
      },
            {
        "value":         {
          "start": 15507,
          "end": 15509,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 15513,
          "end": 15515,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 15521,
          "end": 15523,
          "text": "NYT",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 15527,
          "end": 15529,
          "text": "AFP",
          "labels": ["Dataset"]
        },
        "id": 676
      },
            {
        "value":         {
          "start": 15635,
          "end": 15644,
          "text": "Perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 15712,
          "end": 15715,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 15740,
          "end": 15744,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 15905,
          "end": 15909,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 15915,
          "end": 15918,
          "text": "JMLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 15986,
          "end": 15995,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 16070,
          "end": 16088,
          "text": "New York Times data",
          "labels": ["Dataset"]
        },
        "id": 677
      },
            {
        "value":         {
          "start": 16104,
          "end": 16115,
          "text": "AP News data",
          "labels": ["Dataset"]
        },
        "id": 678
      },
            {
        "value":         {
          "start": 16236,
          "end": 16247,
          "text": "perplexities",
          "labels": ["Metric"]
        },
        "id": 679
      },
            {
        "value":         {
          "start": 16445,
          "end": 16452,
          "text": "GDLM-LIN",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16471,
          "end": 16477,
          "text": "trigram",
          "labels": ["Method"]
        },
        "id": 980
      },
            {
        "value":         {
          "start": 16483,
          "end": 16488,
          "text": "bigram",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16532,
          "end": 16541,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 16549,
          "end": 16552,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16727,
          "end": 16730,
          "text": "GDLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16807,
          "end": 16814,
          "text": "GDLM-LIN",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16831,
          "end": 16838,
          "text": "GDLM-LIN",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16919,
          "end": 16922,
          "text": "JMLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 16936,
          "end": 16940,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 17041,
          "end": 17044,
          "text": "JMLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 17104,
          "end": 17109,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 17127,
          "end": 17131,
          "text": "MKNLM",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 17187,
          "end": 17204,
          "text": "modified KneserNey",
          "labels": ["Method"]
        },
        "id": 680
      },
            {
        "value":         {
          "start": 17523,
          "end": 17532,
          "text": "perplexity",
          "labels": ["Metric"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 17546,
          "end": 17564,
          "text": "modified Kneser-Ney",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 17570,
          "end": 17583,
          "text": "Jelinek-Mercer",
          "labels": ["Method"]
        },
        "id": 681
      }
    ],
    "data": {"text": "An Empirical Investigation of Discounting in Cross-Domain Language Models Abstract We investigate the empirical behavior of ngram discounts within and across domains . When a language model is trained and evaluated on two corpora from exactly the same domain , discounts are roughly constant , matching the assumptions of modified Kneser-Ney LMs . However , when training and test corpora diverge , the empirical discount grows essentially as a linear function of the n-gram count . We adapt a Kneser-Ney language model to incorporate such growing discounts , resulting in perplexity improvements over modified Kneser-Ney and Jelinek-Mercer baselines . 1 Introduction Discounting , or subtracting from the count of each n-gram , is one of the core aspects of Kneser-Ney language modeling ( Kneser and Ney , 1995 ) . For all but the smallest n-gram counts , Kneser-Ney uses a single discount , one that does not grow with the ngram count , because such constant-discounting was seen in early experiments on held-out data ( Church and Gale , 1991 ) . However , due to increasing computational power and corpus sizes , language modeling today presents a different set of challenges than it did 20 years ago . In particular , modeling crossdomain effects has become increasingly more important ( Klakow , 2000 ; Moore and Lewis , 2010 ) , and deployed systems must frequently process data that is out-of-domain from the standpoint of the language model . In this work , we perform experiments on heldout data to evaluate how discounting behaves in the cross-domain setting . We find that , when training and testing on corpora that are as similar as possible , empirical discounts indeed do not grow with ngram count , which validates the parametric assumption of Kneser-Ney smoothing . However , when the train and evaluation corpora differ , even slightly , discounts generally exhibit linear growth in the count of the n-gram , with the amount of growth being closely correlated with the corpus divergence . Finally , we build a language model exploiting a parametric form of the growing discount and show perplexity gains of up to 5.4 % over modified Kneser-Ney . 2 Discount Analysis Underlying discounting is the idea that n-grams will occur fewer times in test data than they do in training data . We investigate this quantitatively by conducting experiments similar in spirit to those of Church and Gale ( 1991 ) . Suppose that we have collected counts on two corpora of the same size , which we will call our train and test corpora . For an n-gram w = ( wi , . . . , wn ) , let ktrain ( w ) denote the number of occurrences of w in the training corpus , and ktest ( w ) denote the number of occurrences of w in the test corpus . We define the empirical discount of w to be d ( w ) = ktrain ( w ) ktest ( w ) ; this will be negative when the n-gram occurs more in the test data than in the training data . Let Wi = { w : ktrain ( w ) = i } be the set of n-grams with count i in the training corpus . We define the average empirical discount function as Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics : shortpapers , pages 2429 , Portland , Oregon , June 19-24 , 2011 . Kneser-Ney implicitly makes two assumptions : first , that discounts do not depend on n-gram count , i.e . that d ( i ) is constant in i . Modified Kneser-Ney relaxes this assumption slightly by having independent parameters for 1 - count , 2 - count , and manycount n-grams , but still assumes that d ( i ) is constant for i greater than two . Second , by using the same discount for all n-grams with a given count , KneserNey assumes that the distribution of d ( w ) for w in a particular Wi is well-approximated by its mean . In this section , we analyze whether or not the behavior of the average empirical discount function supports these two assumptions . We perform experiments on various subsets of the documents in the English Gigaword corpus , chiefly drawn from New York Times ( NYT ) and Agence France Presse ( AFP ) .1 2.1 Are Discounts Constant? Similar corpora To begin , we consider the NYT documents from Gigaword for the year 1995 . In order to create two corpora that are maximally domain-similar , we randomly assign half of these documents to train and half of them to test , yielding train and test corpora of approximately 50M words each , which we denote by NYT95 and NYT95 ' . Figure 1 shows the average empirical discounts d ( i ) for trigrams on this pair of corpora . In this setting , we recover the results of Church and Gale ( 1991 ) in that discounts are approximately constant for ngram counts of two or greater . Divergent corpora In addition to these two corpora , which were produced from a single contiguous batch of documents , we consider testing on corpus pairs with varying degrees of domain difference . We construct additional corpora NYT96 , NYT06 , AFP95 , AFP96 , and AFP06 , by taking 50M words from documents in the indicated years of NYT and AFP data . We then collect training counts on NYT95 and alternately take each of our five new corpora as the test data . Figure 1 also shows the average empirical discount curves for these train/test pairs . Even within NYT newswire data , we see growing discounts when the train and test corpora are drawn from different years , and between the NYT and AFP newswire , discounts grow even more quickly . We observed these trends continuing steadily up into ngram counts in the hundreds , beyond which point it becomes difficult to robustly estimate discounts due to fewer n-gram types in this count range . This result is surprising in light of the constant discounts observed for the NYT95 / NYT95 ' pair . Goodman ( 2001 ) proposes that discounts arise from document-level burstiness in a corpus , because language often repeats itself locally within a document , and Moore and Quirk ( 2009 ) suggest that discounting also corrects for quantization error due to estimating a continuous distribution using a discrete maximum likelihood estimator ( MLE ) . Both of these factors are at play in the NYT95 / NYT95 ' experiment , and yet only a small , constant discount is observed . Our growing discounts must therefore be caused by other , larger-scale phenomena , such as shifts in the subjects of news articles over time or in the style of the writing between newswire sources . The increasing rate of discount growth as the source changes and temporal divergence increases lends credence to this hypothesis . 2.2 Nonuniformity of Discounts Figure 1 considers discounting in terms of averaged discounts for each count , which tests one assumption of modified Kneser-Ney , that discounts are a igraip constant function of n-gram counts . In Figure 2 , we investigate the second assumption , namely that the distribution over discounts for a givennn-gram count is well-approximated by its mean . For similar corpora , this seems to be true , with a histogram of test counts for trigrams of count 10 that is nearly symmetric . For divergent corpora , the data exhibit high skew : almost 40 % of the trigrams simply never appear in the test data , and the distribution has very high standard deviation ( 17.0 ) due to a heavy tail ( not shown ) . Using a discount that depends only on the n-gram count is less appropriate in this case . In combination with the growing discounts of section 2 . 1 , these results point to the fact that modified Kneser-Ney does not faithfully models the discounting in even a mildly cross-domain setting . 2.3 Correlation of Divergence and Discounts Intuitively , corpora that are more temporally distant within a particular newswire source should perhaps be slightly more distinct , and still a higher degree of divergence should exist between corpora from different newswire sources . From Figure 1 , we see that this notion agrees with the relative sizes of the observed discounts . We now ask whether growth in discounts is correlated with train/test dissimilarity in a more quantitative way . For a given pair of corpora , we canonicalize the degree of discounting by selecting the point d ( 30 ) , the average empirical dis count for n-grams occurring 30 times in training .2 To measure divergence between the corpus pair , we compute the difference between the log likelihood of the test corpus under the train corpus language model ( using basic Kneser-Ney ) and the likelihood of the test corpus under a jackknife language model from the test itself , which holds out and scores each test n-gram in turn . This dissimilarity metric resembles the cross-entropy difference used by Moore and Lewis ( 2010 ) to subsample for domain adaptation . We compute this canonicalization for each of twenty pairs of corpora , with each corpus containing 240M trigram tokens between train and test . The corpus pairs were chosen to span varying numbers of newswire sources and lengths of time in order to capture a wide range of corpus divergences . Our results are plotted in Figure 3 . The log likelihood difference and d ( 30 ) are negatively correlated with a correlation coefficient value of r = 0.88 , which strongly supports our hypothesis that higher divergence yields higher discounting . One explanation for the remaining variance is that the trigram discount curve depends on the difference between the number of bigram types in the train and test corpora , which can be as large as 10 % : observing more bigram contexts in training fragments the token counts 2One could also imagine instead canonicalizing the curves by using either the exponent or slope parameters from a fitted power law as in section 3 . However , there was sufficient nonlinearity in the average empirical discount curves that neither of these parameters was an accurate proxy for d ( i ) . and leads to smaller observed discounts . 2.4 Related Work The results of section 2.1 point to a remarkably pervasive phenomenon of growing empirical discounts , except in the case of extremely similar corpora . Growing discounts of this sort were previously suggested by the model of Teh ( 2006 ) . However , we claim that the discounting phenomenon in our data is fundamentally different from his models prediction . In the held-out experiments of section 2.1 , growing discounts only emerge when one evaluates against a dissimilar held-out corpus , whereas his model would predict discount growth even in NYT95 / NYT95 ' , where we do not observe it . Adaptation across corpora has also been addressed before . Bellegarda ( 2004 ) describes a range of techniques , from interpolation at either the count level or the model level ( Bacchiani and Roark , 2003 ; Bacchiani et al. , 2006 ) to using explicit models of syntax or semantics . Hsu and Glass ( 2008 ) employ a log-linear model for multiplicatively discounting n-grams in Kneser-Ney ; when they include the logcount of an n-gram as the only feature , they achieve 75 % of their overall word error rate reduction , suggesting that predicting discounts based on n-gram count can substantially improve the model . Their work also improves on the second assumption of Kneser-Ney , that of the inadequacy of the average empirical discount as a discount constant , by employing various other features in order to provide other criteria on which to discount n-grams . Taking a different approach , both Klakow ( 2000 ) and Moore and Lewis ( 2010 ) use subsampling to select the domain-relevant portion of a large , general corpus given a small in-domain corpus . This can be interpreted as a form of hard discounting , and implicitly models both growing discounts , since frequent n-grams will appear in more of the rejected sentences , and nonuniform discounting over n-grams of each count , since the sentences are chosen according to a likelihood criterion . Although we do not consider this second point in constructing our language model , an advantage of our approach over subsampling is that we use our entire training corpus , and in so doing compromise between minimizing errors from data sparsity and accommodating domain shifts to the extent possible . 3 A Growing Discount Language Model We now implement and evaluate a language model that incorporates growing discounts . 3.1 Methods Instead of using a fixed discount for most n-gram counts , as prescribed by modified Kneser-Ney , we discount by an increasing parametric function of the n-gram count . We use a tune set to compute an average empirical discount curve d ( i ) , and fit a function of the form f ( x ) = a + bx ' to this curve using weighted least-Li-loss regression , with the weight for each point proportional to i | Wi | , the total token counts of n-grams occurring that many times in training . To improve the fit of the model , we use dedicated parameters for count - 1 and count - 2 ngrams as in modified Kneser-Ney , yielding a model with five parameters per n-gram order . We call this model GDLM . We also instantiate this model with c fixed to one , so that the model is strictly linear ( GDLM-LIN ) . As baselines for comparison , we use basic interpolated Kneser-Ney ( KNLM ) , with one discount parameter per n-gram order , and modified interpolated Kneser-Ney ( MKNLM ) , with three parameters per n-gram order , as described in ( Chen and Goodman , 1998 ) . We also compare against Jelinek-Mercer smoothing ( JMLM ) , which interpolates the undiscounted MLEs from every order . According to Chen and Goodman ( 1998 ) , it is common to use different interpolation weights depending on the history count of an n-gram , since MLEs based on many samples are presumed to be more accurate than those with few samples . We used five history count buckets so that JMLM would have the same number of parameters as GDLM . All five models are trigram models with type counts at the lower orders and independent discount or interpolation parameters for each order . Parameters for GDLM , MKNLM , and KNLM are initialized based on estimates from d ( i ) : the regression thereof for GDLM , and raw discounts for MKNLM and KNLM . The parameters of JMLM are initialized to constants independent of the data . These initializations are all heuristic and not guaranteed to be optimal , so we then iterate through the parameters of each model several times and perform line search in each to optimize tune-set perplexity . For evaluation , we train , tune , and test on three disjoint corpora . We consider two different training sets : one of 110M words of NYT from 2000 and 2001 ( NYT00 +01 ) , and one of 110M words of AFP from 2002 , 2005 , and 2006 ( AFP02 +05 +06 ) . In both cases , we compute d ( i ) and tune parameters on 110M words of NYT from 2002 and 2003 , and do our final perplexity evaluation on 4M words of NYT from 2004 . This gives us both in-domain and out-of-domain results for our new language model . Our tune set is chosen to be large so that we can initialize parameters based on the average empirical discount curve ; in practice , one could compute empirical discounts based on a smaller tune set with the counts scaled up proportionately , or simply initialize to constant values . We use two different methods to handle out-ofvocabulary ( OOV ) words : one scheme replaces any unigram token occurring fewer than five times in training with an UNK token , yielding a vocabulary of approximately 157K words , and the other scheme only keeps the top 50K words in the vocabulary . The count truncation method has OOV rates of 0.9 % and 1.9 % in the NYT / NYT and NYT / AFP settings , respectively , and the constant-size vocabulary has OOV rates of 2 % and 3.6 % . 3.2 Results Perplexity results are given in Table 1 . As expected , for in-domain data , GDLM performs comparably to MKNLM , since the discounts do not grow and so there is little to be gained by choosing a parameterization that permits this . Out-of-domain , our model outperforms MKNLM and JMLM by approximately 5 % for both vocabulary sizes . The outof-domain perplexity values are competitive with those of Rosenfeld ( 1996 ) , who trained on New York Times data and tested on AP News data under similar conditions , and even more aggressive closing of the vocabulary . Moore and Lewis ( 2010 ) achieve lower perplexities , but they use in-domain training data that we do not include in our setting . We briefly highlight some interesting features of these results . In the small vocabulary cross-domain setting , for GDLM-LIN , we find as the trigram and bigram discount functions that minimize tune set perplexity . For GDLM , In both cases , a growing discount is indeed learned from the tuning procedure , demonstrating the importance of this in our model . Modeling nonlinear discount growth in GDLM yields only a small marginal improvement over the linear discounting model GDLM-LIN , so we prefer GDLM-LIN for its simplicity . A somewhat surprising result is the strong performance of JMLM relative to MKNLM on the divergent corpus pair . We conjecture that this is because the bucketed parameterization of JMLM gives it the freedom to change interpolation weights with n-gram count , whereas MKNLM has essentially a fixed discount . This suggests that modified KneserNey as it is usually parameterized may be a particularly poor choice in cross-domain settings . Overall , these results show that the growing discount phenomenon detailed in section 2 , beyond simply being present in out-of-domain held-out data , provides the basis for a new discounting scheme that allows us to improve perplexity relative to modified Kneser-Ney and Jelinek-Mercer baselines . "}
  },
    {
    "id": "P12-1030",
    "result":     [
            {
        "value":         {
          "start": 684,
          "end": 719,
          "text": "locallookahead node expansion method",
          "labels": ["Method"]
        },
        "id": 681
      },
            {
        "value":         {
          "start": 768,
          "end": 773,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 3496,
          "end": 3502,
          "text": "BIUTEE1",
          "labels": ["Method"]
        },
        "id": 683
      },
            {
        "value":         {
          "start": 4202,
          "end": 4216,
          "text": "local lookahead",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 4476,
          "end": 4513,
          "text": "transformation-based inference systems",
          "labels": ["Method"]
        },
        "id": 685
      },
            {
        "value":         {
          "start": 4517,
          "end": 4536,
          "text": "AI search algorithms",
          "labels": ["Method"]
        },
        "id": 686
      },
            {
        "value":         {
          "start": 4839,
          "end": 4844,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 5014,
          "end": 5027,
          "text": "RTE benchmarks",
          "labels": ["Dataset"]
        },
        "id": 687
      },
            {
        "value":         {
          "start": 6119,
          "end": 6123,
          "text": "EDITS",
          "labels": ["Method"]
        },
        "id": 688
      },
            {
        "value":         {
          "start": 7036,
          "end": 7039,
          "text": "DIRT",
          "labels": ["Dataset"]
        },
        "id": 712
      },
            {
        "value":         {
          "start": 7073,
          "end": 7077,
          "text": "TEASE",
          "labels": ["Dataset"]
        },
        "id": 690
      },
            {
        "value":         {
          "start": 7438,
          "end": 7443,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 7647,
          "end": 7652,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 9630,
          "end": 9646,
          "text": "Best-first search",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 9876,
          "end": 9902,
          "text": "best-first search algorithm",
          "labels": ["Method"]
        },
        "id": 691
      },
            {
        "value":         {
          "start": 10362,
          "end": 10378,
          "text": "best-first search",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 10397,
          "end": 10399,
          "text": "A *",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 10442,
          "end": 10458,
          "text": "best-first search",
          "labels": ["Method"]
        },
        "id": 692
      },
            {
        "value":         {
          "start": 10523,
          "end": 10534,
          "text": "Weighted A *",
          "labels": ["Method"]
        },
        "id": 714
      },
            {
        "value":         {
          "start": 10648,
          "end": 10663,
          "text": "heuristic search",
          "labels": ["Method"]
        },
        "id": 693
      },
            {
        "value":         {
          "start": 10690,
          "end": 10694,
          "text": "K-BFS",
          "labels": ["Method"]
        },
        "id": 694
      },
            {
        "value":         {
          "start": 10759,
          "end": 10769,
          "text": "Beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 12010,
          "end": 12015,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 12061,
          "end": 12071,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 12098,
          "end": 12118,
          "text": "hereafter BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 695
      },
            {
        "value":         {
          "start": 14776,
          "end": 14781,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 15996,
          "end": 16008,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 16057,
          "end": 16069,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 16753,
          "end": 16758,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 17804,
          "end": 17816,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 20177,
          "end": 20207,
          "text": "bruteforce depth-limited search",
          "labels": ["Method"]
        },
        "id": 697
      },
            {
        "value":         {
          "start": 20225,
          "end": 20233,
          "text": "lookahead",
          "labels": ["Method"]
        },
        "id": 699
      },
            {
        "value":         {
          "start": 20359,
          "end": 20367,
          "text": "lookahead",
          "labels": ["Method"]
        },
        "id": 699
      },
            {
        "value":         {
          "start": 22805,
          "end": 22844,
          "text": "LOCAL-LOOKAHEAD GRADIENT SEARCH ( LLGS )",
          "labels": ["Method"]
        },
        "id": 699
      },
            {
        "value":         {
          "start": 22851,
          "end": 22854,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 22866,
          "end": 22878,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 23194,
          "end": 23201,
          "text": "run time",
          "labels": ["Metric"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 23256,
          "end": 23265,
          "text": "proof cost",
          "labels": ["Metric"]
        },
        "id": 702
      },
            {
        "value":         {
          "start": 23495,
          "end": 23506,
          "text": "RTE datasets",
          "labels": ["Dataset"]
        },
        "id": 703
      },
            {
        "value":         {
          "start": 23510,
          "end": 23525,
          "text": "RTE - 5 ( 2009 )",
          "labels": ["Dataset"]
        },
        "id": 704
      },
            {
        "value":         {
          "start": 23531,
          "end": 23543,
          "text": "RTE6 ( 2010 )",
          "labels": ["Dataset"]
        },
        "id": 705
      },
            {
        "value":         {
          "start": 23551,
          "end": 23565,
          "text": "RTE - 5 dataset",
          "labels": ["Dataset"]
        },
        "id": 706
      },
            {
        "value":         {
          "start": 23748,
          "end": 23754,
          "text": "RTE - 6",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 24268,
          "end": 24284,
          "text": "Lucene IR engine3",
          "labels": ["Tool"]
        },
        "id": 708
      },
            {
        "value":         {
          "start": 24407,
          "end": 24412,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 24430,
          "end": 24440,
          "text": "BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 24534,
          "end": 24540,
          "text": "BIUTEEs",
          "labels": ["Method"]
        },
        "id": 710
      },
            {
        "value":         {
          "start": 24555,
          "end": 24561,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 24585,
          "end": 24606,
          "text": "Directional similarity",
          "labels": ["Dataset"]
        },
        "id": 711
      },
            {
        "value":         {
          "start": 24639,
          "end": 24642,
          "text": "DIRT",
          "labels": ["Dataset"]
        },
        "id": 712
      },
            {
        "value":         {
          "start": 24762,
          "end": 24768,
          "text": "ArkRef4",
          "labels": ["Method"]
        },
        "id": 712
      },
            {
        "value":         {
          "start": 24852,
          "end": 24862,
          "text": "BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 25040,
          "end": 25043,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 25160,
          "end": 25171,
          "text": "weighted A *",
          "labels": ["Method"]
        },
        "id": 714
      },
            {
        "value":         {
          "start": 25190,
          "end": 25202,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 25310,
          "end": 25320,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 25441,
          "end": 25444,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 25570,
          "end": 25581,
          "text": "weighted A *",
          "labels": ["Method"]
        },
        "id": 714
      },
            {
        "value":         {
          "start": 25747,
          "end": 25762,
          "text": "dovetailing WA *",
          "labels": ["Method"]
        },
        "id": 713
      },
            {
        "value":         {
          "start": 25784,
          "end": 25795,
          "text": "weighted A *",
          "labels": ["Method"]
        },
        "id": 714
      },
            {
        "value":         {
          "start": 26024,
          "end": 26035,
          "text": "weighted A *",
          "labels": ["Method"]
        },
        "id": 714
      },
            {
        "value":         {
          "start": 26192,
          "end": 26199,
          "text": "run-time",
          "labels": ["Metric"]
        },
        "id": 715
      },
            {
        "value":         {
          "start": 26288,
          "end": 26295,
          "text": "run-time",
          "labels": ["Metric"]
        },
        "id": 715
      },
            {
        "value":         {
          "start": 26661,
          "end": 26666,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 26800,
          "end": 26803,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 26890,
          "end": 26900,
          "text": "BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 26945,
          "end": 26951,
          "text": "RTE - 5",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 26965,
          "end": 26971,
          "text": "RTE - 6",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 27372,
          "end": 27374,
          "text": "RTE",
          "labels": ["Dataset"]
        },
        "id": 716
      },
            {
        "value":         {
          "start": 27418,
          "end": 27425,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 27430,
          "end": 27436,
          "text": "RTE - 5",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 27442,
          "end": 27443,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27448,
          "end": 27454,
          "text": "RTE - 6",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 27475,
          "end": 27481,
          "text": "RTE - 5",
          "labels": ["Dataset"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 27483,
          "end": 27486,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 27527,
          "end": 27537,
          "text": "BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 27628,
          "end": 27639,
          "text": "McNemar test",
          "labels": ["Method"]
        },
        "id": 717
      },
            {
        "value":         {
          "start": 27646,
          "end": 27649,
          "text": "RTE6",
          "labels": ["Dataset"]
        },
        "id": 718
      },
            {
        "value":         {
          "start": 27672,
          "end": 27675,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 27734,
          "end": 27739,
          "text": "BIUTEE",
          "labels": ["Method"]
        },
        "id": 719
      },
            {
        "value":         {
          "start": 27923,
          "end": 27926,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 28063,
          "end": 28070,
          "text": "run time",
          "labels": ["Metric"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 28078,
          "end": 28092,
          "text": "local-lookahead",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 28137,
          "end": 28140,
          "text": "LLGS",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 28203,
          "end": 28217,
          "text": "local-lookahead",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 28317,
          "end": 28334,
          "text": "standard lookahead",
          "labels": ["Method"]
        },
        "id": 720
      },
            {
        "value":         {
          "start": 28349,
          "end": 28380,
          "text": "brute-force depth-limited search",
          "labels": ["Method"]
        },
        "id": 721
      },
            {
        "value":         {
          "start": 28427,
          "end": 28446,
          "text": "exhaustive lookahead",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 28552,
          "end": 28558,
          "text": "runtime",
          "labels": ["Metric"]
        },
        "id": 1525
      },
            {
        "value":         {
          "start": 28637,
          "end": 28651,
          "text": "local lookahead",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 28666,
          "end": 28671,
          "text": "proofs",
          "labels": ["Metric"]
        },
        "id": 724
      },
            {
        "value":         {
          "start": 28677,
          "end": 28684,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 28694,
          "end": 28708,
          "text": "local lookahead",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 28743,
          "end": 28762,
          "text": "exhaustive lookahead",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 29123,
          "end": 29130,
          "text": "run time",
          "labels": ["Metric"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 29164,
          "end": 29174,
          "text": "BIUTEE-orig",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 29222,
          "end": 29241,
          "text": "AI-search algorithms",
          "labels": ["Method"]
        },
        "id": 725
      },
            {
        "value":         {
          "start": 29338,
          "end": 29348,
          "text": "cost proofs",
          "labels": ["Metric"]
        },
        "id": 726
      },
            {
        "value":         {
          "start": 29423,
          "end": 29450,
          "text": "Monte-Carlo style approaches",
          "labels": ["Method"]
        },
        "id": 727
      }
    ],
    "data": {"text": "Efficient Search for Transformation-based Inference Abstract This paper addresses the search problem in textual inference , where systems need to infer one piece of text from another . A prominent approach to this task is attempts to transform one text into the other through a sequence of inference-preserving transformations , a.k.a. a proof , while estimating the proofs validity . This raises a search challenge of finding the best possible proof . We explore this challenge through a comprehensive investigation of prominent search algorithms and propose two novel algorithmic components specifically designed for textual inference : a gradient-style evaluation function , and a locallookahead node expansion method . Evaluations , using the open-source system , BIUTEE , show the contribution of these ideas to search efficiency and proof quality . 1 Introduction In many NLP settings it is necessary to identify that a certain semantic inference relation holds between two pieces of text . For example , in paraphrase recognition it is necessary to identify that the meanings of two text fragments are roughly equivalent . In passage retrieval for question answering , it is needed to detect text passages from which a satisfying answer can be inferred . A generic formulation for the inference relation between two texts is given by the Recognizing Textual Entailment ( RTE ) paradigm ( Dagan et al. , 2005 ) , which is adapted here for our investigation . In this setting , a system is given two text fragments , termed text ( T ) and hypothesis ( H ) , and has to recognize whether the hypothesis is entailed by ( inferred from ) the text . An appealing approach to such textual inferences is to explicitly transform T into H , using a sequence of transformations ( Bar-Haim et al. , 2007 ; Harmeling , 2009 ; Mehdad , 2009 ; Wang and Manning , 2010 ; Heilman and Smith , 2010 ; Stern and Dagan , 2011 ) . Examples of such possible transformations are lexical substitutions ( e.g. letter * message ) and predicate-template substitutions ( e.g. X [ verbactive ] Y * Y [ verb-passive ] by X ) , which are based on available knowledge resources . Another example is coreference substitutions , such as replacing he with the employee if a coreference resolver has detected that these two expressions corefer . Table 1 exemplifies this approach for a particular T-H pair . The rationale behind this approach is that each transformation step should preserve inference validity , such that each text generated along this process is indeed inferred from the preceding one . An inherent aspect in transformation-based inference is modeling the certainty that each inference step is valid . This is usually achieved by a costbased or probabilistic model , which quantifies confidence in the validity of each individual transformation and consequently of the complete chain of inference . Given a set of possible transformations , there may be many transformation sequences that would transform T to H . This creates a very large search space , where systems have to find the best transformation sequence the one of lowest cost , or of highest probability . To the best of our knowledge , this search challenge has not been investigated yet in a substan tial manner : each of the above-cited works described the search method they used , but none of them tried alternative methods while evaluating search performance . Furthermore , while experimenting with our own open-source inference system , BIUTEE1 , we observed that search efficiency is a major issue , often yielding practically unsatisfactory run-times . This paper investigates the search problem in transformation-based textual inference , naturally falling within the framework of heuristic AI ( Artificial Intelligence ) search . To facilitate such investigation , we formulate a generic search scheme which incorporates many search variants as special cases and enable a meaningful comparison between the algorithms . Under this framework , we identify special characteristics of the textual inference search space , that lead to the development of two novel algorithmic components : a special lookahead method for node expansion , named local lookahead , and a gradient-based evaluation function . Together , they yield a new search algorithm , which achieved substantially superior search performance in our evaluations . The remainder of this paper is organized as follows . Section 2 provides an overview of transformation-based inference systems , AI search algorithms , and search methods realized in prior inference systems . Section 3 formulates the generic search scheme that we have investigated , which covers a broad range of known algorithms , and presents our own algorithmic contributions . These new algorithmic contributions were implemented in our system , BIUTEE . In Section 4 we evaluate them empirically , and show that they improve search efficiency as well as solutions quality . Search performance is evaluated on two recent RTE benchmarks , in terms of runtime , ability to find lower-cost transformation chains and impact on overall inference . 2 Background Applying sequences of transformations to recognize textual inference was suggested by several works . Such a sequence may be referred to as a proof , in the sense that it is used to prove the hypothesis from the text . Although various works along this line differ from each other in several respects , many of them share the common challenge of finding an optimal proof . The following paragraphs review the major research approaches in this direction . We focus on methods that perform transformations over parse trees , and highlight the search challenge with which they are faced . 2.1 Transformation-based textual inference Several researchers suggested using various types of transformations in order to derive H from T . Some suggested a set of predefined transformations , for example , insertion , deletion and substitution of parse-tree nodes , by which any tree can be transformed to any other tree . These transformations were used by the open-source system EDITS ( Mehdad , 2009 ) , and by ( Wang and Manning , 2010 ) . Since the above mentioned transformations are limited in capturing certain interesting and prevalent semantic phenomena , an extended set of tree edit operations ( e.g. , relabel-edge , move-sibling , etc. ) was proposed by Heilman and Smith ( 2010 ) . Similarly , Harmeling ( 2009 ) suggested a heuristic set of 28 transformations , which include various types of node-substitutions as well as restructuring of the entire parse-tree . In contrast to such predefined sets of transformations , knowledge oriented approaches were sug gested by Bar-Haim et al. ( 2007 ) and de Salvo Braz et al. ( 2005 ) . Their transformations are defined by knowledge resources that contain a large amount of entailment rules , or rewrite rules , which are pairs of parse-tree fragments that entail one another . Typical examples for knowledge resources of such rules are DIRT ( Lin and Pantel , 2001 ) , and TEASE ( Szpektor et al . , 2004 ) , as well as syntactic transformations constructed manually . In addition , they used knowledge-based lexical substitutions . However , when only knowledge-based transformations are allowed , transforming the text into the hypothesis is impossible in many cases . This limitation is dealt by our open-source integrated framework , BIUTEE ( Stern and Dagan , 2011 ) , which incorporates knowledge-based transformations ( entailment rules ) with a set of predefined tree-edits . Motivated by the richer structure and search space provided by BIUTEE , we adopted it for our empirical investigations . The semantic validity of transformation-based inference is usually modeled by defining a cost or a probability estimation for each transformation . Costs may be defined manually ( Kouylekov and Magnini , 2005 ) , but are usually learned automatically ( Harmeling , 2009 ; Mehdad , 2009 ; Wang and Manning , 2010 ; Heilman and Smith , 2010 ; Stern and Dagan , 2011 ) . A global cost ( or probability estimation ) for a complete sequence of transformations is typically defined as the sum of the costs of the involved transformations . Finding the lowest cost proof , as needed for determining inference validity , is the focus of our research . Textual inference systems limited to the standard tree-edit operations ( insertion , deletion , substitution ) can use an exact algorithm that finds the optimal solution in polynomial time under certain constraints ( Bille , 2005 ) . Nevertheless , for the extended set of transformations it is unlikely that efficient exact algorithms for finding lowest-cost sequences are available ( Heilman and Smith , 2010 ) . In this harder case , the problem can be viewed as an AI search problem . Each state in the search space is a parse-tree , where the initial state is the text parse-tree , the goal state is the hypothesis parse-tree , and we search for the shortest ( in terms of costs ) path of transformations from the initial state to the goal state . Next we briefly review major concepts from the field of AI search and summarize some relevant proposed solutions . 2.2 Search Algorithms Search algorithms find a path from an initial state to a goal state by expanding and generating states in a search space . The term generating a state refers to creating a data structure that represents it , while expanding a state means generating all its immediate derivations . In our domain , each state is a parse tree , which is expanded by performing all applicable transformations . Best-first search is a common search framework . It maintains an open list ( denoted hereafter as OPEN ) containing all the generated states that have not been expanded yet . States in OPEN are prioritized by an evaluation function , f ( s ) . A best-first search algorithm iteratively removes the best state ( according to f ( s ) ) from OPEN , and inserts new states being generated by expanding this best state . The evaluation function is usually a linear combination of the shortest path found from the start state to state s , denoted by g ( s ) , and a heuristic function , denoted by h ( s ) , which estimates the cost of reaching a goal state from s . Many search algorithms can be viewed as special cases or variations of best-first search . The well-known A * ( Hart et al . , 1968 ) . algorithm is a best-first search that uses an evaluation function f ( s ) = g ( s ) + h ( s ) . Weighted A * ( Pohl , 1970 ) uses an evaluation function f ( s ) = w g ( s ) + h ( s ) , where w is a parameter , while pure heuristic search uses f ( s ) = h ( s ) . K-BFS ( Felner et al . , 2003 ) expands k states in each iteration . Beam search ( Furcy and Koenig , 2005 ; Zhou and Hansen , 2005 ) limits the number of states stored in OPEN , while Greedy search limits OPEN to contain only the single best state generated in the current iteration . The search algorithm has crucial impact on the quality of proof found by a textual inference system , as well as on its efficiency . Next , we describe search strategies used in prior works for textual inference . 2.3 Search in prior inference models In spite of being a fundamental problem , prior solutions to the search challenge in textual inference were mostly ad-hoc . Furthermore , there was no investigation of alternative search methods , and no evaluation of search efficiency and quality was reported . For example , in ( Harmeling , 2009 ) the order by which the transformations are performed is predetermined , and in addition many possible derivations are discarded , to prevent exponential explosion . Handling the search problem in ( Heilman and Smith , 2010 ) was by a variant of greedy search , driven by a similarity measure between the current parse-tree and the hypothesis , while ignoring the cost already paid . In addition , several constraints on the search space were implemented . In the earlier version of BIUTEE ( Stern and Dagan , 2011 ) 2 , a version of beam search was incorporated , named hereafter BIUTEE-orig . This algorithm uses the evaluation function f ( s ) = g ( s ) + wi h ( s ) , where in each iteration ( i ) the value of w is increased , to ensure successful termination of the search . Nevertheless , its efficiency and quality were not investigated . In this paper we consider several prominent search algorithms and evaluate their quality . The evaluation concentrates on two measures : the runtime required to find a proof , and proof quality ( measured by its cost ) . In addition to evaluating standard search algorithms we propose two novel components specifically designed for proof-based textualinference and evaluate their contribution . 3 Search for Textual Inference In this section we formalize our search problem and specify a unifying search scheme by which we test several search algorithms in a systematic manner . Then we propose two novel algorithmic components specifically designed for our problem . We conclude by presenting our new search algorithm which combines these two ideas . 3.1 Inference and search space formalization Let t be a parse tree , and let o be a transformation . Applying o on t , yielding t ' , is denoted by t Xo t ' . If the underlying meaning of t ' can indeed be inferred from the underlying meaning of t , then we refer to the application of o as valid . Let O = ( o1 , o2 , ... on ) be a sequence of transformations , such that t0 Xo1 t1 Xo2 t2 ... Xon tn . We write t0 XO tn , and say that tn can be proven from t0 by applying the sequence O . The proof might be valid , if all the transformations involved are valid , or invalid otherwise . An inference system specifies a cost , C ( o ) , for each transformation o . In most systems the costs are automatically learned . The interpretation of a high cost is that it is unlikely that applying o will be valid . The cost of a sequence O = ( o1 , o2 , ... on ) is defined as Eni = 1 C ( o ) ( or , in some systems , n i = 1 C ( o ) ) . Denoting by tT and tH the text parse tree and the hypothesis parse tree , a proof system has to find a sequence O with minimal cost such that tT XO tH . This forms a search problem of finding the lowest-cost proof among all possible proofs . The search space is defined as follows . A state s is a parse-tree . The start state is tT and the goal state is tH . In some systems any state s in which tH is embedded is considered as goal as well . Given a state s , let [ o ( 1 ) , o ( 2 ) ... o ( m ) I be m transformations that can be applied on it . Expanding s means generating m new states , s ( j ) , j = 1 ... m , such that s Xo ( ;) s ( j ) . The number m is called branching factor . Our empirical observations on BIUTEE showed that its branching factor ranges from 2 - 3 for some states to about 30 for other states . 3.2 Search Scheme Our empirical investigation compares a range prominent search algorithms , described in Section 2 . To facilitate such investigation , we formulate them in the following unifying scheme ( Algorithm 1 ) . Initially , the open list , OPEN contains the initial state . Then , the best kexpand states from OPEN are chosen , according to the evaluation function f ( s ) ( line 3 ) , and expanded using the expansion function expand ( s ) . In classical search algorithms , expand ( s ) means generating a set of states by applying all the possible state transition operators to s. Next , we remove from OPEN the states which were expanded , and add the newly generated states . Finally , we keep in OPEN only the best kmaintain states , according to the evaluation function f ( s ) ( line 6 ) . This process repeats until the goal state is found in BEST ( line 7 ) . Table 2 specifies how known search algorithms , described in Section 2 , fit into the unified search scheme . Since runtime efficiency is crucial in our domain , we focused on improving one of the simple but fast algorithms , namely , greedy search . To improve the quality of the proof found by greedy search , we introduce new algorithmic components for the expansion and evaluation functions , as described in the next two subsections , while maintaining efficiency by keeping kmaintain = kexpand = 1 3.3 Evaluation function In most domains , the heuristic function h ( s ) estimates the cost of the minimal-cost path from a current state , s , to a goal state . Having such a function , the value g ( s ) + h ( s ) estimates the expected total cost of a search path containing s . In our domain , it is yet unclear how to calculate such a heuristic function . Given a state s , systems typically estimate the difference ( the gap ) between s and the hypothesis tH ( the goal state ) . In BIUTEE this is quantified by the number of parse-tree nodes and edges of tH that do not exist in s . However , this does not give an estimation for the expected cost of the path ( the sequence of transformations ) from s to the goal state . This is because the number of nodes and edges that can be changed by a single transformation can vary from a single node to several nodes ( e.g. , by a lexical syntactic entailment rule ) . Moreover , even if two transformations change the same number of nodes and edges , their costs might be significantly different . Consequently , the measurement of the cost accumulated so far ( g ( s ) ) and the remaining gap to tH ( h ( s ) ) are unrelated . We note that a more sophisticated heuristic function was suggested by Heilman and Smith ( 2010 ) , based on tree-kernels . Nevertheless , this heuristic function , serving as h ( s ) , is still unrelated to the transformation costs ( g ( s ) ) . We therefore propose a novel gradient-style function to overcome this difficulty . Our function is designed for a greedy search in which OPEN always contains a single state , s . Let si be a state generated from s , the cost of deriving si from s is Ag ( si ) = g ( si ) g ( s ) . Similarly , the reduction in the value of the heuristic function is de h ( j ) . Informally , this function measures how costly it is to derive si relative to the obtained decrease in the remaining gap to the goal state . For the edge case in which h ( s ) h ( si ) G 0 , we define f ( si ) = oo . Empirically , we show in our experiments that the function f ( s ) performs better than the traditional functions f ( s ) = g ( s ) + h ( s ) and f , , , ( s ) = g ( s ) + w h ( s ) in our domain . 3.4 Node expansion method When examining the proofs produced by the above mentioned algorithms , we observed that in many cases a human could construct proofs that exhibit some internal structure , but were not revealed by the algorithms . Observe , for example , the proof in Table 1 . It can be seen that transformations 2,3 and 4 strongly depend on each other . Applying transformation 3 requires first applying transformation 2 , and similarly 4 could not be applied unless 2 and 3 are first applied . Moreover , there is no gain in applying transformations 2 and 3 , unless transformation 4 is applied as well . On the other hand , transformation 1 does not depend on any other transformation . It may be performed at any point along the proof , and moreover , changing all other transformations would not affect it . Carefully examining many examples , we generalized this phenomenon as follows . Often , a sequence of transformations can be decomposed into a set of coherent subsequences of transformations , where in each subsequence the transformations strongly depend on each other , while different subsequences are independent . This phenomenon can be utilized in the following way : instead of searching for a complete sequence of transformations that transform tT into tH , we can iteratively search for independent coherent subsequences of transformations , such that a combination of these subsequences will transform tT into tH . This is somewhat similar to the technique of applying macro operators , which is used in automated planning ( Botea et al. , 2005 ) and puzzle solving ( Korf , 1985 ) . One technique for finding such subsequences is to perform , for each state being expanded , a bruteforce depth-limited search , also known as lookahead ( Russell and Norvig , 2010 ; Bulitko and Lustrek , 2006 ; Korf , 1990 ; Stern et al . , 2010 ) . However , performing such lookahead might be slow if the branching factor is large . Fortunately , in our domain , coherent subsequences have the following characteristic which can be leveraged : typically , a transformation depends on a previous one only if it is performed over some nodes which were affected by the previous transformation . Accordingly , our proposed algorithm searches for coherent subsequences , in which each subsequent transformation must be applied to nodes that were affected by the previous transformation . Formally , let o be a transformation that has been applied on a tree t , yielding t ' . Qaffected ( o , t ' ) denotes the subset of nodes in t ' which were affected ( modified or created ) by the application of o. Next , for a transformation o , applied on a parse tree t , we define Qrequired ( t , o ) as the subset of ts nodes required for applying o ( i.e. , in the absence of these nodes , o could not be applied ) . Finally , let t be a parse-tree and Q be a subset of its nodes . enabled ops ( t , Q ) is a function that returns the set of the transformations that can be applied on t , which require at least one of the nodes in Q. Formally , enabled ops ( t , Q ) - [ o E 0 : Q n Qrequired ( t , o ) = 01 , where 0 is the set of transformations that can be applied on t . In our algorithm , Q is the set of nodes that were affected by the preceding transformation of the constructed subsequence . The recursive procedure described in Algorithm 2 generates all coherent subsequences of lengths up to d . It should be initially invoked with t - the current state ( parse tree ) being expanded , Q - the set of all its nodes , d - the maximal required length , and 0 as an empty initial sequence . We use Oo as concatenation of an operation o to a subsequence O . The loop in lines 5 - 8 iterates over transformations that can be applied on the input tree , t , requiring the same nodes that were affected by the previous transformation of the subsequence being constructed . Note that in the first call enabled ops ( t , Q ) contain all operations that can be applied on t , with no restriction . Applying an operation o results in a new subsequence O o . This subsequence will be part of the set of subsequences found by the procedure . In addition , it will be used in the next recursive call as the prefix of additional ( longer ) subsequences . 3.5 Local-lookahead gradient search We are now ready to define our new algorithm LOCAL-LOOKAHEAD GRADIENT SEARCH ( LLGS ) . In LLGS , like in greedy search , kmaintain = kexpand = L expand ( s ) is defined to return all states generated by subsequences found by the local-lookahead procedure , while the evaluation function is defined as f = fA ( see last row of Table 2 ) . 4 Evaluation In this section we first evaluate the search performance in terms of efficiency ( run time ) , the quality of the found proofs ( as measured by proof cost ) , and overall inference performance achieved through various search algorithms . Finally we analyze the contribution of our two novel components . 4.1 Evaluation settings We performed our experiments on the last two published RTE datasets : RTE - 5 ( 2009 ) and RTE6 ( 2010 ) . The RTE - 5 dataset is composed of a training and test corpora , each containing 600 texthypothesis pairs , where in half of them the text entails the hypothesis and in the other half it does not . In RTE - 6 , each of the training and test corpora consists of 10 topics , where each topic contains 10 documents . Each corpus contains a set of hypotheses ( 211 in the training dataset , and 243 in the test dataset ) , along with a set of candidate entailing sentences for each hypothesis . The system has to find for each hypothesis which candidate sentences entail it . To improve speed and results , we used the filtering mechanism suggested by ( Mirkin et al . , 2009 ) , which filters the candidate sentences by the Lucene IR engine3 . Thus , only top 20 candidates per hypothesis were tested Evaluation of each of the algorithms was performed by running BIUTEE while replacing BIUTEE-orig with this algorithm . We employed a comprehensive set of knowledge resources ( available in BIUTEEs web site ) : WordNet ( Fellbaum , 1998 ) , Directional similarity ( Kotlerman et al . , 2010 ) , DIRT ( Lin and Pantel , 2001 ) and generic syntactic rules . In addition , we used coreference substitutions , detected by ArkRef4 . We evaluated several known algorithms , described in Table 2 above , as well as BIUTEE-orig . The latter is a strong baseline , which outperforms known search algorithms in generating low cost proofs . We compared all the above mentioned algorithms to our novel one , LLGS . We used the training dataset for parameter tuning , which controls the trade-off between speed and quality . For weighted A * , as well as for greedy search , we used w = 6.0 , since , for a few instances , lower values of w resulted in prohibitive runtime . For beam search we used k = 150 , since higher val ues of k did not improve the proof cost on the training dataset . The value of d in LLGS was set to 3 . d = 4 yielded the same proof costs , but was about 3 times slower . Since lower values of w could be used by weighted A * for most instances , we also ran experiments where we varied the value of w according to the dovetailing method suggested in ( Valenzano et al . , 2010 ) ( denoted dovetailing WA * ) as follows . When weighted A * has found a solution , we reran it with a new value of w , set to half of the previous value . The idea is to guide the search for lower cost solutions . This process was halted when the total number of states generated by all weighted A * instances exceeded a predefined constant ( set to 10 , 000 ) . 4.2 Search performance This experiment evaluates the search algorithms in both efficiency ( run-time ) and proof quality . Efficiency is measured by the average CPU ( Intel Xeon 2.5 GHz ) run-time ( in seconds ) for finding a complete proof for a text-hypothesis instance , and by the average number of generated states along the search . Proof quality is measured by its cost . The comparison of costs requires that all experiments are performed on the same model which was learned during training . Thus , in the training phase we used the original search of BIUTEE , and then ran the test phase with each algorithm separately . The results , presented in Table 3 , show that our novel algorithm , LLGS , outperforms all other algorithms in finding lower cost proofs . The second best is BIUTEE-orig which is much slower by a factor of 3 ( on RTE - 5 ) to 8 ( on RTE - 6 ) 5 . While inherently fast algorithms , particularly greedy and pure heuristic , achieve faster running times , they achieve lower proof quality , as well as lower overall inference performance ( see next subsection ) . 4.3 Overall inference performance In this experiment we test whether , and how much , finding better proofs , by a better search algorithm , improves overall success rate of the RTE system . Table 4 summarizes the results ( accuracy in RTE - 5 and F1 in RTE - 6 ) . We see that in RTE - 5 LLGS outperforms all other algorithms , and BIUTEE-orig is the second best . This result is statistically significant with p < 0.02 according to McNemar test . In RTE6 we see that although LLGS tends to finds lower cost proofs , as shown in Table 3 , BIUTEE obtains slightly lower results when utilizing this algorithm . 4.4 Component evaluation In this experiment we examine separately our two novel components . We examined fA by running LLGS with alternative evaluation functions . The results , displayed in Table 5 , show that using fA yields better proofs and also improves run time . Our local-lookahead ( Subsection 3.4 ) was examined by running LLGS with alternative node expansion methods . One alternative to local-lookahead is standard expansion by generating all immediate derivations . Another alternative is to use the standard lookahead , in which a brute-force depth-limited search is performed in each iteration , termed here exhaustive lookahead . The results , presented in Table 6 , show that by avoiding any type of lookahead one can achieve fast runtime , while compromising proof quality . On the other hand , both exhaustive and local lookahead yield better proofs and accuracy , while local lookahead is more than 4 times faster than exhaustive lookahead . 5 Conclusion In this paper we investigated the efficiency and proof quality obtained by various search algorithms . Consequently , we observed special phenomena of the search space in textual inference and proposed two novel components yielding a new search algorithm , targeted for our domain . We have shown empirically that ( 1 ) this algorithm improves run time by factors of 3 - 8 relative to BIUTEE-orig , and by similar factors relative to standard AI-search algorithms that achieve similar proof quality ; and ( 2 ) outperforms all other algorithms in finding low cost proofs . In future work we plan to investigate other search paradigms , e.g . , Monte-Carlo style approaches ( Kocsis and Szepesvari , 2006 ) , which do not fall under the AI search scheme covered in this paper . In addition , while our novel components were motivated by the search space of textual inference , we foresee their potential utility in other application areas for search , such as automated planning and scheduling . "}
  },
    {
    "id": "P12-1032",
    "result":     [
            {
        "value":         {
          "start": 450,
          "end": 477,
          "text": "structured label propagation",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 765,
          "end": 783,
          "text": "IWSLT and NIST data",
          "labels": ["Dataset"]
        },
        "id": 729
      },
            {
        "value":         {
          "start": 1406,
          "end": 1442,
          "text": "minimum Bayes risk ( MBR ) approaches",
          "labels": ["Method"]
        },
        "id": 730
      },
            {
        "value":         {
          "start": 1582,
          "end": 1599,
          "text": "minimal Bayes risk",
          "labels": ["Method"]
        },
        "id": 731
      },
            {
        "value":         {
          "start": 1860,
          "end": 1871,
          "text": "MBR decoding",
          "labels": ["Method"]
        },
        "id": 732
      },
            {
        "value":         {
          "start": 2008,
          "end": 2029,
          "text": "Collaborative decoding",
          "labels": ["Method"]
        },
        "id": 733
      },
            {
        "value":         {
          "start": 2100,
          "end": 2105,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 2157,
          "end": 2183,
          "text": "Hypothesis mixture decoding",
          "labels": ["Method"]
        },
        "id": 734
      },
            {
        "value":         {
          "start": 3651,
          "end": 3683,
          "text": "graph-based semi-supervised model",
          "labels": ["Method"]
        },
        "id": 735
      },
            {
        "value":         {
          "start": 4075,
          "end": 4091,
          "text": "label propagation",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 4341,
          "end": 4357,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 4555,
          "end": 4581,
          "text": "label propagation algorithm",
          "labels": ["Method"]
        },
        "id": 738
      },
            {
        "value":         {
          "start": 4650,
          "end": 4666,
          "text": "label propagation",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 4748,
          "end": 4752,
          "text": "IWSLT",
          "labels": ["Dataset"]
        },
        "id": 796
      },
            {
        "value":         {
          "start": 4758,
          "end": 4766,
          "text": "NIST data",
          "labels": ["Dataset"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 4991,
          "end": 5023,
          "text": "graph-based translation consensus",
          "labels": ["Method"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 5049,
          "end": 5064,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 5634,
          "end": 5668,
          "text": "structured label propagation method",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 5835,
          "end": 5851,
          "text": "label propagation",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 6004,
          "end": 6041,
          "text": "structured label propagation algorithm",
          "labels": ["Method"]
        },
        "id": 746
      },
            {
        "value":         {
          "start": 6087,
          "end": 6097,
          "text": "graph model",
          "labels": ["Method"]
        },
        "id": 744
      },
            {
        "value":         {
          "start": 6366,
          "end": 6382,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 6637,
          "end": 6653,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 6950,
          "end": 6966,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 7466,
          "end": 7498,
          "text": "graph-based translation consensus",
          "labels": ["Method"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 8043,
          "end": 8059,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 8096,
          "end": 8112,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 8475,
          "end": 8491,
          "text": "graph-based model",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 8519,
          "end": 8535,
          "text": "label propagation",
          "labels": ["Method"]
        },
        "id": 745
      },
            {
        "value":         {
          "start": 11321,
          "end": 11337,
          "text": "Dice co-efficient",
          "labels": ["Metric"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 11359,
          "end": 11365,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 11415,
          "end": 11421,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 11448,
          "end": 11464,
          "text": "Dice co-efficient",
          "labels": ["Metric"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 11676,
          "end": 11679,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 11760,
          "end": 11797,
          "text": "structured label propagation algorithm",
          "labels": ["Method"]
        },
        "id": 746
      },
            {
        "value":         {
          "start": 11914,
          "end": 11946,
          "text": "graph-based translation consensus",
          "labels": ["Method"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 12396,
          "end": 12399,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 12421,
          "end": 12427,
          "text": "i-grams",
          "labels": ["Method"]
        },
        "id": 746
      },
            {
        "value":         {
          "start": 12522,
          "end": 12534,
          "text": "edit distance",
          "labels": ["Metric"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 12538,
          "end": 12550,
          "text": "string kernel",
          "labels": ["Metric"]
        },
        "id": 748
      },
            {
        "value":         {
          "start": 12566,
          "end": 12570,
          "text": "ngram",
          "labels": ["Method"]
        },
        "id": 749
      },
            {
        "value":         {
          "start": 12897,
          "end": 12902,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 13118,
          "end": 13138,
          "text": "graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 13892,
          "end": 13907,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 14003,
          "end": 14022,
          "text": "alternative training",
          "labels": ["Method"]
        },
        "id": 750
      },
            {
        "value":         {
          "start": 14339,
          "end": 14374,
          "text": "Minimum Error Rate Training ( MERT )",
          "labels": ["Method"]
        },
        "id": 751
      },
            {
        "value":         {
          "start": 14572,
          "end": 14575,
          "text": "MERT",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 14599,
          "end": 14626,
          "text": "structured label propagation",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 14632,
          "end": 14635,
          "text": "MERT",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 14652,
          "end": 14655,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 14820,
          "end": 14840,
          "text": "graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 15026,
          "end": 15046,
          "text": "graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 15611,
          "end": 15613,
          "text": "MLE",
          "labels": ["Method"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 16337,
          "end": 16340,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 16799,
          "end": 16819,
          "text": "Graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 19542,
          "end": 19547,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 19668,
          "end": 19700,
          "text": "graph-based translation consensus",
          "labels": ["Method"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 19808,
          "end": 19815,
          "text": "BLEU - 4",
          "labels": ["Metric"]
        },
        "id": 753
      },
            {
        "value":         {
          "start": 19888,
          "end": 19915,
          "text": "bootstrap re-sampling method",
          "labels": ["Method"]
        },
        "id": 754
      },
            {
        "value":         {
          "start": 19956,
          "end": 19965,
          "text": "confidence",
          "labels": ["Metric"]
        },
        "id": 755
      },
            {
        "value":         {
          "start": 20070,
          "end": 20083,
          "text": "IWSLT data set",
          "labels": ["Dataset"]
        },
        "id": 773
      },
            {
        "value":         {
          "start": 20100,
          "end": 20112,
          "text": "NIST data set",
          "labels": ["Dataset"]
        },
        "id": 769
      },
            {
        "value":         {
          "start": 20170,
          "end": 20200,
          "text": "Bracketing Transduction Grammar",
          "labels": ["Method"]
        },
        "id": 757
      },
            {
        "value":         {
          "start": 20233,
          "end": 20250,
          "text": "CKY-style decoding",
          "labels": ["Method"]
        },
        "id": 758
      },
            {
        "value":         {
          "start": 20297,
          "end": 20311,
          "text": "maximum entropy",
          "labels": ["Method"]
        },
        "id": 934
      },
            {
        "value":         {
          "start": 20400,
          "end": 20410,
          "text": "BTG decoder",
          "labels": ["Method"]
        },
        "id": 760
      },
            {
        "value":         {
          "start": 20533,
          "end": 20542,
          "text": "IWSLT data",
          "labels": ["Dataset"]
        },
        "id": 789
      },
            {
        "value":         {
          "start": 20551,
          "end": 20581,
          "text": "IWSLT 2009 dialog task data set",
          "labels": ["Dataset"]
        },
        "id": 762
      },
            {
        "value":         {
          "start": 20615,
          "end": 20618,
          "text": "BTEC",
          "labels": ["Dataset"]
        },
        "id": 763
      },
            {
        "value":         {
          "start": 20624,
          "end": 20641,
          "text": "SLDB training data",
          "labels": ["Dataset"]
        },
        "id": 764
      },
            {
        "value":         {
          "start": 20758,
          "end": 20780,
          "text": "5 - gram language model",
          "labels": ["Method"]
        },
        "id": 770
      },
            {
        "value":         {
          "start": 20855,
          "end": 20861,
          "text": "devset9",
          "labels": ["Dataset"]
        },
        "id": 766
      },
            {
        "value":         {
          "start": 20893,
          "end": 20896,
          "text": "MERT",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 20913,
          "end": 20919,
          "text": "devset8",
          "labels": ["Dataset"]
        },
        "id": 767
      },
            {
        "value":         {
          "start": 20929,
          "end": 20946,
          "text": "Chinese DIALOG set",
          "labels": ["Dataset"]
        },
        "id": 768
      },
            {
        "value":         {
          "start": 20974,
          "end": 20983,
          "text": "IWSLT data",
          "labels": ["Dataset"]
        },
        "id": 789
      },
            {
        "value":         {
          "start": 21082,
          "end": 21094,
          "text": "NIST data set",
          "labels": ["Dataset"]
        },
        "id": 769
      },
            {
        "value":         {
          "start": 21137,
          "end": 21158,
          "text": "NIST 2008 training set",
          "labels": ["Dataset"]
        },
        "id": 769
      },
            {
        "value":         {
          "start": 21324,
          "end": 21346,
          "text": "5 - gram language model",
          "labels": ["Method"]
        },
        "id": 770
      },
            {
        "value":         {
          "start": 21365,
          "end": 21380,
          "text": "Giga-Word corpus",
          "labels": ["Dataset"]
        },
        "id": 770
      },
            {
        "value":         {
          "start": 21508,
          "end": 21528,
          "text": "NIST03 evaluation set",
          "labels": ["Dataset"]
        },
        "id": 771
      },
            {
        "value":         {
          "start": 21550,
          "end": 21582,
          "text": "NIST05 and NIST08 evaluation sets",
          "labels": ["Dataset"]
        },
        "id": 772
      },
            {
        "value":         {
          "start": 21610,
          "end": 21618,
          "text": "NIST data",
          "labels": ["Dataset"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 21750,
          "end": 21763,
          "text": "IWSLT data set",
          "labels": ["Dataset"]
        },
        "id": 773
      },
            {
        "value":         {
          "start": 22108,
          "end": 22147,
          "text": "consensus-based re-ranking ( G-Re-Rank )",
          "labels": ["Method"]
        },
        "id": 773
      },
            {
        "value":         {
          "start": 22324,
          "end": 22339,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 22354,
          "end": 22395,
          "text": "structured label propagation ( Struct-LP )",
          "labels": ["Method"]
        },
        "id": 774
      },
            {
        "value":         {
          "start": 22542,
          "end": 22545,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22575,
          "end": 22583,
          "text": "Struct-LP",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 22679,
          "end": 22687,
          "text": "G-Re-Rank",
          "labels": ["Method"]
        },
        "id": 785
      },
            {
        "value":         {
          "start": 23318,
          "end": 23354,
          "text": "consensus-based decoding ( G-Decode )",
          "labels": ["Method"]
        },
        "id": 777
      },
            {
        "value":         {
          "start": 23408,
          "end": 23440,
          "text": "consensus-based re-ranking method",
          "labels": ["Method"]
        },
        "id": 778
      },
            {
        "value":         {
          "start": 23743,
          "end": 23754,
          "text": "G-Re-Rank-GC",
          "labels": ["Method"]
        },
        "id": 786
      },
            {
        "value":         {
          "start": 23760,
          "end": 23770,
          "text": "G-Decode-GC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 23889,
          "end": 23900,
          "text": "G-Re-Rank-LC",
          "labels": ["Method"]
        },
        "id": 787
      },
            {
        "value":         {
          "start": 23906,
          "end": 23916,
          "text": "G-Decode-LC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 23971,
          "end": 23996,
          "text": "consensus-based re-ranking",
          "labels": ["Method"]
        },
        "id": 783
      },
            {
        "value":         {
          "start": 24057,
          "end": 24081,
          "text": "consensus decoding system",
          "labels": ["Method"]
        },
        "id": 784
      },
            {
        "value":         {
          "start": 24236,
          "end": 24247,
          "text": "G-Re-Rank-LC",
          "labels": ["Method"]
        },
        "id": 787
      },
            {
        "value":         {
          "start": 24253,
          "end": 24263,
          "text": "G-Decode-LC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 24344,
          "end": 24352,
          "text": "G-Re-Rank",
          "labels": ["Method"]
        },
        "id": 785
      },
            {
        "value":         {
          "start": 24358,
          "end": 24365,
          "text": "G-Decode",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 24372,
          "end": 24383,
          "text": "G-Re-Rank-GC",
          "labels": ["Method"]
        },
        "id": 786
      },
            {
        "value":         {
          "start": 24389,
          "end": 24399,
          "text": "G-Decode-GC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 24476,
          "end": 24486,
          "text": "GRe-Rank-GC",
          "labels": ["Method"]
        },
        "id": 786
      },
            {
        "value":         {
          "start": 24529,
          "end": 24540,
          "text": "G-Re-Rank-LC",
          "labels": ["Method"]
        },
        "id": 787
      },
            {
        "value":         {
          "start": 24563,
          "end": 24573,
          "text": "G-Decode-LC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 24598,
          "end": 24607,
          "text": "GDecode-GC",
          "labels": ["Method"]
        },
        "id": 787
      },
            {
        "value":         {
          "start": 24747,
          "end": 24755,
          "text": "NIST data",
          "labels": ["Dataset"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 24798,
          "end": 24831,
          "text": "consensus-based re-ranking methods",
          "labels": ["Method"]
        },
        "id": 788
      },
            {
        "value":         {
          "start": 24870,
          "end": 24879,
          "text": "IWSLT data",
          "labels": ["Dataset"]
        },
        "id": 789
      },
            {
        "value":         {
          "start": 24891,
          "end": 24914,
          "text": "consensus-based decoding",
          "labels": ["Method"]
        },
        "id": 789
      },
            {
        "value":         {
          "start": 25193,
          "end": 25218,
          "text": "modified label propagation",
          "labels": ["Method"]
        },
        "id": 790
      },
            {
        "value":         {
          "start": 25256,
          "end": 25276,
          "text": "graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 25321,
          "end": 25341,
          "text": "graph-based consensus",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 25368,
          "end": 25371,
          "text": "MERT",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 25428,
          "end": 25436,
          "text": "Struct-LP",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 25525,
          "end": 25535,
          "text": "G-ReRank-LC",
          "labels": ["Method"]
        },
        "id": 791
      },
            {
        "value":         {
          "start": 25541,
          "end": 25551,
          "text": "G-Decode-LC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 25761,
          "end": 25771,
          "text": "G-Decode-GC",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 25858,
          "end": 25865,
          "text": "G-Decode",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26179,
          "end": 26213,
          "text": "structured label propagation method",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26296,
          "end": 26323,
          "text": "structured label propagation",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26483,
          "end": 26498,
          "text": "log-linear model",
          "labels": ["Method"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26618,
          "end": 26622,
          "text": "IWSLT",
          "labels": ["Dataset"]
        },
        "id": 796
      },
            {
        "value":         {
          "start": 26628,
          "end": 26636,
          "text": "NIST data",
          "labels": ["Dataset"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26729,
          "end": 26745,
          "text": "Dice co-efficient",
          "labels": ["Metric"]
        },
        "id": 792
      },
            {
        "value":         {
          "start": 26750,
          "end": 26756,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 26789,
          "end": 26792,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 27181,
          "end": 27189,
          "text": "CRF model",
          "labels": ["Method"]
        },
        "id": 1505
      }
    ],
    "data": {"text": "Learning Translation Consensus with Structured Label Propagation Abstract In this paper , we address the issue for learning better translation consensus in machine translation ( MT ) research , and explore the search of translation consensus from similar , rather than the same , source sentences or their spans . Unlike previous work on this topic , we formulate the problem as structured labeling over a much smaller graph , and we propose a novel structured label propagation for the task . We convert such graph-based translation consensus from similar source strings into useful features both for n-best output reranking and for decoding algorithm . Experimental results show that , our method can significantly improve machine translation performance on both IWSLT and NIST data , compared with a state-ofthe-art baseline . 1 Introduction Consensus in translation has gained more and more attention in recent years . The principle of consensus can be sketched as a translation candidate is deemed more plausible if it is supported by other translation candidates . The actual formulation of the principle depends on whether the translation candidate is a complete sentence or just a span of it , whether the candidate is the same as or similar to the supporting candidates , and whether the supporting candidates come from the same or different MT system . Translation consensus is employed in those minimum Bayes risk ( MBR ) approaches where the loss function of a translation is defined with respect to all other translation candidates . That is , the translation with the minimal Bayes risk is the one to the greatest extent similar to other candidates . These approaches include the work of Kumar and Byrne ( 2004 ) , which re-ranks the nbest output of a MT decoder , and the work of Tromble et al . ( 2008 ) and Kumar et al . ( 2009 ) , which does MBR decoding for lattices and hypergraphs . Others extend consensus among translations from the same MT system to those from different MT systems . Collaborative decoding ( Li et al . , 2009 ) scores the translation of a source span by its n-gram similarity to the translations by other systems . Hypothesis mixture decoding ( Duan et al . , 2011 ) performs a second decoding process where the search space is enriched with new hypotheses composed out of existing hypotheses from multiple systems . All these approaches are about utilizing consensus among translations for the same ( span of ) source sentence . It should be noted that consensus among translations of similar source sentences/spans is also helpful for good candidate selection . Consider the examples in Figure 1 . For the source ( Chinese ) span _ i Ef n XT X AV , the MT system produced the correct translation for the second sentence , but it failed to do so for the first one . If the translation of the first sentence could take into consideration the translation of the second sentence , which is similar to but not exactly the same as the first one , the final translation output may be improved . Following this line of reasoning , a discriminative learning method is proposed to constrain the translation of an input sentence using ( Chinese to English ) data set . `` Src '' stands for the source sentence , and `` Ref '' means the reference sentence . `` Best1 '' is the final output of the decoder . the most similar translation examples from translation memory ( TM ) systems ( Ma et al. , 2011 ) . A classifier is applied to re-rank the n-best output of a decoder , taking as features the information about the agreement with those similar translation examples . Alexandrescu and Kirchhoff ( 2009 ) proposed a graph-based semi-supervised model to re-rank n-best translation output . Note that these two attempts are about translation consensus for similar sentences , and about reranking of n-best output . It is still an open question whether translation consensus for similar sentences/spans can be applied to the decoding process . Moreover , the method in Alexandrescu and Kirchhoff ( 2009 ) is formulated as a typical and simple label propagation , which leads to very large graph , thus making learning and search inefficient . ( c.f. Section 3 . ) In this paper , we attempt to leverage translation consensus among similar ( spans of ) source sentences in bilingual training data , by a novel graph-based model of translation consensus . Unlike Alexandrescu and Kirchhoff ( 2009 ) , we reformulate the task of seeking translation consensus among source sentences as structured labeling . We propose a novel label propagation algorithm for structured labeling , which is much more efficient than simple label propagation , and derive useful MT decoder features out of it . We conduct experiments with IWSLT and NIST data , and experimental results show that , our method can improve the translation performance significantly on both data sets , compared with a state-of-the-art baseline . 2 Graph-based Translation Consensus Our MT system with graph-based translation consensus adopts the conventional log-linear model . For the source string f , the conditional probability of a translation candidate a is defined as : where * is the feature vector , A is the feature weights , and H ( f ) is the set of translation hypotheses in the search space . Based on the commonly used features , two kinds of feature are added to equation ( 1 ) , one is graph-based consensus features , which are about consensus among the translations of similar sentences/spans ; the other is local consensus features , which are about consensus among the translations of the same sentence/span . We develop a structured label propagation method , which can calculate consensus statistics from translation candidates of similar source sentences / spans . In the following , we explain why the standard , simple label propagation is not suitable for translation consensus , and then introduce how the problem is formulated as an instance of structured labeling , with the proposed structured label propagation algorithm , in section 3 . Before elaborating how the graph model of consensus is constructed for both a decoder and N-best output re-ranking in section 5 , we will describe how the consensus features and their feature weights can be trained in a semi-supervised way , in section 4 . 3 Graph-based Structured Learning In general , a graph-based model assigns labels to instances by considering the labels of similar instances . A graph is constructed so that each instance is represented by a node , and the weight of the edge between a pair of nodes represents the similarity between them . The gist of graph-based model is that , if two instances are connected by a strong edge , then their labels tend to be the same ( Zhu , 2005 ) . In MT , the instances are source sentences or spans of source sentences , and the possible labels are their translation candidates . This scenario differs from the general case of graph-based model in two aspects . First , there are an indefinite , or even intractable , number of labels . Each of them is a string of words rather than a simple category . In the following we will call these labels as structured labels ( Berlett et al. , 2004 ) . Second , labels are highly instance-dependent . In most cases , for any two different ( spans of ) source sentences , however small their difference is , their correct labels ( translations ) are not exactly the same . Therefore , the principle of graph-based translation consensus must be reformulated as , if two instances ( source spans ) are similar , then their labels ( translations ) tend to be similar ( rather than the same ) . Note that Alexandrescu and Kirchhoff ( 2009 ) do not consider translation as structured labeling . In their graph , a node does not represent only a source sentence but a pair of source sentence and its candidate translation , and there are only two possible labels for each node , namely , 1 ( this is a good translation pair ) and 0 ( this is not a good translation pair ) . Thus their graph-based model is a normal example of the general graph-based model . The biggest problem of such a perspective is inefficiency . An average MT decoder considers a vast amount of translation candidates for each source sentence , and therefore the corresponding graph also contains a vast amount of nodes , thus rendering learning over a large dataset is infeasible . 3.1 Label Propagation for General Graphbased Models A general graph-based model is iteratively trained by label propagation , in which , , the probability of label l for the node , is updated with respect to the corresponding probabilities for s neighboring nodes . In Zhu ( 2005 ) , the updating rule is expressed in a matrix calculation . For convenience , the updating rule is expressed for each label here : where , , the propagating probability , is defined as : , defines the weight of the edge , which is a similarity measure between nodes and . Note that the graph contains nodes for training instances , whose correct labels are known . The probability of the correct label to each training instance is reset to 1 at the end of each iteration . With a suitable measure of instance/node similarity , it is expected that an unlabeled instance/node will find the most suitable label from similar labeled nodes . 3.2 Structured Label Propagation for Graphbased Learning In structured learning like MT , different instances would not have the same correct label , and so the updating rule ( 2 ) is no longer valid , as the value of , should not be calculated based on , . Here we need a new updating rule so that , can be updated with respect to , , where in general . Let us start with the model in Alexandrescu and Kirchhoff ( 2009 ) . According to them , a node in the graph represents the pair of some source sentence/span and its translation candidate . The updating rule ( for the label 1 or 0 ) is : where , is the set of neighbors of the node , ) . When the problem is reformulated as structured labeling , each node represents the source sentence/span only , and the translation candidates become labels . The propagating probability , , , has to be reformulated accordingly . A natural way is to decompose it into a component for nodes and a component for labels . Assuming that the two components are independent , then : , , , , , 5 where , is the propagating probability from source sentence/span to , and , is that from translation candidate to . The set of neighbors , of a pair , has also to be reformulated in terms of the set of neighbors of a source sentence/span : where is the set of translation candidates for source . The new updating rule will then be : The new rule updates the probability of a translation of a source sentence/span with probabilities of similar translations s of some similar source sentences/spans s. Propagation probability , is as defined in equation ( 3 ) , and , is defined given some similarity measure , between labels and : translation candidates of . , is initialized with the translation posterior of given . The translation posterior is normalized in the n-best list . For the nodes representing the training sentence pairs , this posterior is fixed . , is the propagating probability in equation ( 8 ) , with the similarity measure , defined as the Dice co-efficient over the set of all n-grams in and those in . That is , where is the set of n-grams in string , and , is the Dice co-efficient over sets and : We take 1 4 for similarity between translation candidates , thus leading to four features . The other propagating probability , , as defined in equation ( 3 ) , takes symmetrical sentence level BLEU as similarity measure1 : 4 Features and Training The last section sketched the structured label propagation algorithm . Before elaborating the details of how the actual graph is constructed , we would like to first introduce how the graph-based translation consensus can be used in an MT system . 4.1 Graph-based Consensus Features The probability as estimated in equation ( 7 ) is taken as a group of new features in either a decoder or an n-best output re-ranker . We will call these features collectively as graph-based consensus features ( GC ) : Recall that , refers to source sentences / spans which are similar with , and refers to where , is defined as follows ( Liang et al . , 2006 ) : where , is the IBM BLEU score computed over i-grams for hypothesis using as reference . In theory we could use other similarity measures such as edit distance , string kernel . Here simple ngram similarity is used for the sake of efficiency . 4.2 Other Features In addition to graph-based consensus features , we also propose local consensus features , defined over the n-best translation candidates as : where p ( e ' | f ) is translation posterior . Like GC , there are four features with respect to the value of n in n-gram similarity measure . We also use other fundamental features , such as translation probabilities , lexical weights , distortion probability , word penalty , and language model probability . 4.3 Training Method When graph-based consensus is applied to an MT system , the graph will have nodes for training data , development ( dev ) data , and test data ( details in Section 5 ) . There is only one label/translation for each training data node . For each dev/test data node , the possible labels are the n-best translation candidates from the decoder . Note that there is mutual dependence between the consensus graph and the decoder . On the one hand , the MT decoder depends on the graph for the GC features . On the other hand , the graph needs the decoder to provide the translation candidates as possible labels , and their posterior probabilities as initial values of various pf , e . Therefore , we can alternatively update graph-based consensus features and feature weights in the log-linear model . end while return last ( GCt , At ) Algorithm 1 outlines our semi-supervised method for such alternative training . The entire process starts with a decoder without consensus features . Then a graph is constructed out of all training , dev , and test data . The subsequent structured label propagation provides GC feature values to the MT decoder . The decoder then adds the new features and re-trains all the feature weights by Minimum Error Rate Training ( MERT ) ( Och , 2003 ) . The decoder with new feature weights then provides new n-best candidates and their posteriors for constructing another consensus graph , which in turn gives rise to next round of MERT . This alternation of structured label propagation and MERT stops when the BLEU score on dev data converges , or a pre-set limit ( 10 rounds ) is reached . 5 Graph Construction A technical detail is still needed to complete the description of graph-based consensus , namely , how the actual consensus graph is constructed . We will divide the discussion into two sections regarding how the graph is used . 5.1 Graph Construction for Re-Ranking When graph-based consensus is used for reranking the n-best outputs of a decoder , each node in the graph corresponds to a complete sentence . A separate node is created for each source sentence in training data , dev data , and test data . For any node from training data ( henceforth training node ) , it is labeled with the correct translation , and pf , e is fixed as 1 . If there are sentence pairs with the same source sentence but different translations , all the translations will be assigned as labels to that source sentence , and the corresponding probabilities are estimated by MLE . There is no edge between training nodes , since we suppose all the sentences of the training data are correct , and it is pointless to re-estimate the confidence of those sentence pairs . Each node from dev/test data ( henceforth test node ) is unlabeled , but it will be given an n-best list of translation candidates as possible labels from a MT decoder . The decoder also provides translation posteriors as the initial confidences of the labels . A test node can be connected to training nodes and other test nodes . If the source sentences of a test node and some other node are sufficiently similar , a similarity edge is created between them . In our experiment we measure similarity by symmetrical sentence level BLEU of source sentences , and 0.3 is taken as the threshold for edge creation . Figure 2 shows a toy example graph . Each node is depicted as rectangle with the upper half showing the source sentence and the lower half showing the correct or possible labels . Training nodes are in grey while test nodes are in white . The edges between the nodes are weighted by the similarities between the corresponding source sentences . 5.2 Graph Construction for Decoding Graph-based consensus can also be used in the decoding algorithm , by re-ranking the translation candidates of not only the entire source sentence but also every source span . Accordingly the graph does not contain only the nodes for source sentences but also the nodes for all source spans . It is needed to find the candidate labels for each source span . It is not difficult to handle test nodes , since the purpose of MT decoder is to get all possible segmentations of a source sentence in dev/test data , search for the translation candidates of each source span , and calculate the probabilities of the candidates . Therefore , the cells in the search space of a decoder can be directly mapped as test nodes in the graph . Training nodes can be handled similarly , by applying forced alignment . Forced alignment performs phrase segmentation and alignment of each sentence pair of the training data using the full translation system as in decoding ( Wuebker et al. , 2010 ) . In simpler term , for each sentence pair in training data , a decoder is applied to the source side , and all the translation candidates that do not match any substring of the target side are deleted . The cells of in such a reduced search space of the decoder can be directly mapped as training nodes in the graph , just as in the case of test nodes . Note that , due to pruning in both decoding and translation model training , forced alignment may fail , i.e. the decoder may not be able to produce target side of a sentence pair . In such case we still map the cells in the search space as training nodes . Note also that the shorter a source span is , the more likely it appears in more than one source sentence . All the translation candidates of the same source span in different source sentences are merged . Edge creation is the same as that in graph construction for n-best re-ranking , except that two nodes are always connected if they are about a span and its sub-span . This exception ensures that shorter spans can always receive propagation from longer ones , and vice versa . Figure 3 shows a toy example . There is one node for the training sentence `` E A M N '' and two nodes for the test sentences `` E A B C '' and `` F D B C '' . All the other nodes represent spans . The node `` M N '' and `` E A '' are created according to the forced alignment result of the sentence `` E A M N '' . As we see , the translation candidates for `` M N '' and `` E A '' are not the sub-strings from the target sentence of `` E A M N '' . There are two kinds of edges . Dash lines are edges connecting nodes of a span and its sub-span , such as the one between `` E A B C '' and `` E '' . Solid lines are edges connecting nodes with sufficient source side n-gram similarity , such as the one between ` ` E A M N ' ' and ` ` E A B C ' ' . 6 Experiments and Results In this section , graph-based translation consensus is tested on the Chinese to English translation tasks . The evaluation method is the case insensitive IBM BLEU - 4 ( Papineni et al . , 2002 ) . Significant testing is carried out using bootstrap re-sampling method proposed by Koehn ( 2004 ) with a 95 % confidence level . 6.1 Experimental Data Setting and Baselines We test our method with two data settings : one is IWSLT data set , the other is NIST data set . Our baseline decoder is an in-house implementation of Bracketing Transduction Grammar ( Dekai Wu , 1997 ) ( BTG ) in CKY-style decoding with a lexical reordering model trained with maximum entropy ( Xiong et al . , 2006 ) . The features we used are commonly used features as standard BTG decoder , such as translation probabilities , lexical weights , language model , word penalty and distortion probabilities . Our IWSLT data is the IWSLT 2009 dialog task data set . The training data include the BTEC and SLDB training data . The training data contains 81k sentence pairs , 655k Chinese words and 806 English words . The language model is 5 - gram language model trained with the target sentences in the training data . The test set is devset9 , and the development set for MERT comprises both devset8 and the Chinese DIALOG set . The baseline results on IWSLT data are shown in Table 1 . devset8 + dialog devset9 Baseline 48.79 44.73 Table 1 . Baselines For the NIST data set , the bilingual training data we used is NIST 2008 training set excluding the Hong Kong Law and Hong Kong Hansard . The training data contains 354k sentence pairs , 8M Chinese words and 10M English words . The language model is 5 - gram language model trained with the Giga-Word corpus plus the English sentences in the training data . The development data utilized to tune the feature weights of our decoder is NIST03 evaluation set , and test sets are NIST05 and NIST08 evaluation sets . The baseline results on NIST data are shown in Table 2 . 6.2 Experimental Result Table 3 shows the performance of our consensusbased re-ranking and decoding on the IWSLT data set . To perform consensus-based re-ranking , we first use the baseline decoder to get the n-best list for each sentence of development and test data , then we create graph using the n-best lists and training data as we described in section 5.1 , and perform semi-supervised training as mentioned in section 4.3 . As we can see from Table 3 , our consensus-based re-ranking ( G-Re-Rank ) outperforms the baseline significantly , not only for the development data , but also for the test data . Instead of using graph-based consensus confidence as features in the log-linear model , we perform structured label propagation ( Struct-LP ) to re-rank the n-best list directly , and the similarity measures for source sentences and translation candidates are symmetrical sentence level BLEU ( equation ( 10 ) ) . Using Struct-LP , the performance is significantly improved , compared with the baseline , but not as well as G-Re-Rank . for IWSLT data set . The results in bold type are significantly better than the baseline . We use the baseline system to perform forced alignment procedure on the training data , and create span nodes using the derivation tree of the forced alignment . We also saved the spans of the sentences from development and test data , which will be used to create the responding nodes for consensus-based decoding . In such a way , we create the graph for decoding , and perform semi supervised training to calculate graph-based consensus features , and tune the weights for all the features we used . In Table 3 , we can see that our consensus-based decoding ( G-Decode ) is much better than baseline , and also better than consensus-based re-ranking method . That is reasonable since the neighbor/local similarity features not only re-rank the final n-best output , but also the spans during decoding . To test the contribution of each kind of features , we first remove all the local consensus features and perform consensus-based re-ranking and decoding ( G-Re-Rank-GC and G-Decode-GC ) , and then we remove all the graph-based consensus features to test the contribution of local consensus features ( G-Re-Rank-LC and G-Decode-LC ) . Without the graph-based consensus features , our consensus-based re-ranking and decoding is simplified into a consensus re-ranking and consensus decoding system , which only re-rank the candidates according to the consensus information of other candidates in the same n-best list . From Table 3 , we can see , the G-Re-Rank-LC and G-Decode-LC improve the performance of development data and test data , but not as much as G-Re-Rank and G-Decode do . G-Re-Rank-GC and G-Decode-GC improve the performance of machine translation according to the baseline . GRe-Rank-GC does not achieve the same performance as G-Re-Rank-LC does . Compared with G-Decode-LC , the performance with GDecode-GC is much better . for NIST data set . The results in bold type are significantly better than the baseline . We also conduct experiments on NIST data , and results are shown in Table 4 . The consensus-based re-ranking methods are performed in the same way as for IWSLT data , but for consensus-based decoding , the data set contains too many sentence pairs to be held in one graph for our machine . We apply the method of Alexandrescu and Kirchhoff ( 2009 ) to construct separate graphs for each development and test sentence without losing global connectivity information . We perform modified label propagation with the separate graphs to get the graph-based consensus for n-best list of each sentence , and the graph-based consensus will be recorded for the MERT to tune the weights . From Table 4 , we can see that , Struct-LP improves the performance slightly , but not significantly . Local consensus features ( G-ReRank-LC and G-Decode-LC ) improve the performance slightly . The combination of graphbased and local consensus features can improve the translation performance significantly on SMT re-ranking . With graph-based consensus features , G-Decode-GC achieves significant performance gain , and combined with local consensus features , G-Decode performance is improved farther . 7 Conclusion and Future Work In this paper , we extend the consensus method by collecting consensus statistics , not only from translation candidates of the same source sentence/span , but also from those of similar ones . To calculate consensus statistics , we develop a novel structured label propagation method for structured learning problems , such as machine translation . Note that , the structured label propagation can be applied to other structured learning tasks , such as POS tagging and syntactic parsing . The consensus statistics are integrated into the conventional log-linear model as features . The features and weights are tuned with an iterative semi-supervised method . We conduct experiments on IWSLT and NIST data , and our method can improve the performance significantly . In this paper , we only tried Dice co-efficient of n-grams and symmetrical sentence level BLEU as similarity measures . In the future , we will explore other consensus features and other similarity measures , which may take document level information , or syntactic and semantic information into consideration . We also plan to introduce feature to model the similarity of the source sentences , which are reflected by only one score in our paper , and optimize the parameters with CRF model . "}
  },
    {
    "id": "P13-1074",
    "result":     [
            {
        "value":         {
          "start": 646,
          "end": 650,
          "text": "IWSLT",
          "labels": ["Dataset"]
        },
        "id": 796
      },
            {
        "value":         {
          "start": 656,
          "end": 659,
          "text": "TDT4",
          "labels": ["Dataset"]
        },
        "id": 820
      },
            {
        "value":         {
          "start": 2068,
          "end": 2103,
          "text": "hidden event language model ( HELM )",
          "labels": ["Method"]
        },
        "id": 794
      },
            {
        "value":         {
          "start": 3549,
          "end": 3579,
          "text": "shift-reduce decoding algorithm",
          "labels": ["Method"]
        },
        "id": 800
      },
            {
        "value":         {
          "start": 5401,
          "end": 5405,
          "text": "IWSLT",
          "labels": ["Dataset"]
        },
        "id": 796
      },
            {
        "value":         {
          "start": 5416,
          "end": 5419,
          "text": "TDT4",
          "labels": ["Method"]
        },
        "id": 820
      },
            {
        "value":         {
          "start": 5524,
          "end": 5548,
          "text": "CRF-based baseline method",
          "labels": ["Method"]
        },
        "id": 796
      },
            {
        "value":         {
          "start": 6389,
          "end": 6395,
          "text": "n-grams",
          "labels": ["Method"]
        },
        "id": 960
      },
            {
        "value":         {
          "start": 6504,
          "end": 6524,
          "text": "maximum entropy model",
          "labels": ["Method"]
        },
        "id": 895
      },
            {
        "value":         {
          "start": 6566,
          "end": 6577,
          "text": "finite state",
          "labels": ["Method"]
        },
        "id": 797
      },
            {
        "value":         {
          "start": 6583,
          "end": 6612,
          "text": "multi-layer perceptron methods",
          "labels": ["Method"]
        },
        "id": 798
      },
            {
        "value":         {
          "start": 6646,
          "end": 6670,
          "text": "conditional random fields",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 6880,
          "end": 6918,
          "text": "statistical machine translation ( SMT )",
          "labels": ["Method"]
        },
        "id": 799
      },
            {
        "value":         {
          "start": 7662,
          "end": 7665,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 9716,
          "end": 9746,
          "text": "shift-reduce decoding algorithm",
          "labels": ["Method"]
        },
        "id": 800
      },
            {
        "value":         {
          "start": 12258,
          "end": 12285,
          "text": "punctuation prediction model",
          "labels": ["Method"]
        },
        "id": 800
      },
            {
        "value":         {
          "start": 12295,
          "end": 12324,
          "text": "transition-based parsing model",
          "labels": ["Method"]
        },
        "id": 801
      },
            {
        "value":         {
          "start": 14355,
          "end": 14399,
          "text": "cascaded punctuation prediction model ( CPP )",
          "labels": ["Method"]
        },
        "id": 802
      },
            {
        "value":         {
          "start": 15566,
          "end": 15609,
          "text": "unified punctuation prediction model ( UPP )",
          "labels": ["Method"]
        },
        "id": 803
      },
            {
        "value":         {
          "start": 16902,
          "end": 16904,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 16910,
          "end": 16919,
          "text": "UPP models",
          "labels": ["Method"]
        },
        "id": 807
      },
            {
        "value":         {
          "start": 17058,
          "end": 17070,
          "text": "Treebank data",
          "labels": ["Dataset"]
        },
        "id": 829
      },
            {
        "value":         {
          "start": 17761,
          "end": 17763,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 17769,
          "end": 17778,
          "text": "UPP models",
          "labels": ["Method"]
        },
        "id": 807
      },
            {
        "value":         {
          "start": 17930,
          "end": 17932,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 17938,
          "end": 17940,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 17970,
          "end": 17972,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 17978,
          "end": 17980,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 18116,
          "end": 18118,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 18124,
          "end": 18126,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 18267,
          "end": 18269,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 18275,
          "end": 18277,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 18320,
          "end": 18322,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 18644,
          "end": 18678,
          "text": "English Web Treebank ( LDC2012T13 )",
          "labels": ["Dataset"]
        },
        "id": 808
      },
            {
        "value":         {
          "start": 18688,
          "end": 18734,
          "text": "English portion of OntoNotes 4.0 ( LDC2011T03 )",
          "labels": ["Dataset"]
        },
        "id": 809
      },
            {
        "value":         {
          "start": 18743,
          "end": 18769,
          "text": "Stanford Conversion toolkit",
          "labels": ["Tool"]
        },
        "id": 810
      },
            {
        "value":         {
          "start": 19391,
          "end": 19397,
          "text": "IWSLT09",
          "labels": ["Dataset"]
        },
        "id": 816
      },
            {
        "value":         {
          "start": 19503,
          "end": 19534,
          "text": "TDT4 English data ( LDC2005T16 )",
          "labels": ["Dataset"]
        },
        "id": 812
      },
            {
        "value":         {
          "start": 19844,
          "end": 19863,
          "text": "precision ( prec . )",
          "labels": ["Metric"]
        },
        "id": 813
      },
            {
        "value":         {
          "start": 19867,
          "end": 19882,
          "text": "recall ( rec . )",
          "labels": ["Metric"]
        },
        "id": 814
      },
            {
        "value":         {
          "start": 19888,
          "end": 19906,
          "text": "F1 - measure ( F1 )",
          "labels": ["Metric"]
        },
        "id": 815
      },
            {
        "value":         {
          "start": 19980,
          "end": 19988,
          "text": "CRF model",
          "labels": ["Method"]
        },
        "id": 1505
      },
            {
        "value":         {
          "start": 20947,
          "end": 20953,
          "text": "IWSLT09",
          "labels": ["Dataset"]
        },
        "id": 816
      },
            {
        "value":         {
          "start": 21010,
          "end": 21048,
          "text": "BTEC ( Basic Travel Expression Corpus )",
          "labels": ["Dataset"]
        },
        "id": 816
      },
            {
        "value":         {
          "start": 21076,
          "end": 21096,
          "text": "CT ( Challenge Task )",
          "labels": ["Dataset"]
        },
        "id": 817
      },
            {
        "value":         {
          "start": 22167,
          "end": 22169,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 22211,
          "end": 22213,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 22431,
          "end": 22433,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 22443,
          "end": 22445,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 22603,
          "end": 22611,
          "text": "TDT4 data",
          "labels": ["Dataset"]
        },
        "id": 821
      },
            {
        "value":         {
          "start": 22638,
          "end": 22675,
          "text": "SRIs English broadcast news ASR system",
          "labels": ["Tool"]
        },
        "id": 819
      },
            {
        "value":         {
          "start": 22692,
          "end": 22701,
          "text": "error rate",
          "labels": ["Metric"]
        },
        "id": 1535
      },
            {
        "value":         {
          "start": 22780,
          "end": 22783,
          "text": "TDT4",
          "labels": ["Dataset"]
        },
        "id": 820
      },
            {
        "value":         {
          "start": 23198,
          "end": 23208,
          "text": "ASR systems",
          "labels": ["Tool"]
        },
        "id": 828
      },
            {
        "value":         {
          "start": 23345,
          "end": 23353,
          "text": "TDT4 data",
          "labels": ["Dataset"]
        },
        "id": 821
      },
            {
        "value":         {
          "start": 23513,
          "end": 23521,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23527,
          "end": 23534,
          "text": "F1 score",
          "labels": ["Metric"]
        },
        "id": 1317
      },
            {
        "value":         {
          "start": 23586,
          "end": 23588,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 23601,
          "end": 23606,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23613,
          "end": 23615,
          "text": "UPP",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 23634,
          "end": 23642,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23648,
          "end": 23655,
          "text": "F1 score",
          "labels": ["Metric"]
        },
        "id": 1317
      },
            {
        "value":         {
          "start": 23721,
          "end": 23723,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 23740,
          "end": 23745,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 24214,
          "end": 24226,
          "text": "Treebank data",
          "labels": ["Dataset"]
        },
        "id": 829
      },
            {
        "value":         {
          "start": 24336,
          "end": 24343,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24561,
          "end": 24568,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24722,
          "end": 24745,
          "text": "transition-based parsing",
          "labels": ["Method"]
        },
        "id": 822
      },
            {
        "value":         {
          "start": 24752,
          "end": 24788,
          "text": "texts containing punctuations ( TCP )",
          "labels": ["Dataset"]
        },
        "id": 823
      },
            {
        "value":         {
          "start": 25170,
          "end": 25172,
          "text": "CPP",
          "labels": ["Method"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 25183,
          "end": 25216,
          "text": "texts without punctuations ( TOP )",
          "labels": ["Dataset"]
        },
        "id": 824
      },
            {
        "value":         {
          "start": 25256,
          "end": 25258,
          "text": "TOP",
          "labels": ["Dataset"]
        },
        "id": 825
      },
            {
        "value":         {
          "start": 25285,
          "end": 25287,
          "text": "TCP",
          "labels": ["Dataset"]
        },
        "id": 826
      },
            {
        "value":         {
          "start": 25381,
          "end": 25388,
          "text": "TOP data",
          "labels": ["Method"]
        },
        "id": 827
      },
            {
        "value":         {
          "start": 26268,
          "end": 26278,
          "text": "ASR systems",
          "labels": ["Tool"]
        },
        "id": 828
      },
            {
        "value":         {
          "start": 26366,
          "end": 26381,
          "text": "CRF-based method",
          "labels": ["Method"]
        },
        "id": 828
      },
            {
        "value":         {
          "start": 26710,
          "end": 26722,
          "text": "Treebank data",
          "labels": ["Dataset"]
        },
        "id": 829
      }
    ],
    "data": {"text": "Punctuation Prediction with Transition-based Parsing Abstract Punctuations are not available in automatic speech recognition outputs , which could create barriers to many subsequent text processing tasks . This paper proposes a novel method to predict punctuation symbols for the stream of words in transcribed speech texts . Our method jointly performs parsing and punctuation prediction by integrating a rich set of syntactic features when processing words from left to right . It can exploit a global view to capture long-range dependencies for punctuation prediction with linear complexity . The experimental results on the test data sets of IWSLT and TDT4 show that our method can achieve high-level performance in punctuation prediction over the stream of words in transcribed speech text . 1 Introduction Standard automatic speech recognizers output unstructured streams of words . They neither perform a proper segmentation of the output into sentences , nor predict punctuation symbols . The unavailable punctuations and sentence boundaries in transcribed speech texts create barriers to many subsequent processing tasks , such as summarization , information extraction , question answering and machine translation . Thus , the segmentation of long texts is necessary in many real applications . For example , in speech-to-speech translation , continuously transcribed speech texts need to be segmented before being fed into subsequent machine translation systems ( Takezawa et al. , 1998 ; Nakamura , 2009 ) . This is because current machine translation ( MT ) systems perform the translation at the sentence level , where various models used in MT are trained over segmented sentences and many algorithms inside MT have an exponential complexity with regard to the length of inputs . The punctuation prediction problem has attracted research interest in both the speech processing community and the natural language processing community . Most previous work primarily exploits local features in their statistical models such as lexicons , prosodic cues and hidden event language model ( HELM ) ( Liu et al . , 2005 ; Matusov et al . , 2006 ; Huang and Zweig , 2002 ; Stolcke and Shriberg , 1996 ) . The word-level models integrating local features have narrow views about the input and could not achieve satisfied performance due to the limited context information access ( Favre et al. , 2008 ) . Naturally , global contexts are required to model the punctuation prediction , especially for long-range dependencies . For instance , in English question sentences , the ending question mark is long-range dependent on the initial phrases ( Lu and Ng , 2010 ) , such as could you in Figure 1 . There has been some work trying to incorporate syntactic features to broaden the view of hypotheses in the punctuation prediction models ( Roark et al. , 2006 ; Favre et al. , 2008 ) . In their methods , the punctuation prediction is treated as a separated post-procedure of parsing , which may suffer from the problem of error propagation . In addition , these approaches are not able to incrementally process inputs and are not efficient for very long inputs , especially in the cases of long transcribed speech texts from presentations where the number of streaming words could be larger than hundreds or thousands . In this paper , we propose jointly performing punctuation prediction and transition-based dependency parsing over transcribed speech text . When the transition-based parsing consumes the stream of words left to right with the shift-reduce decoding algorithm , punctuation symbols are predicted for each word based on the contexts of the parsing tree . Two models are proposed to cause the punctuation prediction to interact with the transition actions in parsing . One is to conduct transition actions of parsing followed by punctuation predictions in a cascaded way . The other is to associate the conventional transition actions of parsing with punctuation perditions , so that predicted punctuations are directly inferred from the parsing tree . Our models have linear complexity and are capable of handling streams of words with any length . In addition , the computation of models use a rich set of syntactic features , which can improve the complicated punctuation predictions from a global view , especially for the long range dependencies . Figure 1 shows an example of how parsing helps punctuation prediction over the transcribed speech text . As illustrated in Figure 1 ( b ) , two commas are predicted when their preceding words act as the adverbial modifiers ( advmod ) during parsing . The period after the word menu is predicted when the parsing of an adverbial clause modifier ( advcl ) is completed . The question mark at the end of the input is determined when a direct object modifier ( dobj ) is identified , together with the long range clue that the auxiliary word occurs before the nominal subject ( nsubj ) . Eventually , two segmentations are formed according to the punctuation prediction results , shown in Figure 1 ( c ) . The training data used for our models is adapted from Treebank data by excluding all punctuations but keeping the punctuation contexts , so that it can simulate the unavailable annotated transcribed speech texts . In decoding , beam search is used to get optimal punctuation prediction results . We conduct experiments on both IWSLT data and TDT4 test data sets . The experimental results show that our method can achieve higher performance than the CRF-based baseline method . The paper is structured as follows : Section 2 conducts a survey of related work . The transitionbased dependency parsing is introduced in Section 3 . We explain our approach to predicting punctuations for transcribed speech texts in Section 4 . Section 5 gives the results of our experiment . The conclusion and future work are given in Section 6 . 2 Related Work Sentence boundary detection and punctuation prediction have been extensively studied in the speech processing field and have attracted research interest in the natural language processing field as well . Most previous work exploits local features for the task . Kim and Woodland ( 2001 ) , Huang and Zweig ( 2002 ) , Christensen et al . ( 2001 ) , and Liu et al . ( 2005 ) integrate both prosodic features ( pitch , pause duration , etc . ) and lexical features ( words , n-grams , etc . ) to predict punctuation symbols during speech recognition , where Huang and Zweig ( 2002 ) uses a maximum entropy model , Christensen et al . ( 2001 ) focus on finite state and multi-layer perceptron methods , and Liu et al . ( 2005 ) uses conditional random fields . However , in some scenarios the prosodic cues are not available due to inaccessible original raw speech waveforms . Matusov et al . ( 2006 ) integrate segmentation features into the log-linear model in the statistical machine translation ( SMT ) framework to improve the translation performance when translating transcribed speech texts . Lu and Ng ( 2010 ) uses dynamic conditional random fields to perform both sentence boundary and sentence type prediction . They achieved promising results on both English and Chinese transcribed speech texts . The above work only ex ploits local features , so they were limited to capturing long range dependencies for punctuation prediction . It is natural to incorporate global knowledge , such as syntactic information , to improve punctuation prediction performance . Roark et al. ( 2006 ) use a rich set of non-local features including parser scores to re-rank full segmentations . Favre et al . ( 2008 ) integrate syntactic information from a PCFG parser into a log-linear and combine it with local features for sentence segmentation . The punctuation prediction in these works is performed as a post-procedure step of parsing , where a parse tree needs to be built in advance . As their parsing over the stream of words in transcribed speech text is exponentially complex , their approaches are only feasible for short input processing . Unlike these works , we incorporate punctuation prediction into the parsing which process left to right input without length limitations . Numerous dependency parsing algorithms have been proposed in the natural language processing community , including transition-based and graph-based dependency parsing . Compared to graph-based parsing , transition-based parsing can offer linear time complexity and easily leverage non-local features in the models ( Yamada and Matsumoto , 2003 ; Nivre et al. , 2006b ; Zhang and Clark , 2008 ; Huang and Sagae , 2010 ) . Starting with the work from ( Zhang and Nivre , 2011 ) , in this paper we extend transition-based dependency parsing from the sentence-level to the stream of words and integrate the parsing with punctuation prediction . Joint POS tagging and transition-based dependency parsing are studied in ( Hatori et al. , 2011 ; Bohnet and Nivre , 2012 ) . The improvements are reported with the joint model compared to the pipeline model for Chinese and other richly inflected languages , which shows that it also makes sense to jointly perform punctuation prediction and parsing , although these two tasks of POS tagging and punctuation prediction are different in two ways : 1 ) . The former usually works on a well-formed single sentence while the latter needs to process multiple sentences that are very lengthy . 2 ) . POS tags are must-have features to parsing while punctuations are not . The parsing quality in the former is more sensitive to the performance of the entire task than in the latter . 3 Transition-based dependency parsing In a typical transition-based dependency parsing process , the shift-reduce decoding algorithm is applied and a queue and stack are maintained ( Zhang and Nivre , 2011 ) . The queue stores the stream of transcribed speech words , the front of which is indexed as the current word . The stack stores the unfinished words which may be linked with the current word or a future word in the queue . When words in the queue are consumed from left to right , a set of transition actions is applied to build a parse tree . There are four kinds of transition actions conducted in the parsing process ( Zhang and Nivre , 2011 ) , as described in Table 1 . Action Description Shift Fetches the current word from the queue and pushes it to the stack Reduce Pops the stack LeftArc Adds a dependency link from the current word to the stack top , and pops the stack RightArc Adds a dependency link from the stack top to the current word , takes away the current word from the queue and pushes it to the stack The choice of each transition action during the parsing is scored by a linear model that can be trained over a rich set of non-local features extracted from the contexts of the stack , the queue and the set of dependency labels . As described in ( Zhang and Nivre , 2011 ) , the feature templates could be defined over the lexicons , POS-tags and the combinations with syntactic information . In parsing , beam search is performed to search the optimal sequence of transition actions , from which a parse tree is formed ( Zhang and Clark , 2008 ) . As each word must be pushed to the stack once and popped off once , the number of actions needed to parse a sentence is always 2n , where n is the length of the sentence . Thus , transitionbased parsing has a linear complexity with the length of input and naturally it can be extended to process the stream of words . 4 Our method 4.1 Model In the task of punctuation prediction , we are given a stream of words from an automatic transcription of speech text , denoted by 1 : = 1 , 2 , ... , . We are asked to output a sequence of punctuation symbols 1 : = 1 , 2 , ... , where is attached to to form a sentence like Figure 1 ( c ) . If there are no ambiguities , 1 is also abbreviated as , similarly for 1 as . We model the search of the best sequence of predicted punctuation symbols as : We introduce the transition-based parsing tree to guide the punctuation prediction in Model ( 2 ) , where parsing trees are constructed over the transcribed text while containing no punctuations . Rather than enumerate all possible parsing trees , we jointly optimize the punctuation prediction model and the transition-based parsing model with the form : It is noted that a partial parsing tree uniquely corresponds to a sequence of transition actions , and vice versa . Suppose 1 corresponds to the action sequence 1 and let denote the last action in 1 . As the current word can only be consumed from the queue by either Shift or RightArc according to Table 1 , we have [ , ] . Thus , we synchronize the punctuation prediction with the application of Shift and RightArc during the parsing , which is explained by Model ( 5 ) . The model is further refined by reducing the computation scope . When a full-stop punctuation is determined ( i.e. , a segmentation is formed ) , we discard the previous contexts and restart a new procedure for both parsing and punctuation prediction over the rest of words in the stream . In this way we are theoretically able to handle the unlimited stream of words without needing to always keep the entire context history of streaming words . Let be the position index of last full-stop punctuation1 before , and the partial tree and corresponding action sequence over the words With different computation of Model ( 6 ) , we induce two joint models for punctuation prediction : the cascaded punctuation prediction model and the unified punctuation prediction model . 4.2 Cascaded punctuation prediction model (CPP) Shift(,), Shift(N), Shift(N), LeftArc, LeftArc, LeftArc, Shift(N), RightArc(?), Reduce, Reduce In Model ( 6 ) , the computation of two sub-models is independent . The first sub-model is computed based on the context of words and partial trees without any punctuation knowledge , while the computation of the second sub-model is conditional on the context from the partially built parsing tree and the transition action . As the words in the stream are consumed , each computation of transition actions is followed by a computation of punctuation prediction . Thus , the two sub-models are computed in a cascaded way , until the optimal parsing tree and optimal punctuation symbols are generated . We call this model the cascaded punctuation prediction model ( CPP ) . 4.3 Unified punctuation prediction model ( UPP ) In Model ( 6 ) , if the punctuation symbols can be deterministically inferred from the partial tree , ( | , , ) can be omitted because it is always 1 . Similar to the idea of joint POS tagging and parsing ( Hatori et al. , 2011 ; Bohnet and Nivre , 2012 ) , we propose attaching the punctuation prediction onto the parsing tree by embedding into . Thus , we extend the conventional transition actions illustrated in Table 1 to a new set of transition actions for the parsing , denoted by : where Q is the set of punctuation symbols to be predicted , s is a punctuation symbol belonging to Q , Shift ( s ) is an action that attaches s to the current word on the basis of original Shift action in parsing , RightArc ( s ) attaches s to the current word on the basis of original RightArc action . With the redefined transition action set A , the computation of Model ( 6 ) is reformulated as : Here , the computation of parsing tree and punctuation prediction is unified into one model where the sequence of transition action outputs uniquely determines the punctuations attached to the words . We refer to it as the unified punctuation prediction model ( UPP ) . ( a ) . Parsing tree and attached punctuation symbols to produce the parsing tree in Figure 2 ( a ) . According to the sequence of actions , we can determine the sequence of predicted punctuation symbols like , NNN ? that have been attached to the words shown in Figure 2 ( a ) . The final segmentation with the predicted punctuation insertion could be so , could you tell me ? . 4.4 Model training and decoding In practice , the sub-models in Model ( 6 ) and ( 7 ) with the form of P ( Y IX ) is computed with a linear model Score ( Y , X ) as where 0 ( Y , X ) is the feature vector extracted from the output Y and the context X , and A is the weight vector . For the features of the models , we incorporate the bag of words and POS tags as well as tree-based features shown in Table 2 , which are the same as those defined in ( Zhang and Nivre , 2011 ) . Table 2 . ( a ) Features of the bag of words and POS tags . ( b ) . Tree-based features . wword ; pPOS tag ; ddistance between ws and w0 ; vnumber of modifiers ; tdependency label ; Tset of dependency labels ; s , 0 , 1 and 2 index the stack top and three front items in the queue respectively ; hhead ; lleft/leftmost ; rright/rightmost ; h2head of a head ; l2second leftmost ; r2second rightmost . The training data for both the CPP and UPP models need to contain parsing trees and punctuation information . Due to the absence of annotation over transcribed speech data , we adapt the Treebank data for the purpose of model training . To do this , we remove all types of syntactic information related to punctuation symbols from the raw Treebank data , but record what punctuation symbols are attached to the words . We normalize various punctuation symbols into two types : Middle-paused punctuation ( M ) and Full-stop punctuation ( F ) . Plus null type ( N ) , there are three kinds of punctuation symbols attached to the words . Table 3 illustrates the normalizations of punctuation symbols . In the experiments , we did not further distinguish the type among full-stop punctuation because the question mark and the exclamation mark have very low frequency in Treebank data . But our CPP and UPP models are both independent regarding the number of punctuation types to be predicted . As the feature templates are the same for the model training of both CPP and UPP , the training instances of CPP and UPP have the same contexts but with different outputs . Similar to work in ( Zhang and Clark , 2008 ; Zhang and Nivre , 2011 ) , we train CPP and UPP by generalized perceptron ( Collins , 2002 ) . In decoding , beam search is performed to get the optimal sequence of transition actions in CPP and UPP , and the optimal punctuation symbols in CPP . To ensure each segment decided by a fullstop punctuation corresponds to a single parsing tree , two constraints are applied in decoding for the pruning of deficient search paths . 5 Experiments 5.1 Experimental setup Our training data of transition-based dependency trees are converted from phrasal structure trees in English Web Treebank ( LDC2012T13 ) and the English portion of OntoNotes 4.0 ( LDC2011T03 ) by the Stanford Conversion toolkit ( Marneffe et al . , 2006 ) . It contains around 1.5 M words in total and consist of various genres including weblogs , web texts , newsgroups , email , reviews , questionanswer sessions , newswires , broadcast news and broadcast conversations . To simulate the transcribed speech text , all words in dependency trees are lowercased and punctuations are excluded before model training . In addition , every ten dependency trees are concatenated sequentially to simulate a parsing result of a stream of words in the model training . There are two test data sets used in our experiments . One is the English corpus of the IWSLT09 evaluation campaign ( Paul , 2009 ) that is the conversional speech text . The other is a subset of the TDT4 English data ( LDC2005T16 ) which consists of 200 hours of closed-captioned broadcast news . In the decoding , the beam size of both the transition-based parsing and punctuation prediction is set to 5 . The part-of-speech tagger is our re-implementation of the work in ( Collins , 2002 ) . The evaluation metrics of our experiments are precision ( prec . ) , recall ( rec . ) and F1 - measure ( F1 ) . For the comparison , we also implement a baseline method based on the CRF model . It incorporates the features of bag of words and POS tags shown in Table 2 ( a ) , which are commonly used in previous related work . 5.2 Experimental results We test the performance of our method on both the correctly recognized texts and automatically recognized texts . The former data is used to evaluate the capability of punctuation prediction of our algorithm regardless of the noises from speech data , as our model training data come from formal text instead of transcribed speech data . The usage of the latter test data set aims to evaluate the effectiveness of our method in real applications where lots of substantial recognition errors could be contained . In addition , we also evaluate the quality of our transition-based parsing , as its performance could have a big influence on the quality of punctuation prediction . 5.2.1 Performance on correctly recognized text The evaluation of our method on correctly recognized text uses 10 % of IWSLT09 training set , which consists of 19,972 sentences from BTEC ( Basic Travel Expression Corpus ) and 10,061 sentences from CT ( Challenge Task ) . The average input length is about 10 words and each input contains 1.3 sentences on average . The evaluation results are presented in Table 4 . We achieved good performance on full-stop punctuation compared to the baseline , which shows our method can efficiently process sentence segmentation because each segment is decided by the structure of a single parsing tree . In addition , the global syntactic knowledge used in our work help capture long range dependencies of punctuations . The performance of middle-paused punctuation prediction is fairly low between all methods , which shows predicting middle-paused punctuations is a difficult task . This is because the usage of middle-paused punctuations is very flexible , especially in conversional data . The last column in Table 4 presents the performance of the pure segmentation task where the middle-paused and full-stop punctuations are mixed and not distinguished . The performance of our method is much higher than that of the baseline , which shows our method is good at segmentation . We also note that UPP yields slightly better performance than CPP on full-stop and mixed punctuation prediction , and much better performance on middle-paused punctuation prediction . This could be because the interaction of parsing and punctuation prediction is closer together in UPP than in CPP . 5.2.2 Performance on automatically recognized text Table 5 shows the experimental results of punctuation prediction on automatically recognized text from TDT4 data that is recognized using SRIs English broadcast news ASR system where the word error rate is estimated to be 18 % . As the annotation of middle-paused punctuations in TDT4 is not available , we can only evaluate the performance of full-stop punctuation prediction ( i.e . , detecting sentence boundaries ) . Thus , we merge every three sentences into one single input before performing full-stop prediction . The average input length is about 43 words . Generally , the performance shown in Table 5 is not as high as that in Table 4 . This is because the speech recognition error from ASR systems degrades the capability of model prediction . Another reason might be that the domain and style of our training data mismatch those of TDT4 data . The baseline gets a little higher recall than our method , which shows the baseline method tends to make aggressive segmentation decisions . However , both precision and F1 score of our method are much higher than the baseline . CPP has higher recall than UPP , but with lower precision and F1 score . This is in line with Table 4 , which consistently illustrates CPP can get higher recall on fullstop punctuation prediction for both correctly recognized and automatically recognized texts . 5.2.3 Performance of transition-based parsing Performance of parsing affects the quality of punctuation prediction in our work . In this section , we separately evaluate the performance of our transition-based parser over various domains including the Wall Street Journal ( WSJ ) , weblogs , newsgroups , answers , email messages and reviews . We divided annotated Treebank data into three data sets : 90 % for model training , 5 % for the development set and 5 % for the test set . The accuracy of our POS-tagger achieves 96.71 % . The beam size in the decoding of both our POS-tagging and parsing is set to 5 . Table 6 presents the results of our experiments on the measures of UAS and LAS , where the overall accuracy is obtained from a general model which is trained over the combination of the training data from all domains . We first evaluate the performance of our transition-based parsing over texts containing punctuations ( TCP ) . The evaluation results show that our transition-based parser achieves state-of-the-art performance levels , referring to the best dependency parsing results reported in the shared task of SANCL 2012 workshop2 , although they can not be compared directly due to the different training data and test data sets used in the experiments . Secondly , we evaluate our parsing model in CPP over the texts without punctuations ( TOP ) . Surprisingly , the performance over TOP is better than that over TCP . The reason could be that we cleaned out data noises caused by punctuations when preparing TOP data . These results illustrate that the performance of transition-based parsing in our method does not degrade after being integrated with punctuation prediction . As a by-product of the punctuation prediction task , the outputs of parsing trees can benefit the subsequent text processing tasks . 6 Conclusion and Future Work In this paper , we proposed a novel method for punctuation prediction of transcribed speech texts . Our approach jointly performs parsing and punctuation prediction by integrating a rich set of syntactic features . It can not only yield parse trees , but also determine sentence boundaries and predict punctuation symbols from a global view of the in puts . The proposed algorithm has linear complexity in the size of input , which can efficiently process the stream of words from a purely text processing perspective without the dependences on either the ASR systems or subsequent tasks . The experimental results show that our approach outperforms the CRF-based method on both the correctly recognized and automatically recognized texts . In addition , the performance of the parsing over the stream of transcribed words is state-ofthe-art , which can benefit many subsequent text processing tasks . In future work , we will try our method on other languages such as Chinese and Japanese , where Treebank data is available . We would also like to test the MT performance over transcribed speech texts with punctuation symbols inserted based on our method proposed in this paper . "}
  },
    {
    "id": "P13-2153",
    "result":     [
            {
        "value":         {
          "start": 4511,
          "end": 4536,
          "text": "CMU Pronouncing Dictionary",
          "labels": ["Dataset"]
        },
        "id": 829
      },
            {
        "value":         {
          "start": 5211,
          "end": 5248,
          "text": "Carnegie Mellon University ( CMUdict )",
          "labels": ["Dataset"]
        },
        "id": 830
      },
            {
        "value":         {
          "start": 5252,
          "end": 5258,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 5456,
          "end": 5469,
          "text": "cmudict .0.7 a",
          "labels": ["Dataset"]
        },
        "id": 832
      },
            {
        "value":         {
          "start": 5538,
          "end": 5544,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 6182,
          "end": 6188,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 6387,
          "end": 6399,
          "text": "edit distance",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 6407,
          "end": 6425,
          "text": "commonbiphone check",
          "labels": ["Method"]
        },
        "id": 833
      },
            {
        "value":         {
          "start": 6551,
          "end": 6582,
          "text": "phoneticsimilarity score ( PSS )",
          "labels": ["Metric"]
        },
        "id": 834
      },
            {
        "value":         {
          "start": 6590,
          "end": 6617,
          "text": "common-biphone score ( CBS )",
          "labels": ["Metric"]
        },
        "id": 835
      },
            {
        "value":         {
          "start": 6625,
          "end": 6627,
          "text": "PSS",
          "labels": ["Metric"]
        },
        "id": 842
      },
            {
        "value":         {
          "start": 6841,
          "end": 6843,
          "text": "PSS",
          "labels": ["Metric"]
        },
        "id": 842
      },
            {
        "value":         {
          "start": 6927,
          "end": 6929,
          "text": "CBS",
          "labels": ["Metric"]
        },
        "id": 843
      },
            {
        "value":         {
          "start": 7850,
          "end": 7868,
          "text": "editdistance method",
          "labels": ["Method"]
        },
        "id": 838
      },
            {
        "value":         {
          "start": 7912,
          "end": 7932,
          "text": "common-biphone method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 8011,
          "end": 8020,
          "text": "CBS method",
          "labels": ["Method"]
        },
        "id": 840
      },
            {
        "value":         {
          "start": 8028,
          "end": 8037,
          "text": "PSS method",
          "labels": ["Method"]
        },
        "id": 841
      },
            {
        "value":         {
          "start": 8297,
          "end": 8303,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 8317,
          "end": 8319,
          "text": "PSS",
          "labels": ["Metric"]
        },
        "id": 842
      },
            {
        "value":         {
          "start": 8479,
          "end": 8498,
          "text": "commonbiphone method",
          "labels": ["Method"]
        },
        "id": 842
      },
            {
        "value":         {
          "start": 8564,
          "end": 8566,
          "text": "CBS",
          "labels": ["Metric"]
        },
        "id": 843
      },
            {
        "value":         {
          "start": 8620,
          "end": 8625,
          "text": "Python",
          "labels": ["Tool"]
        },
        "id": 1453
      },
            {
        "value":         {
          "start": 8903,
          "end": 8909,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 9002,
          "end": 9050,
          "text": "decision tree-based grapheme-to-phoneme algorithm",
          "labels": ["Method"]
        },
        "id": 844
      },
            {
        "value":         {
          "start": 9067,
          "end": 9073,
          "text": "CMUdict",
          "labels": ["Dataset"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 9109,
          "end": 9112,
          "text": "PSSs",
          "labels": ["Metric"]
        },
        "id": 845
      },
            {
        "value":         {
          "start": 9118,
          "end": 9121,
          "text": "CBSs",
          "labels": ["Metric"]
        },
        "id": 846
      },
            {
        "value":         {
          "start": 9281,
          "end": 9319,
          "text": "mean pairwise similarity score ( MPSS )",
          "labels": ["Metric"]
        },
        "id": 847
      },
            {
        "value":         {
          "start": 9323,
          "end": 9347,
          "text": "mean chain length ( MCL )",
          "labels": ["Metric"]
        },
        "id": 848
      },
            {
        "value":         {
          "start": 9355,
          "end": 9383,
          "text": "maximum chain length ( MXCL )",
          "labels": ["Metric"]
        },
        "id": 849
      },
            {
        "value":         {
          "start": 12495,
          "end": 12499,
          "text": "ANOVA",
          "labels": ["Method"]
        },
        "id": 850
      },
            {
        "value":         {
          "start": 12996,
          "end": 12999,
          "text": "MPSS",
          "labels": ["Metric"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13054,
          "end": 13074,
          "text": "common-biphone method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13225,
          "end": 13228,
          "text": "MPSS",
          "labels": ["Metric"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13686,
          "end": 13688,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 13694,
          "end": 13697,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 13843,
          "end": 13863,
          "text": "common-biphone method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13867,
          "end": 13869,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 13891,
          "end": 13911,
          "text": "common-biphone method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13933,
          "end": 13952,
          "text": "edit-distance method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 13956,
          "end": 13959,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 13981,
          "end": 13994,
          "text": "common biphone",
          "labels": ["Method"]
        },
        "id": 855
      },
            {
        "value":         {
          "start": 14016,
          "end": 14028,
          "text": "edit distance",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 14076,
          "end": 14078,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 14084,
          "end": 14087,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 14168,
          "end": 14170,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 14191,
          "end": 14194,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 14834,
          "end": 14854,
          "text": "common-biphone method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 14940,
          "end": 14943,
          "text": "MPSS",
          "labels": ["Metric"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 14947,
          "end": 14949,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 14957,
          "end": 14960,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 15012,
          "end": 15031,
          "text": "edit-distance method",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 15066,
          "end": 15087,
          "text": "Commonbiphone measures",
          "labels": ["Method"]
        },
        "id": 856
      },
            {
        "value":         {
          "start": 15251,
          "end": 15281,
          "text": "automated common-biphone method",
          "labels": ["Method"]
        },
        "id": 857
      },
            {
        "value":         {
          "start": 16476,
          "end": 16478,
          "text": "MCL",
          "labels": ["Metric"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 16484,
          "end": 16487,
          "text": "MXCL",
          "labels": ["Metric"]
        },
        "id": 858
      }
    ],
    "data": {"text": "Computerized Analysis of a Verbal Fluency Test Abstract We present a system for automated phonetic clustering analysis of cognitive tests of phonemic verbal fluency , on which one must name words starting with a specific letter ( e.g. , F ) for one minute . Test responses are typically subjected to manual phonetic clustering analysis that is labor-intensive and subject to inter-rater variability . Our system provides an automated alternative . In a pilot study , we applied this system to tests of 55 novice and experienced professional fighters ( boxers and mixed martial artists ) and found that experienced fighters produced significantly longer chains of phonetically similar words , while no differences were found in the total number of words produced . These findings are preliminary , but strongly suggest that our system can be used to detect subtle signs of brain damage due to repetitive head trauma in individuals that are otherwise unimpaired . 1 Introduction The neuropsychological test of phonemic verbal fluency ( PVF ) consists of asking the patient to generate as many words as he or she can in a limited time ( usually 60 seconds ) that begin with a specific letter of the alphabet ( Benton et al. , 1989 ) . This test has been used extensively as part of larger cognitive test batteries to study cognitive impairment resulting from a number of neurological conditions , including Parkinsons and Huntingtons diseases , various forms of dementia , and traumatic brain injury ( Troyer et al. , 1998a , b ; Raskin et al. , 1992 ; Ho et al. , 2002 ) . Patients with these disorders tend to generate significantly fewer words on this test than do healthy individuals . Prior studies have also found that clustering ( the degree to which patients generate groups of phonetically similar words ) and switching ( transitioning from one cluster to the next ) behaviors are also sensitive to the effects of these neurological conditions . Contact sports such as boxing , mixed martial arts , football , and hockey are well known for high prevalence of repetitive head trauma . In recent years , the long-term effects of repetitive head trauma in athletes has become the subject of intensive research . In general , repetitive head trauma is a known risk factor for chronic traumatic encephalopathy ( CTE ) , a devastating and untreatable condition that ultimately results in permanent disability and premature death ( Omalu et al. , 2010 ; Gavett et al. , 2011 ) . However , little is currently known about the relationship between the amount of exposure to head injury and the magnitude of risk for developing these conditions . Furthermore , the development of new behavioral methods aimed at detection of subtle early signs of brain impairment is an active area of research . The PVF test is an excellent target for this research because it is very easy to administer and has been shown to be sensitive to the effects of acute traumatic brain injury ( Raskin and Rearick , 1996 ) . However , a major obstacle to using this test widely for early detection of brain impairment is that clustering and switching analyses needed to detect these subtle changes have to be done manually . These manual approaches are extremely laborintensive , and are therefore limited in the types of clustering analyses that can be performed . Manual methods are also not scalable to large numbers of tests and are subject to inter-rater variability , making the results difficult to compare across subjects , as well as across different studies . Moreover , traditional manual clustering and switching analyses rely primarily on word orthography to determine phonetic similarity ( e.g. , by comparing the first two letters of two words ) , rather than phonetic representations , which would be prohibitively time consuming to obtain by hand . Phonetic similarity has been investigated in application to a number of research areas , including spelling correction ( Toutanova and Moore , 2002 ) , machine translation ( Knight and Graehl , 1998 ; Kondrak et al. , 2003 ) , cross-lingual information retrieval ( Melamed , 1999 ; Fujii and Ishikawa , 2001 ) , language acquisition ( Somers , 1998 ) , historical linguistics ( Raman et al. , 1997 ) , and socialmedia informatics ( Liu et al. , 2012 ) ; we propose a novel clinical application . Our objective was to develop and pilot-test a relatively simple , but robust , system for automatic identification of word clusters , based on phonetic content , that uses the CMU Pronouncing Dictionary , a decision tree-based algorithm for generating pronunciations for out-of-dictionary words , and two different approaches to calculating phonetic similarity between words . We first describe the system architecture and our phonetic-similarity computation methods , and then present the results of a pilot study , using data from professional fighters , demonstrating the utility of this system for early detection of subtle signs of brain impairment . 2 Automated Clustering Analysis Figure 1 shows the high-level architecture and workflow of our system . 2.1 Pronunciation Dictionary We use a dictionary developed for speech recognition and synthesis applications at the Carnegie Mellon University ( CMUdict ) . CMUdict contains phonetic transcriptions , using a phone set based on ARPABET ( Rabiner and Juang , 1993 ) , for North American English word pronunciations ( Weide , 1998 ) . We used the latest version , cmudict .0.7 a , which contains 133,746 entries . From the full set of entries in CMUdict , we removed alternative pronunciations for each word , leaving a single phonetic representation for each heteronymous set . Additionally , all vowel symbols were stripped of numeric stress markings ( e.g. , AH1 AH ) , and all multicharacter phone symbols were converted to arbitrary singlecharacter symbols , in lowercase to distinguish these symbols from the original single-character ARPABET symbols ( e.g. , AH c ) . Finally , whitespace between the symbols constituting each phonetic representation was removed , yielding compact phonetic-representation strings suitable for computing our similarity measures . To illustrate , the CMUdict pronunciation entry for the word phonetic , [ F AH0 N EH1 T IH0 K ] , would be represented as FcNiTmK . 2.2 Similarity Computation Our system uses two methods for determining phonetic similarity : edit distance and a commonbiphone check . Each of these methods gives a measure of similarity for a pair of phonetic representations , which we respectively call a phoneticsimilarity score ( PSS ) and a common-biphone score ( CBS ) . For PSS , we first compute the Levenshtein distance ( Levenshtein , 1966 ) between compact phonetic-representation strings and normalize that to the length of the longer string ; then , that value is subtracted from 1 . PSS values range from 0 to 1 , with higher scores indicating greater similarity . The CBS is binary , with a score of 1 given for two phonetic representations that have a common initial and / or final biphone , and 0 for two strings that have neither in common . 2.3 Phonetic Clustering We distinguish between two ways of defining phonetic clusters . Traditionally , any sequence of n words in a PVF response is deemed to form a cluster if all pairwise word combinations for that sequence are determined to be phonetically similar by some metric . In addition to this method , we developed a less stringent approach in which we define chains instead of clusters . A chain comprises a sequence for which the phonetic representation of each word is similar to that of the word immediately prior to it in the chain ( unless it is chain-initial ) and the word subsequent to it ( unless it is chain-final ) . Lone words that do not belong to any cluster constitute singleton clusters . We call chains based on the editdistance method phonetic chains , and chains based on the common-biphone method common-biphone chains ; both are illustrated in Figure 2 . Unlike the binary CBS method , the PSS method produces continuous edit-distance values , and therefore requires a threshold for categorizing a word pair as similar or dissimilar . We determine the threshold empirically for each letter by taking a random sample of 1000 words starting with that letter in CMUdict , computing PSS scores for each pairwise combination ( n = 499 , 500 ) , and then setting the threshold as the value separating the upper quintile of these scores . With the commonbiphone method , two words are considered phonetically similar simply if their CBS is 1 . 2.4 System Overview Our system is written in Python , and is available online . The system accepts transcriptions of a PVF response for a specific letter and , as a preprocessing step , removes any words that do not begin with that letter . After pre-processing , all words are phoneticized by dictionary lookup in our modified CMUdict . For out-of-dictionary words , we automatically generate a phonetic representation with a decision tree-based grapheme-to-phoneme algorithm trained on the CMUdict ( Pagel et al . , 1998 ) . Next , PSSs and CBSs are computed sequentially for each pair of contiguous phonetic representations , and are used in their respective methods to compute the following measures : mean pairwise similarity score ( MPSS ) , mean chain length ( MCL ) , and maximum chain length ( MXCL ) . Singletons are included in these calculations as chains of length 1 . We also calculate equivalent measures for clusters , but do not present these results here due to space limitations , as they are similar to those for chains . In addition to these measures , our system produces a count of the total number of words that start with the letter specified for the PVF test ( WCNT ) , and a count of repeated words ( RCNT ) . 3 Pilot Study 3.1 Participants We used PVF tests from 55 boxers and mixed martial artists ( 4 women , 51 men ; mean age 27.7 y.o. , SD 6.0 ) that participated in the Professional Fighters Brain Health Study ( PFBH ) . The PFBH is a longitudinal study of unarmed active professional fighters , retired professional fighters , and age/education matched controls ( Bernick et al. , in press ) . It is designed to enroll over 400 participants over the next five years . The 55 participants in our pilot represent a sample from the first wave of assessments , conducted in summer of 2012 . All 55 participants were fluent speakers of English and were able to read at at least a 4th-grade level . None of these participants fought in a professional or amateur competition within 45 days prior to testing . 3.2 Methods Each participants professional fighting history was used to determine his or her total number of pro fights and number of fights per year . These figures were used to construct a composite fightexposure index as a summary measure of cumulative traumatic exposure , as follows . Fighters with zero professional fights were assigned a score of 0 ; fighters with between 1 and 15 total fights , but only one or fewer fights per year , were assigned a score of 1 ; fighters with 1-15 total fights , and more than one fight per year , got a score of 2 ; fighters with more than 15 total fights , but only one or fewer fights per year , got a score of 3 ; remaining fighters , with more than 15 fights and more than one fight per year , were assigned the highest score of 4 . Due to the relatively small sample size in our pilot study , we combined groups with scores of 0 and 1 to constitute the low-exposure group ( n = 25 ) , and the rest were assigned to the highexposure group ( n = 30 ) . All participants underwent a cognitive test battery that included the PVF test ( letter F ) . Their responses were processed by our system , and means for our chaining variables of interest , as well as counts of total words and repetitions , were compared across the low - and high-exposure groups . Additionally , all 55 PVF responses were subjected to manual phonetic clustering analysis , following the methodology of Troyer et al. ( 1997 ) . With this approach , clusters are used instead of chains , and two words are considered phonetically similar if they meet any of the following conditions : they begin with the same two orthographic letters ; they rhyme ; they differ by only a vowel sound ( e.g. , flip and flop ) ; or they are homophones . For each clustering method , the differences in means between the groups were tested for statistical significance using one-way ANOVA adjusted for the effects of age and years of education . Spearman correlation was used to test for associations between continuous variables , due to nonlinearity , and to directly compare manually determined clustering measures with corresponding automatically determined chain measures . 4 Results The results of comparisons between the clustering methods , as well as between the low - and highexposure groups , are illustrated in Figure 3.2 We found a significant difference ( p < 0.02 ) in MPSS between the high - and low-exposure groups using the common-biphone method ( 0.15 vs . 0.11 ) , while with edit distance the difference was small ( 0.29 vs . 0.28 ) and not significant ( Figure 3a ) . Due to infeasibility , MPSS was not calculated manually . Mean chain sizes determined by the commonbiphone method correlated with manually determined cluster sizes more strongly than did chain sizes determined by edit distance ( = 0.73 , p < 0.01 vs. = 0.48 , p < 0.01 ) . Comparisons of maximum chain and cluster sizes showed a similar pattern ( = 0.71 , p < 0.01 vs. = 0.39 , p < 0.01 ) . Both automatic methods showed significant differences ( p < 0.01 ) between the two groups in MCL and MXCL , with each finding longer chains in the high-exposure group ( Figure 3b , 3c ) ; however , slightly larger differences were observed using the common-biphone method ( MCL : 2.79 vs . 2.21 by common-biphone method , 3.23 vs . 2.80 by edit-distance method ; MXCL : 3.94 vs . 2.64 by common biphone , 4.94 vs . 3.76 by edit distance ) . Group differences for manually determined MCL and MXCL were also significant ( p < 0.05 and p < 0.02 , respectively ) , but less so ( MCL : 1.71 vs . 1.46 ; MXCL : 4.0 vs . 3.04 ) . 5 Discussion While manual phonetic clustering analysis yielded significant differences between the low - and highexposure fighter groups , our automatic approach , which utilizes phonetic word representations , appears to be more sensitive to these differences ; it also appears to produce less variability on clustering measures . Furthermore , as discussed above , automatic analysis is much less labor-intensive , and thus is more scalable to large numbers of tests . Moreover , our system is not prone to human error during analysis , nor to inter-rater variability . Of the two automatic clustering methods , the common-biphone method , which uses binary similarity values , found greater differences between groups in MPSS , MCL , and MXCL ; thus , it appears to be more sensitive than the edit-distance method in detecting group differences . Commonbiphone measures were also found to better correlate with manual measures ; however , both automated methods disagreed with the manual approach to some extent . The fact that the automated common-biphone method shows significant differences between group means , while having less variability in measurements , suggests that it may be a more suitable measure of phonetic clustering than the traditional manual method . These results are particularly important in light of the difference in WCNT means between lowand high-exposure groups being small and not significant ( WCNT : 17.6 , SD 5.1 vs. 18.7 , SD 4.7 ; p = 0.24 ) . Other studies that used manual clustering and switching analyses reported significantly more switches for healthy controls than for individuals with neurological conditions ( Troyer et al. , 1997 ) . These studies also reported differences in the total number of words produced , likely due to investigating already impaired individuals . Our findings show that the low - and highexposure groups produced similar numbers of words , but the high-exposure group tended to produce longer sequences of phonetically similar words . The latter phenomenon may be interpreted as a mild form of perseverative ( stuck-inset/repetitive ) behavior that is characteristic of disorders involving damage to frontal and subcortical brain structures . To test this interpretation , we correlated MCL and MXCL , the two measures with greatest differences between low - and high-exposure fighters , with the count of repeated words ( RCNT ) . The resulting correlations were 0.41 ( p = 0.01 ) and 0.48 ( p < 0.001 ) , respectively , which supports the perseverative-behavior interpretation of our findings . Clearly , these findings are preliminary and need to be confirmed in larger samples ; however , they plainly demonstrate the utility of our fully automated and quantifiable approach to characterizing and measuring clustering behavior on PVF tests . Pending further clinical validation , this system may be used for large-scale screening for subtle signs of certain types of brain damage or degeneration not only in contact-sports athletes , but also in the general population . "}
  },
    {
    "id": "P14-1022",
    "result":     [
            {
        "value":         {
          "start": 2227,
          "end": 2238,
          "text": "PCFG parsers",
          "labels": ["Method"]
        },
        "id": 858
      },
            {
        "value":         {
          "start": 2449,
          "end": 2473,
          "text": "tree-substitution parsers",
          "labels": ["Method"]
        },
        "id": 859
      },
            {
        "value":         {
          "start": 2508,
          "end": 2525,
          "text": "neural net parsers",
          "labels": ["Method"]
        },
        "id": 860
      },
            {
        "value":         {
          "start": 2554,
          "end": 2562,
          "text": "rerankers",
          "labels": ["Method"]
        },
        "id": 861
      },
            {
        "value":         {
          "start": 4293,
          "end": 4296,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 4427,
          "end": 4434,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 4464,
          "end": 4466,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 4666,
          "end": 4669,
          "text": "PCFG",
          "labels": ["Method"]
        },
        "id": 862
      },
            {
        "value":         {
          "start": 5095,
          "end": 5096,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 5410,
          "end": 5411,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 5953,
          "end": 5965,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 6077,
          "end": 6082,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 6222,
          "end": 6229,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 7196,
          "end": 7212,
          "text": "Adagrad algorithm",
          "labels": ["Method"]
        },
        "id": 863
      },
            {
        "value":         {
          "start": 7288,
          "end": 7300,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 7521,
          "end": 7533,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 7613,
          "end": 7614,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7640,
          "end": 7652,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 7704,
          "end": 7707,
          "text": "CRFs",
          "labels": ["Method"]
        },
        "id": 864
      },
            {
        "value":         {
          "start": 7733,
          "end": 7740,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 8548,
          "end": 8550,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 8603,
          "end": 8626,
          "text": "structured margin parser",
          "labels": ["Method"]
        },
        "id": 865
      },
            {
        "value":         {
          "start": 9321,
          "end": 9333,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 9796,
          "end": 9808,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 10324,
          "end": 10336,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 10479,
          "end": 10481,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 10583,
          "end": 10595,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 12101,
          "end": 12103,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 13975,
          "end": 13987,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 15831,
          "end": 15847,
          "text": "parent annotation",
          "labels": ["Method"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 15886,
          "end": 15902,
          "text": "Parent annotation",
          "labels": ["Method"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 16687,
          "end": 16698,
          "text": "Xbar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 16814,
          "end": 16815,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 16825,
          "end": 16826,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19199,
          "end": 19227,
          "text": "Penn Treebank development set",
          "labels": ["Dataset"]
        },
        "id": 868
      },
            {
        "value":         {
          "start": 19317,
          "end": 19328,
          "text": "Xbar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 19891,
          "end": 19903,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 20206,
          "end": 20218,
          "text": "X-bar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 21554,
          "end": 21565,
          "text": "Xbar grammar",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 22074,
          "end": 22087,
          "text": "Collinss model",
          "labels": ["Method"]
        },
        "id": 869
      },
            {
        "value":         {
          "start": 22205,
          "end": 22217,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 22290,
          "end": 22304,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 22947,
          "end": 22961,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 23572,
          "end": 23636,
          "text": "Statistical Parsing of Morphologically Rich Languages Shared Task",
          "labels": ["Dataset"]
        },
        "id": 871
      },
            {
        "value":         {
          "start": 23684,
          "end": 23698,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 23773,
          "end": 23787,
          "text": "Replaced system",
          "labels": ["Method"]
        },
        "id": 873
      },
            {
        "value":         {
          "start": 23879,
          "end": 23893,
          "text": "Replaced system",
          "labels": ["Method"]
        },
        "id": 873
      },
            {
        "value":         {
          "start": 23908,
          "end": 23922,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 24277,
          "end": 24294,
          "text": "Berkeley-Rep model",
          "labels": ["Method"]
        },
        "id": 873
      },
            {
        "value":         {
          "start": 24354,
          "end": 24368,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 24450,
          "end": 24462,
          "text": "Berkeley-Tags",
          "labels": ["Method"]
        },
        "id": 876
      },
            {
        "value":         {
          "start": 24573,
          "end": 24583,
          "text": "BerkeleyRep",
          "labels": ["Method"]
        },
        "id": 875
      },
            {
        "value":         {
          "start": 24589,
          "end": 24601,
          "text": "Berkeley-Tags",
          "labels": ["Method"]
        },
        "id": 876
      },
            {
        "value":         {
          "start": 24640,
          "end": 24655,
          "text": "Berkeley parsers",
          "labels": ["Method"]
        },
        "id": 876
      },
            {
        "value":         {
          "start": 24796,
          "end": 24810,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 24906,
          "end": 24924,
          "text": "Berkeley-Rep parser",
          "labels": ["Method"]
        },
        "id": 877
      },
            {
        "value":         {
          "start": 24970,
          "end": 24984,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 24994,
          "end": 25012,
          "text": "BerkeleyTags parser",
          "labels": ["Method"]
        },
        "id": 878
      },
            {
        "value":         {
          "start": 25109,
          "end": 25123,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 25304,
          "end": 25318,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 25715,
          "end": 25726,
          "text": "suffix model",
          "labels": ["Method"]
        },
        "id": 879
      },
            {
        "value":         {
          "start": 26453,
          "end": 26465,
          "text": "Penn Treebank",
          "labels": ["Dataset"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 28483,
          "end": 28499,
          "text": "parent annotation",
          "labels": ["Method"]
        },
        "id": 880
      },
            {
        "value":         {
          "start": 29121,
          "end": 29147,
          "text": "Stanford Sentiment Treebank",
          "labels": ["Dataset"]
        },
        "id": 966
      },
            {
        "value":         {
          "start": 30753,
          "end": 30768,
          "text": "Stanford CoreNLP",
          "labels": ["Method"]
        },
        "id": 1407
      },
            {
        "value":         {
          "start": 30953,
          "end": 30967,
          "text": "Stanford system",
          "labels": ["Method"]
        },
        "id": 882
      },
            {
        "value":         {
          "start": 31023,
          "end": 31030,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 31573,
          "end": 31587,
          "text": "Berkeley parser",
          "labels": ["Method"]
        },
        "id": 883
      }
    ],
    "data": {"text": "Less Grammar , More Features Abstract We present a parser that relies primarily on extracting information directly from surface spans rather than on propagating information through enriched grammar structure . For example , instead of creating separate grammar symbols to mark the definiteness of an NP , our parser might instead capture the same information from the first word of the NP . Moving context out of the grammar and onto surface features can greatly simplify the structural component of the parser : because so many deep syntactic cues have surface reflexes , our system can still parse accurately with context-free backbones as minimal as Xbar grammars . Keeping the structural backbone simple and moving features to the surface also allows easy adaptation to new languages and even to new tasks . On the SPMRL 2013 multilingual constituency parsing shared task ( Seddah et al. , 2013 ) , our system outperforms the top single parser system of Bjorkelund et al. ( 2013 ) on a range of languages . In addition , despite being designed for syntactic analysis , our system also achieves stateof-the-art numbers on the structural sentiment task of Socher et al. ( 2013 ) . Finally , we show that , in both syntactic parsing and sentiment analysis , many broad linguistic trends can be captured via surface features . 1 Introduction Naive context-free grammars , such as those embodied by standard treebank annotations , do not parse well because their symbols have too little context to constrain their syntactic behavior . For example , to PPs usually attach to verbs and of PPs usually attach to nouns , but a context-free PP symbol can equally well attach to either . Much of the last few decades of parsing research has therefore focused on propagating contextual information from the leaves of the tree to internal nodes . For example , head lexicalization ( Eisner , 1996 ; Collins , 1997 ; Charniak , 1997 ) , structural annotation ( Johnson , 1998 ; Klein and Manning , 2003 ) , and state-splitting ( Matsuzaki et al. , 2005 ; Petrov et al. , 2006 ) are all designed to take coarse symbols like PP and decorate them with additional context . The underlying reason that such propagation is even needed is that PCFG parsers score trees based on local configurations only , and any information that is not threaded through the tree becomes inaccessible to the scoring function . There have been non-local approaches as well , such as tree-substitution parsers ( Bod , 1993 ; Simaan , 2000 ) , neural net parsers ( Henderson , 2003 ) , and rerankers ( Collins and Koo , 2005 ; Charniak and Johnson , 2005 ; Huang , 2008 ) . These non-local approaches can actually go even further in enriching the grammars structural complexity by coupling larger domains in various ways , though their non-locality generally complicates inference . In this work , we instead try to minimize the structural complexity of the grammar by moving as much context as possible onto local surface features . We examine the position that grammars should not propagate any information that is available from surface strings , since a discriminative parser can access that information directly . We therefore begin with a minimal grammar and iteratively augment it with rich input features that do not enrich the context-free backbone . Previous work has also used surface features in their parsers , but the focus has been on machine learning methods ( Taskar et al. , 2004 ) , latent annotations ( Petrov and Klein , 2008a ; Petrov and Klein , 2008b ) , or implementation ( Finkel et al. , 2008 ) . By contrast , we investigate the extent to which we need a grammar at all . As a thought experiment , consider a parser with no grammar , which functions by independently classifying each span ( i , j ) of a sentence as an NP , VP , and so on , or null if that span is a non-constituent . For example , spans that begin with the might tend to be NPs , while spans that end with of might tend to be non-constituents . An independent classification approach is actually very viable for part-of-speech tagging ( Toutanova et al. , 2003 ) , but is problematic for parsing if nothing else , parsing comes with a structural requirement that the output be a well-formed , nested tree . Our parser uses a minimal PCFG backbone grammar to ensure a basic level of structural well-formedness , but relies mostly on features of surface spans to drive accuracy . Formally , our model is a CRF where the features factor over anchored rules of a small backbone grammar , as shown in Figure 1 . Some aspects of the parsing problem , such as the tree constraint , are clearly best captured by a PCFG . Others , such as heaviness effects , are naturally captured using surface information . The open question is whether surface features are adequate for key effects like subcategorization , which have deep definitions but regular surface reflexes ( e.g. the preposition selected by a verb will often linearly follow it ) . Empirically , the answer seems to be yes , and our system produces strong results , e.g . up to 90.5 F1 on English parsing . Our parser is also able to generalize well across languages with little tuning : it achieves state-of-the-art results on multilingual parsing , scoring higher than the best single-parser system from the SPMRL 2013 Shared Task on a range of languages , as well as on the competitions average F1 metric . One advantage of a system that relies on surface features and a simple grammar is that it is portable not only across languages but also across tasks to an extent . For example , Socher et al. ( 2013 ) demonstrates that sentiment analysis , which is usually approached as a flat classification task , can be viewed as tree-structured . In their work , they propagate real-valued vectors up a tree using neural tensor nets and see gains from their recursive approach . Our parser can be easily adapted to this task by replacing the X-bar grammar over treebank symbols with a grammar over the sentiment values to encode the output variables and then adding n-gram indicators to our feature set to capture the bulk of the lexical effects . When applied to this task , our system generally matches their accuracy overall and is able to outperform it on the overall sentence-level subtask . 2 Parsing Model In order to exploit non-independent surface features of the input , we use a discriminative formulation . Our model is a conditional random field ( Lafferty et al. , 2001 ) over trees , in the same vein as Finkel et al. ( 2008 ) and Petrov and Klein ( 2008a ) . Formally , we define the probability of a tree T conditioned on a sentence w as where the feature domains r range over the ( anchored ) rules used in the tree . An anchored rule r is the conjunction of an unanchored grammar rule rule ( r ) and the start , stop , and split indexes where that rule is anchored , which we refer to as span ( r ) . It is important to note that the richness of the backbone grammar is reflected in the structure of the trees T , while the features that condition directly on the input enter the equation through the anchoring span ( r ) . To optimize model parameters , we use the Adagrad algorithm of Duchi et al . ( 2010 ) with L2 regularization . We start with a simple X-bar grammar whose only symbols are NP , NP-bar , VP , and so on . Our base model has no surface features : formally , on each anchored rule r we have only an indicator of the ( unanchored ) rule identity , rule ( r ) . Because the X-bar grammar is so minimal , this grammar does not parse very accurately , scoring just 73 F1 on the standard English Penn Treebank task . In past work that has used tree-structured CRFs in this way , increased accuracy partially came from decorating trees T with additional annotations , giving a tree T0 over a more complex symbol set . These annotations introduce additional context into the model , usually capturing linguistic intuition about the factors that influence grammaticality . For instance , we might annotate every constituent X in the tree with its parent Y , giving a tree with symbols X [ Y ] . Finkel et al. ( 2008 ) used parent annotation , head tag annotation , and horizontal sibling annotation together in a single large grammar . In Petrov and Klein ( 2008a ) and Petrov and Klein ( 2008b ) , these annotations were latent ; they were inferred automatically during training . Hall and Klein ( 2012 ) employed both kinds of annotations , along with lexicalized head word annotation . All of these past CRF parsers do also exploit span features , as did the structured margin parser of Taskar et al . ( 2004 ) ; the current work primarily differs in shifting the work from the grammar to the surface features . The problem with rich annotations is that they increase the state space of the grammar substantially . For example , adding parent annotation can square the number of symbols , and each subsequent annotation causes a multiplicative increase in the size of the state space . Hall and Klein ( 2012 ) attempted to reduce this state space by factoring these annotations into individual components . Their approach changed the multiplicative penalty of annotation into an additive penalty , but even so their individual grammar projections are much larger than the base X-bar grammar . In this work , we want to see how much of the expressive capability of annotations can be captured using surface evidence , with little or no annotation of the underlying grammar . To that end , we avoid annotating our trees at all , opting instead to see how far simple surface features will go in achieving a high-performance parser . We will return to the question of annotation in Section 5 . 3 Surface Feature Framework To improve the performance of our X-bar grammar , we will add a number of surface feature templates derived only from the words in the sentence . We say that an indicator is a surface property if it can be extracted without reference to the parse tree . These features can be implemented without reference to structured linguistic notions like headedness ; however , we will argue that they still capture a wide range of linguistic phenomena in a data-driven way . Throughout this and the following section , we will draw on motivating examples from the English Penn Treebank , though similar examples could be equally argued for other languages . For performance on other languages , see Section 6 . Recall that our CRF factors over anchored rules r , where each r has identity rule ( r ) and anchoring span ( r ) . The X-bar grammar has only indicators of rule ( r ) , ignoring the anchoring . Let a surface property of r be an indicator function of span ( r ) and the sentence itself . For example , the first word in a constituent is a surface property , as of the rule VP VBD NP over the anchored span averted financial disaster with the shown indices . Span properties are generated as described throughout Section 4 ; they are then conjoined with the rule and just the parent nonterminal to give the features fired over the anchored production . is the word directly preceding the constituent . As illustrated in Figure 1 , the actual features of the model are obtained by conjoining surface properties with various abstractions of the rule identity . For rule abstractions , we use two templates : the parent of the rule and the identity of the rule . The surface features are somewhat more involved , and so we introduce them incrementally . One immediate computational and statistical issue arises from the sheer number of possible surface features . There are a great number of spans in a typical treebank ; extracting features for every possible combination of span and rule is prohibitive . One simple solution is to only extract features for rule/span pairs that are actually observed in gold annotated examples during training . Because these positive features correspond to observed constituents , they are far less numerous than the set of all possible features extracted from all spans . As far as we can tell , all past CRF parsers have used positive features only . However , negative featuresfeatures that are not observed in any treeare still powerful indicators of ( un ) grammaticality : if we have never seen a PRN that starts with has , or a span that begins with a quotation mark and ends with a close bracket , then we would like the model to be able to place negative weights on these features . Thus , we use a simple feature hashing scheme where positive features are indexed individually , while nega on Section 22 , for a number of incrementally growing feature sets . We show that each feature type presented in Section 4 adds benefit over the previous , and in combination they produce a reasonably good yet simple parser . tive features are bucketed together . During training there are no collisions between positive features , which generally receive positive weight , and negative features , which generally receive negative weight ; only negative features can collide . Early experiments indicated that using a number of negative buckets equal to the number of positive features was effective . 4 Features Our goal is to use surface features to replicate the functionality of other annotations , without increasing the state space of our grammar , meaning that the rules rule ( r ) remain simple , as does the state space used during inference . Before we present our main features , we briefly discuss the issue of feature sparsity . While lexical features are a powerful driver of our parser , firing features on rare words would allow it to overfit the training data quite heavily . To that end , for the purposes of computing our features , a word is represented by its longest suffix that occurs 100 or more times in the training data ( which will be the entire word , for common words ) . Table 1 shows the results of incrementally building up our feature set on the Penn Treebank development set . RULE specifies that we use only indicators on rule identity for binary production and nonterminal unaries . For this experiment and all others , we include a basic set of lexicon features , i.e. features on preterminal part-of-speech tags . A given preterminal unary at position i in the sentence includes features on the words ( suffixes ) at position i 1 , i , and i + 1 . Because the lexicon is especially sensitive to morphological effects , we also fire features on all prefixes and suf fixes of the current word up to length 5 , regardless of frequency . Subsequent lines in Table 1 indicate additional surface feature templates computed over the span , which are then conjoined with the rule identity as shown in Figure 1 to give additional features . In the rest of the section , we describe the features of this type that we use . Note that many of these features have been used before ( Taskar et al. , 2004 ; Finkel et al. , 2008 ; Petrov and Klein , 2008b ) ; our goal here is not to amass as many feature templates as possible , but rather to examine the extent to which a simple set of features can replace a complicated state space . 4.1 Basic Span Features We start with some of the most obvious properties available to us , namely , the identity of the first and last words of a span . Because heads of constituents are often at the beginning or the end of a span , these feature templates can ( noisily ) capture monolexical properties of heads without having to incur the inferential cost of lexicalized annotations . For example , in English , the syntactic head of a verb phrase is typically at the beginning of the span , while the head of a simple noun phrase is the last word . Other languages , like Korean or Japanese , are more consistently head final . Structural contexts like those captured by parent annotation ( Johnson , 1998 ) are more subtle . Parent annotation can capture , for instance , the difference in distribution in NPs that have S as a parent ( that is , subjects ) and NPs under VPs ( objects ) . We try to capture some of this same intuition by introducing a feature on the length of a span . For instance , VPs embedded in NPs tend to be short , usually as embedded gerund phrases . Because constituents in the treebank can be quite long , we bin our length features into 8 buckets , of disambiguating a PP attachment . Because impact is likely to take a PP , the monolexical indicator feature that conjoins impact with the appropriate rule will help us parse this example correctly . lengths 1 , 2 , 3 , 4 , 5 , 10 , 20 , and 21 words . Adding these simple features ( first word , last word , and lengths ) as span features of the Xbar grammar already gives us a substantial improvement over our baseline system , improving the parsers performance from 73.0 F1 to 85.0 F1 ( see Table 1 ) . 4.2 Span Context Features Of course , there is no reason why we should confine ourselves to just the words within the span : words outside the span also provide a rich source of context . As an example , consider disambiguating the POS tag of the word read in Figure 2 . A VP is most frequently preceded by a subject NP , whose rightmost word is often its head . Therefore , we fire features that ( separately ) look at the words immediately preceding and immediately following the span . 4.3 Split Point Features Another important source of features are the words at and around the split point of a binary rule application . Figure 3 shows an example of one in stance of this feature template . impact is a noun that is more likely to take a PP than other nouns , and so we expect this feature to have high weight and encourage the attachment ; this feature proves generally useful in resolving such cases of rightattachments to noun phrases , since the last word of the noun phrase is often the head . As another example , coordination can be represented by an indicator of the conjunction , which comes immediately after the split point . Finally , control structures with infinitival complements can be captured with a rule S NP VP with the word to at the split point . 4.4 Span Shape Features We add one final feature characterizing the span , which we call span shape . Figure 4 shows how this feature is computed . For each word in the span ,2 we indicate whether that word begins with a capital letter , lowercase letter , digit , or punctuation mark . If it begins with punctuation , we indicate the punctuation mark explicitly . Figure 4 shows that this is especially useful in characterizing constructions such as parentheticals and quoted expressions . Because this feature indicates capitalization , it can also capture properties of NP internal structure relevant to named entities , and its sensitivity to capitalization and punctuation makes it useful for recognizing appositive constructions . 5 Annotations We have built up a strong set of features by this point , but have not yet answered the question of whether or not grammar annotation is useful on top of them . In this section , we examine two of the most commonly used types of additional annotation , structural annotation , and lexical annotation . Table 2 : Results for the Penn Treebank development set , sentences of length < 40 , for different annotation schemes implemented on top of the Xbar grammar . Recall from Section 3 that every span feature is conjoined with indicators over rules and rule parents to produce features over anchored rule productions ; when we consider adding an annotation layer to the grammar , what that does is refine the rule indicators that are conjoined with every span feature . While this is a powerful way of refining features , we show that common successful annotation schemes provide at best modest benefit on top of the base parser . 5.1 Structural Annotation The most basic , well-understood kind of annotation on top of an X-bar grammar is structural annotation , which annotates each nonterminal with properties of its environment ( Johnson , 1998 ; Klein and Manning , 2003 ) . This includes vertical annotation ( parent , grandparent , etc . ) as well as horizontal annotation ( only partially Markovizing rules as opposed to using an X-bar grammar ) . Table 2 shows the performance of our feature set in grammars with several different levels of structural annotation .3 Klein and Manning ( 2003 ) find large gains ( 6 % absolute improvement , 20 % relative improvement ) going from v = 0 , h = 0 to v = 1 , h = 1 ; however , we do not find the same level of benefit . To the extent that our parser needs to make use of extra information in order to apply a rule correctly , simply inspecting the input to determine this information appears to be almost as effective as relying on information threaded through the parser . In Section 6 and Section 7 , we use v = 1 and h = 0 ; we find that v = 1 provides a small , reliable improvement across a range of languages and tasks , whereas other annotations are less clearly beneficial . 3We use v = 0 to indicate no annotation , diverging from the notation in Klein and Manning ( 2003 ) . Test < 40 Test all Berkeley 90.6 90.1 This work 89.9 89.2 5.2 Lexical Annotation Another commonly-used kind of structural annotation is lexicalization ( Eisner , 1996 ; Collins , 1997 ; Charniak , 1997 ) . By annotating grammar nonterminals with their headwords , the idea is to better model phenomena that depend heavily on the semantics of the words involved , such as coordination and PP attachment . Table 2 shows results from lexicalizing the Xbar grammar ; it provides meager improvements . One probable reason for this is that our parser already includes monolexical features that inspect the first and last words of each span , which captures the syntactic or the semantic head in many cases or can otherwise provide information about what the constituents type may be and how it is likely to combine . Lexicalization allows us to capture bilexical relationships along dependency arcs , but it has been previously shown that these add only marginal benefit to Collinss model anyway ( Gildea , 2001 ) . 5.3 English Evaluation Finally , Table 3 shows our final evaluation on Section 23 of the Penn Treebank . We use the v = 1 , h = 0 grammar . While we do not do as well as the Berkeley parser , we will see in Section 6 that our parser does a substantially better job of generalizing to other languages . 6 Other Languages Historically , many annotation schemes for parsers have required language-specific engineering : for example , lexicalized parsers require a set of head rules and manually-annotated grammars require detailed analysis of the treebank itself ( Klein and Manning , 2003 ) . A key strength of a parser that does not rely heavily on an annotated grammar is that it may be more portable to other languages . We show that this is indeed the case : on nine languages , our system is competitive with or better than the Berkeley parser , which is the best single the best single parser from ( Bjorkelund et al. , 2013 ) ; we only compare to this parser on the development set because neither the system nor test set values are publicly available . Berkeley-Tags is a version of the Berkeley parser run by the task organizers where tags are provided to the model , and is the best single parser submitted to the official task . In both cases , we match or outperform the baseline parsers in aggregate and on the majority of individual languages . parser4 for the majority of cases we consider . We evaluate on the constituency treebanks from the Statistical Parsing of Morphologically Rich Languages Shared Task ( Seddah et al . , 2013 ) . We compare to the Berkeley parser ( Petrov and Klein , 2007 ) as well as two variants . First , we use the Replaced system of Bjorkelund et al . ( 2013 ) ( Berkeley-Rep ) , which is their best single parser . The Replaced system modifies the Berkeley parser by replacing rare words with morphological descriptors of those words computed using language-specific modules , which have been hand-crafted for individual languages or are trained with additional annotation layers in the treebanks that we do not exploit . Unfortunately , Bjorkelund et al . ( 2013 ) only report results on the development set for the Berkeley-Rep model ; however , the task organizers also use a version of the Berkeley parser provided with parts of speech from high-quality POS taggers for each language ( Berkeley-Tags ) . These part-of-speech taggers often incorporate substantial knowledge of each languages morphology . Both BerkeleyRep and Berkeley-Tags make up for some shortcomings of the Berkeley parsers unknown word model , which is tuned to English . In Table 4 , we see that our performance is overall substantially higher than that of the Berkeley parser . On the development set , we outperform the Berkeley parser and match the performance of the Berkeley-Rep parser . On the test set , we outper form both the Berkeley parser and the BerkeleyTags parser on seven of nine languages , losing only on Arabic and French . These results suggest that the Berkeley parser may be heavily fit to English , particularly in its lexicon . However , even when language-specific unknown word handling is added to the parser , our model still outperforms the Berkeley parser overall , showing that our model generalizes even better across languages than a parser for which this is touted as a strength ( Petrov and Klein , 2007 ) . Our span features appear to work well on both head-initial and head-final languages ( see Basque and Korean in the table ) , and the fact that our parser performs well on such morphologicallyrich languages as Hungarian indicates that our suffix model is sufficient to capture most of the morphological effects relevant to parsing . Of course , a language that was heavily prefixing would likely require this feature to be modified . Likewise , our parser does not perform as well on Arabic and Hebrew . These closely related languages use templatic morphology , for which suffixing is not appropriate ; however , using additional surface features based on the output of a morphological analyzer did not lead to increased performance . Finally , our high performance on languages such as Polish and Swedish , whose training treebanks consist of 6578 and 5000 sentences , respectively , show that our feature-rich model performs robustly even on treebanks much smaller than the Penn Treebank .6 of our span features for this task . The presence of While under this kind of rule tells us that the sentiment of the constituent to the right dominates the sentiment to the left . 7 Sentiment Analysis Finally , because the system is , at its core , a classifier of spans , it can be used equally well for tasks that do not normally use parsing algorithms . One example is sentiment analysis . While approaches to sentiment analysis often simply classify the sentence monolithically , treating it as a bag of ngrams ( Pang et al. , 2002 ; Pang and Lee , 2005 ; Wang and Manning , 2012 ) , the recent dataset of Socher et al. ( 2013 ) imposes a layer of structure on the problem that we can exploit . They annotate every constituent in a number of training trees with an integer sentiment value from 1 ( very negative ) to 5 ( very positive ) , opening the door for models such as ours to learn how syntax can structurally affect sentiment .7 Figure 5 shows an example that requires some analysis of sentence structure to correctly understand . The first constituent conveys positive sentiment with never lethargic and the second conveys negative sentiment with hindered , but to determine the overall sentiment of the sentence , we need to exploit the fact that while signals a discounting of the information that follows it . The grammar rule 2 4 1 already encodes the notion of the sentiment of the right child being dominant , so when this is conjoined with our span feature on the first word ( While ) , we end up with a feature that captures this effect . Our features can also lexicalize on other discourse connectives such as but or however , which often occur at the split point between two spans . 7.1 Adapting to Sentiment Our parser is almost entirely unchanged from the parser that we used for syntactic analysis . Though the treebank grammar is substantially different , with the nonterminals consisting of five integers with very different semantics from syntactic nonterminals , we still find that parent annotation is effective and otherwise additional annotation layers are not useful . One structural difference between sentiment analysis and syntactic parsing lies in where the relevant information is present in a span . Syntax is often driven by heads of constituents , which tend to be located at the beginning or the end , whereas sentiment is more likely to depend on modifiers such as adjectives , which are typically present in the middle of spans . Therefore , we augment our existing model with standard sentiment analysis features that look at unigrams and bigrams in the span ( Wang and Manning , 2012 ) . Moreover , the Stanford Sentiment Treebank is unique in that each constituent was annotated in isolation , meaning that context never affects sentiment and that every word always has the same tag . We exploit this by adding an additional feature template similar to our span shape feature from Section 4.4 which uses the ( deterministic ) tag for each word as its descriptor . 7.2 Results We evaluated our model on the fine-grained sentiment analysis task presented in Socher et al. ( 2013 ) and compare to their released system . The task is to predict the root sentiment label of each parse tree ; however , because the data is annotated with sentiment at each span of each parse tree , we can also evaluate how well our model does at these intermediate computations . Following their experimental conditions , we filter the test set so that it only contains trees with non-neutral sentiment labels at the root . Table 5 shows that our model outperforms the model of Socher et al. ( 2013 ) both the published numbers and latest released versionon the task of root classification , even though the system was not explicitly designed for this task . Their model has high capacity to model complex interactions of words through a combinatory tensor , but it appears that our simpler , feature-driven model is just as effective at capturing the key effects of compositionality for sentiment analysis . on the Stanford Sentiment Treebank of Socher et al. ( 2013 ) . We compare against the printed numbers in Socher et al . ( 2013 ) as well as the performance of the corresponding release , namely the sentiment component in the latest version of the Stanford CoreNLP at the time of this writing . Our model handily outperforms the results from Socher et al . ( 2013 ) at root classification and edges out the performance of the latest version of the Stanford system . On all spans of the tree , our model has comparable accuracy to the others . 8 Conclusion To date , the most successful constituency parsers have largely been generative , and operate by refining the grammar either manually or automatically so that relevant information is available locally to each parsing decision . Our main contribution is to show that there is an alternative to such annotation schemes : namely , conditioning on the input and firing features based on anchored spans . We build up a small set of feature templates as part of a discriminative constituency parser and outperform the Berkeley parser on a wide range of languages . Moreover , we show that our parser is adaptable to other tree-structured tasks such as sentiment analysis ; we outperform the recent system of Socher et al. ( 2013 ) and obtain state of the art performance on their dataset . Our system is available as open-source at https://www.github.com/dlwh/epic . "}
  },
    {
    "id": "P14-1065",
    "result":     [
            {
        "value":         {
          "start": 242,
          "end": 260,
          "text": "all-subtree kernels",
          "labels": ["Method"]
        },
        "id": 883
      },
            {
        "value":         {
          "start": 318,
          "end": 344,
          "text": "Rhetorical Structure Theory",
          "labels": ["Method"]
        },
        "id": 942
      },
            {
        "value":         {
          "start": 1117,
          "end": 1136,
          "text": "log-linear framework",
          "labels": ["Method"]
        },
        "id": 885
      },
            {
        "value":         {
          "start": 2746,
          "end": 2772,
          "text": "Rhetorical Structure Theory",
          "labels": ["Method"]
        },
        "id": 942
      },
            {
        "value":         {
          "start": 2808,
          "end": 2810,
          "text": "RST",
          "labels": ["Method"]
        },
        "id": 892
      },
            {
        "value":         {
          "start": 4753,
          "end": 4757,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 4767,
          "end": 4771,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 5455,
          "end": 5457,
          "text": "PRO",
          "labels": ["Method"]
        },
        "id": 889
      },
            {
        "value":         {
          "start": 5490,
          "end": 5493,
          "text": "MIRA",
          "labels": ["Method"]
        },
        "id": 890
      },
            {
        "value":         {
          "start": 6278,
          "end": 6281,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 8185,
          "end": 8215,
          "text": "Discourse Representation Theory",
          "labels": ["Method"]
        },
        "id": 890
      },
            {
        "value":         {
          "start": 8619,
          "end": 8637,
          "text": "MetricsMATR dataset",
          "labels": ["Dataset"]
        },
        "id": 891
      },
            {
        "value":         {
          "start": 8725,
          "end": 8727,
          "text": "RST",
          "labels": ["Method"]
        },
        "id": 892
      },
            {
        "value":         {
          "start": 9278,
          "end": 9281,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 9287,
          "end": 9289,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 9356,
          "end": 9367,
          "text": "MTC4 dataset",
          "labels": ["Dataset"]
        },
        "id": 892
      },
            {
        "value":         {
          "start": 10149,
          "end": 10166,
          "text": "WMT12 test dataset",
          "labels": ["Dataset"]
        },
        "id": 893
      },
            {
        "value":         {
          "start": 10186,
          "end": 10187,
          "text": "DT",
          "labels": ["Method"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 11363,
          "end": 11389,
          "text": "Rhetorical Structure Theory",
          "labels": ["Method"]
        },
        "id": 942
      },
            {
        "value":         {
          "start": 11807,
          "end": 11827,
          "text": "maximum entropy model",
          "labels": ["Method"]
        },
        "id": 895
      },
            {
        "value":         {
          "start": 11894,
          "end": 11903,
          "text": "F1 - score",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 11979,
          "end": 12010,
          "text": "dynamic Conditional Random Field",
          "labels": ["Method"]
        },
        "id": 896
      },
            {
        "value":         {
          "start": 12197,
          "end": 12246,
          "text": "probabilistic CKY-like bottom-up parsing algorithm",
          "labels": ["Method"]
        },
        "id": 897
      },
            {
        "value":         {
          "start": 12396,
          "end": 12405,
          "text": "F1 - score",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 12681,
          "end": 12698,
          "text": "Tree Edit Distance",
          "labels": ["Method"]
        },
        "id": 898
      },
            {
        "value":         {
          "start": 12719,
          "end": 12730,
          "text": "Tree Kernels",
          "labels": ["Method"]
        },
        "id": 899
      },
            {
        "value":         {
          "start": 12793,
          "end": 12812,
          "text": "Tree kernels ( TKs )",
          "labels": ["Method"]
        },
        "id": 900
      },
            {
        "value":         {
          "start": 12926,
          "end": 12929,
          "text": "SVMs",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 12966,
          "end": 12979,
          "text": "convolution TK",
          "labels": ["Method"]
        },
        "id": 902
      },
            {
        "value":         {
          "start": 13308,
          "end": 13309,
          "text": "TK",
          "labels": ["Method"]
        },
        "id": 904
      },
            {
        "value":         {
          "start": 13432,
          "end": 13433,
          "text": "TK",
          "labels": ["Method"]
        },
        "id": 904
      },
            {
        "value":         {
          "start": 13577,
          "end": 13579,
          "text": "TKs",
          "labels": ["Method"]
        },
        "id": 904
      },
            {
        "value":         {
          "start": 15055,
          "end": 15059,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 15069,
          "end": 15073,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 16625,
          "end": 16633,
          "text": "SPEDE07PP",
          "labels": ["Metric"]
        },
        "id": 940
      },
            {
        "value":         {
          "start": 16637,
          "end": 16641,
          "text": "AMBER",
          "labels": ["Metric"]
        },
        "id": 906
      },
            {
        "value":         {
          "start": 16645,
          "end": 16650,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 16654,
          "end": 16662,
          "text": "TERRORCAT",
          "labels": ["Metric"]
        },
        "id": 907
      },
            {
        "value":         {
          "start": 16666,
          "end": 16673,
          "text": "SIMPBLEU",
          "labels": ["Metric"]
        },
        "id": 908
      },
            {
        "value":         {
          "start": 16677,
          "end": 16686,
          "text": "XENERRCATS",
          "labels": ["Metric"]
        },
        "id": 909
      },
            {
        "value":         {
          "start": 16690,
          "end": 16700,
          "text": "WORDBLOCKEC",
          "labels": ["Metric"]
        },
        "id": 910
      },
            {
        "value":         {
          "start": 16704,
          "end": 16715,
          "text": "BLOCKERRCATS",
          "labels": ["Metric"]
        },
        "id": 911
      },
            {
        "value":         {
          "start": 16723,
          "end": 16726,
          "text": "POSF",
          "labels": ["Metric"]
        },
        "id": 912
      },
            {
        "value":         {
          "start": 16795,
          "end": 16808,
          "text": "ASIYA toolkit4",
          "labels": ["Tool"]
        },
        "id": 913
      },
            {
        "value":         {
          "start": 16928,
          "end": 16932,
          "text": "ASIYA",
          "labels": ["Tool"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 17232,
          "end": 17241,
          "text": "ASIYAs ULC",
          "labels": ["Metric"]
        },
        "id": 915
      },
            {
        "value":         {
          "start": 17361,
          "end": 17365,
          "text": "WMT08",
          "labels": ["Dataset"]
        },
        "id": 916
      },
            {
        "value":         {
          "start": 17371,
          "end": 17375,
          "text": "WMT09",
          "labels": ["Dataset"]
        },
        "id": 917
      },
            {
        "value":         {
          "start": 17475,
          "end": 17477,
          "text": "ULC",
          "labels": ["Metric"]
        },
        "id": 918
      },
            {
        "value":         {
          "start": 17498,
          "end": 17500,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 17506,
          "end": 17511,
          "text": "Meteor",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 17605,
          "end": 17610,
          "text": "TERp-A",
          "labels": ["Metric"]
        },
        "id": 919
      },
            {
        "value":         {
          "start": 17616,
          "end": 17624,
          "text": "METEOR-pa",
          "labels": ["Metric"]
        },
        "id": 920
      },
            {
        "value":         {
          "start": 17684,
          "end": 17692,
          "text": "Asiya0809",
          "labels": ["Metric"]
        },
        "id": 921
      },
            {
        "value":         {
          "start": 17876,
          "end": 17879,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 17911,
          "end": 17914,
          "text": "NIST",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 17940,
          "end": 17942,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 17972,
          "end": 17978,
          "text": "ROUGE-W",
          "labels": ["Metric"]
        },
        "id": 923
      },
            {
        "value":         {
          "start": 18007,
          "end": 18012,
          "text": "METEOR",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 18056,
          "end": 18080,
          "text": "METEOR-ex ( exact match )",
          "labels": ["Metric"]
        },
        "id": 924
      },
            {
        "value":         {
          "start": 18084,
          "end": 18107,
          "text": "METEOR-st ( + stemming )",
          "labels": ["Metric"]
        },
        "id": 925
      },
            {
        "value":         {
          "start": 18113,
          "end": 18136,
          "text": "METEOR-sy ( + synonyms )",
          "labels": ["Metric"]
        },
        "id": 926
      },
            {
        "value":         {
          "start": 18225,
          "end": 18236,
          "text": "Asiya - 0809",
          "labels": ["Metric"]
        },
        "id": 927
      },
            {
        "value":         {
          "start": 18253,
          "end": 18261,
          "text": "Asiya-ALL",
          "labels": ["Metric"]
        },
        "id": 929
      },
            {
        "value":         {
          "start": 18328,
          "end": 18336,
          "text": "Asiya-ALL",
          "labels": ["Metric"]
        },
        "id": 929
      },
            {
        "value":         {
          "start": 18635,
          "end": 18639,
          "text": "ASIYA",
          "labels": ["Tool"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 18874,
          "end": 18886,
          "text": "WMT campaigns",
          "labels": ["Dataset"]
        },
        "id": 929
      },
            {
        "value":         {
          "start": 19482,
          "end": 19493,
          "text": "Kendalls Tau",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 19730,
          "end": 19739,
          "text": "WMT12 data",
          "labels": ["Dataset"]
        },
        "id": 931
      },
            {
        "value":         {
          "start": 19756,
          "end": 19777,
          "text": "learning-to-rank model",
          "labels": ["Method"]
        },
        "id": 932
      },
            {
        "value":         {
          "start": 20188,
          "end": 20207,
          "text": "log-linear SMT model",
          "labels": ["Method"]
        },
        "id": 933
      },
            {
        "value":         {
          "start": 20249,
          "end": 20263,
          "text": "Maximum Entropy",
          "labels": ["Method"]
        },
        "id": 934
      },
            {
        "value":         {
          "start": 20477,
          "end": 20497,
          "text": "discourse information",
          "labels": ["Method"]
        },
        "id": 934
      },
            {
        "value":         {
          "start": 20729,
          "end": 20730,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 20736,
          "end": 20741,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21044,
          "end": 21064,
          "text": "Spearmans correlation",
          "labels": ["Metric"]
        },
        "id": 937
      },
            {
        "value":         {
          "start": 21165,
          "end": 21176,
          "text": "Kendalls Tau",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 21291,
          "end": 21292,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21298,
          "end": 21303,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21775,
          "end": 21776,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21787,
          "end": 21792,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21818,
          "end": 21819,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 21825,
          "end": 21830,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22035,
          "end": 22036,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22042,
          "end": 22047,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22106,
          "end": 22107,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22111,
          "end": 22116,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22201,
          "end": 22205,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22258,
          "end": 22267,
          "text": "TERRORCATs",
          "labels": ["Metric"]
        },
        "id": 938
      },
            {
        "value":         {
          "start": 22397,
          "end": 22401,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22421,
          "end": 22422,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22517,
          "end": 22520,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22526,
          "end": 22528,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22583,
          "end": 22584,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 22805,
          "end": 22806,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23179,
          "end": 23180,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23277,
          "end": 23282,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23305,
          "end": 23306,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23341,
          "end": 23347,
          "text": "unigram",
          "labels": ["Method"]
        },
        "id": 1401
      },
            {
        "value":         {
          "start": 23428,
          "end": 23433,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23601,
          "end": 23606,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23688,
          "end": 23693,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23734,
          "end": 23735,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23875,
          "end": 23880,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 23990,
          "end": 23991,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24326,
          "end": 24330,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24371,
          "end": 24372,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24412,
          "end": 24423,
          "text": "Kendalls Tau",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 24653,
          "end": 24654,
          "text": "DT",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 24707,
          "end": 24722,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24727,
          "end": 24731,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24735,
          "end": 24746,
          "text": "Kendalls Tau",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 24786,
          "end": 24787,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 24890,
          "end": 24901,
          "text": "Kendalls Tau",
          "labels": ["Metric"]
        },
        "id": 939
      },
            {
        "value":         {
          "start": 25127,
          "end": 25128,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25240,
          "end": 25245,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25262,
          "end": 25263,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25283,
          "end": 25285,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25439,
          "end": 25444,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25513,
          "end": 25518,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 25538,
          "end": 25540,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26012,
          "end": 26027,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26049,
          "end": 26053,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26075,
          "end": 26079,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26098,
          "end": 26102,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26110,
          "end": 26125,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26130,
          "end": 26134,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26384,
          "end": 26399,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26841,
          "end": 26846,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 26990,
          "end": 26991,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27246,
          "end": 27247,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27253,
          "end": 27258,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27406,
          "end": 27407,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27461,
          "end": 27466,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27659,
          "end": 27663,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27667,
          "end": 27675,
          "text": "SPEDE07PP",
          "labels": ["Metric"]
        },
        "id": 940
      },
            {
        "value":         {
          "start": 27690,
          "end": 27692,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27717,
          "end": 27718,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27729,
          "end": 27731,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27777,
          "end": 27782,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 27957,
          "end": 27961,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28045,
          "end": 28049,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28197,
          "end": 28201,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28245,
          "end": 28249,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28275,
          "end": 28290,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28316,
          "end": 28320,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28363,
          "end": 28367,
          "text": "WMT11",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28373,
          "end": 28377,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28549,
          "end": 28552,
          "text": "NIST",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28556,
          "end": 28560,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 28564,
          "end": 28566,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28574,
          "end": 28577,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 28592,
          "end": 28596,
          "text": "ASIYA",
          "labels": ["Tool"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28619,
          "end": 28623,
          "text": "ASIYA",
          "labels": ["Tool"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28890,
          "end": 28891,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 28897,
          "end": 28902,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29079,
          "end": 29080,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29086,
          "end": 29091,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29120,
          "end": 29123,
          "text": "NIST",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29127,
          "end": 29131,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 29135,
          "end": 29137,
          "text": "TER",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29145,
          "end": 29148,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 29162,
          "end": 29163,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29186,
          "end": 29188,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29234,
          "end": 29239,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29321,
          "end": 29325,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29327,
          "end": 29342,
          "text": "cross-validation",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29385,
          "end": 29389,
          "text": "WMT12",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29435,
          "end": 29439,
          "text": "WMT11",
          "labels": ["Dataset"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29506,
          "end": 29507,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29576,
          "end": 29581,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29615,
          "end": 29616,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29640,
          "end": 29642,
          "text": "Tau",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29716,
          "end": 29717,
          "text": "DR",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 29723,
          "end": 29728,
          "text": "DR-LEX",
          "labels": ["Metric"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 30301,
          "end": 30318,
          "text": "all-subtree kernel",
          "labels": ["Method"]
        },
        "id": 941
      },
            {
        "value":         {
          "start": 30395,
          "end": 30421,
          "text": "Rhetorical Structure Theory",
          "labels": ["Method"]
        },
        "id": 942
      },
            {
        "value":         {
          "start": 30467,
          "end": 30486,
          "text": "WMT12 and WMT11 data",
          "labels": ["Dataset"]
        },
        "id": 942
      }
    ],
    "data": {"text": "Using Discourse Structure Improves Machine Translation Evaluation Abstract We present experiments in using discourse structure for improving machine translation evaluation . We first design two discourse-aware similarity measures , which use all-subtree kernels to compare discourse parse trees in accordance with the Rhetorical Structure Theory . Then , we show that these measures can help improve a number of existing machine translation evaluation metrics both at the segment - and at the system-level . Rather than proposing a single new metric , we show that discourse information is complementary to the state-of-the-art evaluation metrics , and thus should be taken into account in the development of future richer evaluation metrics . 1 Introduction From its foundations , Statistical Machine Translation ( SMT ) had two defining characteristics : first , translation was modeled as a generative process at the sentence-level . Second , it was purely statistical over words or word sequences and made little to no use of linguistic information . Although modern SMT systems have switched to a discriminative log-linear framework , which allows for additional sources as features , it is generally hard to incorporate dependencies beyond a small window of adjacent words , thus making it difficult to use linguistically-rich models . Recently , there have been two promising research directions for improving SMT and its evaluation : ( a ) by using more structured linguistic information , such as syntax ( Galley et al. , 2004 ; Quirk et al. , 2005 ) , hierarchical structures ( Chiang , 2005 ) , and semantic roles ( Wu and Fung , 2009 ; Lo et al. , 2012 ) , and ( b ) by going beyond the sentence-level , e.g. , translating at the document level ( Hardmeier et al. , 2012 ) . Going beyond the sentence-level is important since sentences rarely stand on their own in a well-written text . Rather , each sentence follows smoothly from the ones before it , and leads into the ones that come afterwards . The logical relationship between sentences carries important information that allows the text to express a meaning as a whole beyond the sum of its separate parts . Note that sentences can be made of several clauses , which in turn can be interrelated through the same logical relations . Thus , in a coherent text , discourse units ( sentences or clauses ) are logically connected : the meaning of a unit relates to that of the previous and the following units . Discourse analysis seeks to uncover this coherence structure underneath the text . Several formal theories of discourse have been proposed to describe the coherence structure ( Mann and Thompson , 1988 ; Asher and Lascarides , 2003 ; Webber , 2004 ) . For example , the Rhetorical Structure Theory ( Mann and Thompson , 1988 ) , or RST , represents text by labeled hierarchical structures called Discourse Trees ( DTs ) , which can incorporate several layers of other linguistic information , e.g . , syntax , predicate-argument structure , etc . . Modeling discourse brings together the above research directions ( a ) and ( b ) , which makes it an attractive goal for MT. This is demonstrated by the establishment of a recent workshop dedicated to Discourse in Machine Translation ( Webber et al. , 2013 ) , collocated with the 2013 annual meeting of the Association of Computational Linguistics . The area of discourse analysis for SMT is still nascent and , to the best of our knowledge , no previous research has attempted to use rhetorical structure for SMT or machine translation evaluation . One possible reason could be the unavailability of accurate discourse parsers . However , this situation is likely to change given the most recent advances in automatic discourse analysis ( Joty et al. , 2012 ; Joty et al. , 2013 ) . We believe that the semantic and pragmatic information captured in the form of DTs ( i ) can help develop discourse-aware SMT systems that produce coherent translations , and ( ii ) can yield better MT evaluation metrics . While in this work we focus on the latter , we think that the former is also within reach , and that SMT systems would benefit from preserving the coherence relations in the source language when generating target-language translations . In this paper , rather than proposing yet another MT evaluation metric , we show that discourse information is complementary to many existing evaluation metrics , and thus should not be ignored . We first design two discourse-aware similarity measures , which use DTs generated by a publiclyavailable discourse parser ( Joty et al . , 2012 ) ; then , we show that they can help improve a number of MT evaluation metrics at the segment - and at the system-level in the context of the WMT11 and the WMT12 metrics shared tasks ( Callison-Burch et al . , 2011 ; Callison-Burch et al . , 2012 ) . These metrics tasks are based on sentence-level evaluation , which arguably can limit the benefits of using global discourse properties . Fortunately , several sentences are long and complex enough to present rich discourse structures connecting their basic clauses . Thus , although limited , this setting is able to demonstrate the potential of discourselevel information for MT evaluation . Furthermore , sentence-level scoring ( i ) is compatible with most translation systems , which work on a sentence-bysentence basis , ( ii ) could be beneficial to modern MT tuning mechanisms such as PRO ( Hopkins and May , 2011 ) and MIRA ( Watanabe et al . , 2007 ; Chiang et al . , 2008 ) , which also work at the sentence-level , and ( iii ) could be used for reranking n-best lists of translation hypotheses . 2 Related Work Addressing discourse-level phenomena in machine translation is relatively new as a research direction . Some recent work has looked at anaphora resolution ( Hardmeier and Federico , 2010 ) and discourse connectives ( Cartoni et al. , 2011 ; Meyer , 2011 ) , to mention two examples .1 However , so far the attempts to incorporate discourse-related knowledge in MT have been only moderately successful , at best . We refer the reader to ( Hardmeier , 2012 ) for an in-depth overview of discourse-related research for MT. A common argument , is that current automatic evaluation metrics such as BLEU are inadequate to capture discourse-related aspects of translation quality ( Hardmeier and Federico , 2010 ; Meyer et al . , 2012 ) . Thus , there is consensus that discourseinformed MT evaluation metrics are needed in order to advance research in this direction . Here we suggest some simple ways to create such metrics , and we also show that they yield better correlation with human judgments . The field of automatic evaluation metrics for MT is very active , and new metrics are continuously being proposed , especially in the context of the evaluation campaigns that run as part of the Workshops on Statistical Machine Translation ( WMT 2008-2012 ) , and NIST Metrics for Machine Translation Challenge ( MetricsMATR ) , among others . For example , at WMT12 , 12 metrics were compared ( Callison-Burch et al. , 2012 ) , most of them new . There have been several attempts to incorporate syntactic and semantic linguistic knowledge into MT evaluation . For instance , at the syntactic level , we find metrics that measure the structural similarity between shallow syntactic sequences ( Gimenez and M`arquez , 2007 ; Popovic and Ney , 2007 ) or between constituency trees ( Liu and Gildea , 2005 ) . In the semantic case , there are metrics that exploit the similarity over named entities and predicate-argument structures ( Gimenez and M`arquez , 2007 ; Lo et al. , 2012 ) . In this work , instead of proposing a new metric , we focus on enriching current MT evaluation metrics with discourse information . Our experiments show that many existing metrics can benefit from additional knowledge about discourse structure . In comparison to the syntactic and semantic extensions of MT metrics , there have been very few attempts to incorporate discourse information so far . One example are the semantics-aware metrics of Gimenez and M ` arquez ( 2009 ) and Comelles et al . ( 2010 ) , which use the Discourse Representation Theory ( Kamp and Reyle , 1993 ) and treebased discourse representation structures ( DRS ) produced by a semantic parser . They calculate the similarity between the MT output and references based on DRS subtree matching , as defined in ( Liu and Gildea , 2005 ) , DRS lexical overlap , and DRS morpho-syntactic overlap . However , they could not improve correlation with human judgments , as evaluated on the MetricsMATR dataset . Compared to the previous work , ( i ) we use a different discourse representation ( RST ) , ( ii ) we compare discourse parses using all-subtree kernels ( Collins and Duffy , 2001 ) , ( iii ) we evaluate on much larger datasets , for several language pairs and for multiple metrics , and ( iv ) we do demonstrate better correlation with human judgments . Wong and Kit ( 2012 ) recently proposed an extension of MT metrics with a measure of document-level lexical cohesion ( Halliday and Hasan , 1976 ) . Lexical cohesion is achieved using word repetitions and semantically similar words such as synonyms , hypernyms , and hyponyms . For BLEU and TER , they observed improved correlation with human judgments on the MTC4 dataset when linearly interpolating these metrics with their lexical cohesion score . Unlike their work , which measures lexical cohesion at the document-level , here we are concerned with coherence ( rhetorical ) structure , primarily at the sentence-level . 3 Our Discourse-Based Measures Our working hypothesis is that the similarity between the discourse structures of an automatic and of a reference translation provides additional information that can be valuable for evaluating MT systems . In particular , we believe that good translations should tend to preserve discourse relations . As an example , consider the three discourse trees ( DTs ) shown in Figure 1 : ( a ) for a reference ( human ) translation , and ( b ) and ( c ) for translations of two different systems on the WMT12 test dataset . The leaves of a DT correspond to contiguous atomic text spans , called Elementary Discourse Units or EDUs ( three in Figure 1a ) . Adjacent spans are connected by certain coherence relations ( e.g. , Elaboration , Attribution ) , forming larger discourse units , which in turn are also subject to this relation linking . Discourse units linked by a relation are further distinguished based on their relative importance in the text : nuclei are the core parts of the relation while satellites are supportive ones . Note that the nuclearity and relation labels in the reference translation are also realized in the system translation in ( b ) , but not in ( c ) , which makes ( b ) a better translation compared to ( c ) , according to our hypothesis . We argue that existing metrics that only use lexical and syntactic information can not distinguish well between ( b ) and ( c ) . In order to develop a discourse-aware evaluation metric , we first generate discourse trees for the reference and the system-translated sentences using a discourse parser , and then we measure the similarity between the two discourse trees . We describe these two steps below . 3.1 Generating Discourse Trees In Rhetorical Structure Theory , discourse analysis involves two subtasks : ( i ) discourse segmentation , or breaking the text into a sequence of EDUs , and ( ii ) discourse parsing , or the task of linking the units ( EDUs and larger discourse units ) into labeled discourse trees . Recently , Joty et al. ( 2012 ) proposed discriminative models for both discourse segmentation and discourse parsing at the sentence level . The segmenter uses a maximum entropy model that achieves state-of-the-art accuracy on this task , having an F1 - score of 90.5 % , while human agreement is 98.3 % . The discourse parser uses a dynamic Conditional Random Field ( Sutton et al . , 2007 ) as a parsing model in order to infer the probability of all possible discourse tree constituents . The inferred ( posterior ) probabilities are then used in a probabilistic CKY-like bottom-up parsing algorithm to find the most likely DT . Using the standard set of 18 coarse-grained relations defined in ( Carlson and Marcu , 2001 ) , the parser achieved an F1 - score of 79.8 % , which is very close to the human agreement of 83 % . These high scores allowed us to develop successful discourse similarity metrics .2 3.2 Measuring Similarity A number of metrics have been proposed to measure the similarity between two labeled trees , e.g . , Tree Edit Distance ( Tai , 1979 ) and Tree Kernels ( Collins and Duffy , 2001 ; Moschitti and Basili , 2006 ) . Tree kernels ( TKs ) provide an effective way to integrate arbitrary tree structures in kernelbased machine learning algorithms like SVMs . In the present work , we use the convolution TK defined in ( Collins and Duffy , 2001 ) , which efficiently calculates the number of common subtrees in two trees . Note that this kernel was originally designed for syntactic parsing , where the subtrees are subject to the constraint that their nodes are taken with either all or none of the children . This constraint of the TK imposes some limitations on the type of substructures that can be compared . One way to cope with the limitations of the TK is to change the representation of the trees to a form that is suitable to capture the relevant information for our task . We experiment with TKs applied to two different representations of the discourse tree : non-lexicalized ( DR ) , and lexicalized ( DR-LEX ) . In Figure 2 we show the two representations for the subtree that spans the text : suggest the ECB should be the lender of last resort , which is highlighted in Figure 1b . As shown in Figure 2a , DR does not include any lexical item , and therefore measures the similarity between two translations in terms of their discourse structures only . On the contrary , DR-LEX includes the lexical items to account for lexical matching ; moreover , it separates the structure ( the skeleton ) of the tree from its labels , i.e. the nuclearity and the relations , in order to allow the tree kernel to give partial credit to subtrees that differ in labels but match in their skeletons . More specifically , it uses the tags SPAN and EDU to build the skeleton of the tree , and considers the nuclearity and/or the relation labels as properties , added as children , of these tags . For example , a SPAN has two properties ( its nuclearity and its relation ) , and an EDU has one property ( its nuclearity ) . The words of an EDU are placed under the predefined children NGRAM . In order to allow the tree kernel to find subtree matches at the word level , we include an additional layer of dummy leaves as was done in ( Moschitti et al. , 2007 ) ; not shown in Figure 2 , for simplicity . 4 Experimental Setup In our experiments , we used the data available for the WMT12 and the WMT11 metrics shared tasks for translations into English . This included the output from the systems that participated in the WMT12 and the WMT11 MT evaluation campaigns , both consisting of 3,003 sentences , for four different language pairs : Czech-English ( CSEN ) , French-English ( FR-EN ) , German-English ( DE-EN ) , and Spanish-English ( ES-EN ) ; as well as a dataset with the English references . We measured the correlation of the metrics with the human judgments provided by the organizers . The judgments represent rankings of the output of five systems chosen at random , for a particular sentence , also chosen at random . Note that each judgment effectively constitutes 10 pairwise system rankings . The overall coverage , i.e. the number of unique sentences that were evaluated , was only a fraction of the total ; the total number of judgments , along with other information of the datasets are shown in Table 1 . 4.1 MT Evaluation Metrics In this study , we evaluate to what extent existing evaluation metrics can benefit from additional discourse information . To do so , we contrast different MT evaluation metrics with and without discourse information . The evaluation metrics we used are described below . ( ranks ) , unique sentences ( sents ) , and different judges ( judges ) for the different language pairs , for the human evaluation of the WMT12 and WMT11 shared tasks . Metrics from WMT12 . We used the publicly available scores for all metrics that participated in the WMT12 metrics task ( Callison-Burch et al . , 2012 ) : SPEDE07PP , AMBER , METEOR , TERRORCAT , SIMPBLEU , XENERRCATS , WORDBLOCKEC , BLOCKERRCATS , and POSF . Metrics from ASIYA . We used the freely available version of the ASIYA toolkit4 in order to extend the set of evaluation measures contrasted in this study beyond those from the WMT12 metrics task . ASIYA ( Gimenez and M ` arquez , 2010a ) is a suite for MT evaluation that provides a large set of metrics that use different levels of linguistic information . For reproducibility , below we explain the individual metrics with the exact names required by the toolkit to calculate them . First , we used ASIYAs ULC ( Gimenez and M ` arquez , 2010b ) , which was the best performing metric at the system and the segment levels at the WMT08 and WMT09 metrics tasks . This is a uniform linear combination of 12 individual metrics . From the original ULC , we only replaced TER and Meteor individual metrics by newer versions taking into account synonymy lookup and paraphrasing : TERp-A and METEOR-pa in ASIYAs terminology . We will call this combined metric Asiya0809 in our experiments . To complement the set of individual metrics that participated at the WMT12 metrics task , we also computed the scores of other commonlyused evaluation metrics : BLEU ( Papineni et al . , 2002 ) , NIST ( Doddington , 2002 ) , TER ( Snover et al . , 2006 ) , ROUGE-W ( Lin , 2004 ) , and three METEOR variants ( Denkowski and Lavie , 2011 ) : METEOR-ex ( exact match ) , METEOR-st ( + stemming ) and METEOR-sy ( + synonyms ) . The uniform linear combination of the previous 7 individual metrics plus the 12 from Asiya - 0809 is reported as Asiya-ALL in the experimental section . The individual metrics combined in Asiya-ALL can be naturally categorized according to the type of linguistic information they use to compute the quality scores . We grouped them in the following four families and calculated the uniform linear combination of the metrics in each group : All uniform linear combinations are calculated outside ASIYA . In order to make the scores of the different metrics comparable , we performed a minmax normalization , for each metric , and for each language pair combination . 4.2 Human Judgements and Learning The human-annotated data from the WMT campaigns encompasses series of rankings on the output of different MT systems for every source sentence . Annotators rank the output of five systems according to perceived translation quality . The organizers relied on a random selection of systems , and a large number of comparisons between pairs of them , to make comparisons across systems feasible ( Callison-Burch et al. , 2012 ) . As a result , for each source sentence , only relative rankings were available . As in the WMT12 experimental setup , we use these rankings to calculate correlation with human judgments at the sentencelevel , i.e . Kendalls Tau ; see ( Callison-Burch et al . , 2012 ) for details . For the experiments reported in Section 5.4 , we used pairwise rankings to discriminatively learn the weights of the linear combinations of individual metrics . In order to use the WMT12 data for training a learning-to-rank model , we transformed the five-way relative rankings into ten pairwise comparisons . For instance , if a judge ranked the output of systems A , B , C , D , E as A > B > C > D > E , this would entail that A > B , A > C , A > D and A > E , etc. . To determine the relative weights for the tuned combinations , we followed a similar approach to the one used by PRO to tune the relative weights of the components of a log-linear SMT model ( Hopkins and May , 2011 ) , also using Maximum Entropy as the base learning algorithm . Unlike PRO , ( i ) we use human judgments , not automatic scores , and ( ii ) we train on all pairs , not on a subsample . 5 Experimental Results In this section , we explore how discourse information can be used to improve machine translation evaluation metrics . Below we present the evaluation results at the system - and segment-level , using our two basic metrics on discourse trees ( Section 3.1 ) , which are referred to as DR and DR-LEX . 5.1 Evaluation In our experiments , we only consider translation into English , and use the data described in Table 1 . For evaluation , we follow the setup of the metrics task of WMT12 ( Callison-Burch et al . , 2012 ) : at the system-level , we use the official script from WMT12 to calculate the Spearmans correlation , where higher absolute values indicate better metrics performance ; at the segment-level , we use Kendalls Tau for measuring correlation , where negative values are worse than positive ones . In our experiments , we combine DR and DR-LEX to other metrics in two different ways : using uniform linear interpolation ( at system - and segment-level ) , and using a tuned linear interpolation for the segment-level . We only present the average results over all four language pairs . For simplicity , in our tables we show results divided into evaluation groups : For each metric in groups II , III and IV , we present the results for the original metric as well for the linear interpolation of that metric with DR and with DR-LEX . The combinations with DR and DR-LEX that improve over the original metrics are shown in bold , and those that degrade are in italic . Furthermore , we also present overall results for : ( i ) the average score over all metrics , excluding DR and DR-LEX , and ( ii ) the differences in the correlations for the DR / DR-LEX-combined and the original metrics . 7 We have fixed a bug in the scoring tool from WMT12 , which was making all scores positive . This made TERRORCATs score negative , as we present it in Table 3 . 5.2 System-level Results Table 2 shows the system-level experimental results for WMT12 . We can see that DR is already competitive by itself : on average , it has a correlation of .807 , very close to BLEU and TER scores ( .810 and .812 , respectively ) . Moreover , DR yields improvements when combined with 15 of the 19 metrics ; worsening only four of the metrics . Overall , we observe an average improvement of +.024 , in the correlation with the human judgments . This suggests that DR contains information that is complementary to that used by the other metrics . Note that this is true both for the individual metrics from groups II and III , as well as for the metric combinations in group IV . Combinations in the last group involve several metrics that already use linguistic information at different levels and are hard to improve over ; yet , adding DR does improve , which shows that it has some complementary information to offer . As expected , DR-LEX performs better than DR since it is lexicalized ( at the unigram level ) , and also gives partial credit to correct structures . Individually , DR-LEX outperforms most of the metrics from group II , and ranks as the second best metric in that group . Furthermore , when combined with individual metrics in group II , DR-LEX is able to improve consistently over each one of them . Note that , even though DR-LEX has better individual performance than DR , it does not yield improvements when combined with most of the metrics in group IV . However , over all metrics and all language pairs , DR-LEX is able to obtain an average improvement in correlation of + .035 , which is remarkably higher than that of DR . Thus , we can conclude that at the system-level , adding discourse information to a metric , even using the simplest of the combination schemes , is a good idea for most of the metrics , and can help to significantly improve the correlation with human judgments . 5.3 Segment-level Results: Non-tuned Table 3 shows the results for WMT12 at the segment-level . We can see that DR performs badly , with a high negative Kendalls Tau of - .433 . This should not be surprising : ( a ) the discourse tree structure alone does not contain enough information for a good evaluation at the segment-level , and ( b ) this metric is more sensitive to the quality of the DT , which can be wrong or void . level : tuning with cross-validation on WMT12 . Kendalls Tau with human judgments . Additionally , DR is more likely to produce a high number of ties , which is harshly penalized by WMT12s definition of Kendalls Tau . Conversely , ties and incomplete discourse analysis were not a problem at the system-level , where evidence from all 3,003 test sentences is aggregated , and allows to rank systems more precisely . Due to the low score of DR as an individual metric , it fails to yield improvements when uniformly combined with other metrics . Again , DR-LEX is better than DR ; with a positive Tau of + .133 , yet as an individual metric , it ranks poorly compared to other metrics in group II . However , when linearly combined with other metrics , DR-LEX outperforms 14 of the 19 metrics in Table 3 . Across all metrics , DR-LEX yields an average Tau improvement of + .026 , i.e . from .165 to .190 . This is a large improvement , taking into account that the combinations are just uniform linear combinations . In subsection 5.4 , we present the results of tuning the linear combination in a discriminative way . 5.4 Segment-level Results: Tuned We experimented with tuning the weights of the individual metrics in the metric combinations , using the learning method described in Section 4.2 . First , we did this using cross-validation to tune and test on WMT12 . Later we tuned on WMT12 and evaluated on WMT11 . For cross-validation in WMT12 , we used ten folds of approximately equal sizes , each containing about 300 sentences : we constructed the folds by putting together entire documents , thus not allowing sentences from a document to be split over two different folds . During each cross-validation run , we trained our pairwise ranker using the human judgments corresponding to nine of the ten folds . We aggregated the data for different language pairs , and produced a single set of tuning weights for all language pairs .9 We then used the remaining fold for evaluation The results are shown in Table 4 . As in previous sections we present the average results over all four language pairs . We can see that the tuned combinations with DR-LEX improve over most of the individual metrics in groups II and III . Interestingly , the tuned combinations that include the much weaker metric DR now improve over 12 out of 13 of the individual metrics in groups II and III , and only slightly degrades the score of the 13th one ( SPEDE07PP ) . Note that the ASIYA metrics are combinations of several metrics , and these combinations ( which exclude DR and DR-LEX ) can be also tuned ; this yields sizable improvements over the untuned versions as column three in the table shows . Compared to this baseline , DR improves for three of the six ASIYA metrics , while DR-LEX improves for four of them . Note that improving over the last two ASIYA metrics is very hard : they have very high scores of .296 and .295 ; for comparison , the best segment-level system at WMT12 ( SPEDE07PP ) achieved a Tau of .254 . On average , DR improves Tau from .165 to .201 , which is + .036 , while DR-LEX improves to .222 , or + .057 . These much larger improvements highlight the importance of tuning the linear combination when working at the segment-level . 5.4.1 Testing on WMT11 In order to rule out the possibility that the improvement of the tuned metrics on WMT12 comes from over-fitting , and to verify that the tuned metrics do generalize when applied to other sentences , we also tested on a new test set : WMT11 . Therefore , we tuned the weights on all WMT12 pairwise judgments ( no cross-validation ) , and we evaluated on WMT11 . Since the metrics that participated in WMT11 and WMT12 are different ( and even when they have the same name , there is no guarantee that they have not changed from 2011 to 2012 ) , we only report results for the versions of NIST , ROUGE , TER , and BLEU available in ASIYA , as well as for the ASIYA metrics , thus ensuring that the metrics in the experiments are consistent for 2011 and 2012 . The results are shown in Table 5 . Once again , tuning yields sizable improvements over the simple combination for the ASIYA metrics ( third column in Table 5 ) . Adding DR and DR-LEX to the combinations manages to improve over five and four of the six tuned ASIYA metrics , respectively . However , some of the differences are very small . On the contrary , DR and DR-LEX significantly improve over NIST , ROUGE , TER , and BLEU . Overall , DR improves the average Tau from .207 to .244 , which is + .037 , while DR-LEX improves to .267 or + .061 . These improvements are very close to those for the WMT12 cross-validation . This shows that the weights learned on WMT12 generalize well , as they are also good for WMT11 . What is also interesting to note is that when tuning is used , DR helps achieve sizeable improvements , even if not as strong as for DR-LEX . This is remarkable given that DR has a strong negative Tau as an individual metric at the sentence-level . This suggests that both DR and DR-LEX contain information that is complementary to that of the individual metrics that we experimented with . Overall , from the experimental results in this section , we can conclude that discourse structure is an important information source to be taken into account in the automatic evaluation of machine translation output . 6 Conclusions and Future Work In this paper we have shown that discourse structure can be used to improve automatic MT evaluation . First , we defined two simple discourse-aware similarity metrics ( lexicalized and un-lexicalized ) , which use the all-subtree kernel to compute similarity between discourse parse trees in accordance with the Rhetorical Structure Theory . Then , after extensive experimentation on WMT12 and WMT11 data , we showed that a variety of existing evaluation metrics can benefit from our discourse-based metrics , both at the segment - and the system-level , especially when the discourse information is incorporated in an informed way ( i.e . using supervised tuning ) . Our results show that discourse-based metrics can improve the state-ofthe-art MT metrics , by increasing correlation with human judgments , even when only sentence-level discourse information is used . Addressing discourse-level phenomena in MT is a relatively new research direction . Yet , many of the ongoing efforts have been moderately successful according to traditional evaluation metrics . There is a consensus in the MT community that more discourse-aware metrics need to be proposed for this area to move forward . We believe this work is a valuable contribution towards this longer-term goal . The tuned combined metrics tested in this paper are just an initial proposal , i.e. a simple adjustment of the relative weights for the individual metrics in a linear combination . In the future , we plan to work on integrated representations of syntactic , semantic and discourse-based structures , which would allow us to train evaluation metrics based on more fine-grained features . Additionally , we propose to use the discourse information for MT in two different ways . First , at the sentence-level , we can use discourse information to re-rank alternative MT hypotheses ; this could be applied either for MT parameter tuning , or as a post-processing step for the MT output . Second , we propose to move in the direction of using discourse information beyond the sentence-level . "}
  },
    {
    "id": "P16-1002",
    "result":     [
            {
        "value":         {
          "start": 392,
          "end": 423,
          "text": "synchronous context-free grammar",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 541,
          "end": 560,
          "text": "sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 582,
          "end": 584,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 607,
          "end": 639,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 778,
          "end": 785,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 794,
          "end": 802,
          "text": "RNN model",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 901,
          "end": 916,
          "text": "GeoQuery dataset",
          "labels": ["Dataset"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 1548,
          "end": 1581,
          "text": "recurrent neural networks ( RNNs )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 1821,
          "end": 1824,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2004,
          "end": 2007,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2714,
          "end": 2754,
          "text": "synchronous context-free grammar ( SCFG )",
          "labels": ["Method"]
        },
        "id": 1025
      },
            {
        "value":         {
          "start": 2844,
          "end": 2867,
          "text": "sequence-to-sequence RNN",
          "labels": ["Method"]
        },
        "id": 1025
      },
            {
        "value":         {
          "start": 2882,
          "end": 2914,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 2948,
          "end": 2955,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2964,
          "end": 2972,
          "text": "RNN model",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 3018,
          "end": 3028,
          "text": "GEO dataset",
          "labels": ["Dataset"]
        },
        "id": 1012
      },
            {
        "value":         {
          "start": 3065,
          "end": 3072,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 3117,
          "end": 3119,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 3683,
          "end": 3685,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 3892,
          "end": 3907,
          "text": "GeoQuery ( GEO )",
          "labels": ["Dataset"]
        },
        "id": 1013
      },
            {
        "value":         {
          "start": 4229,
          "end": 4241,
          "text": "ATIS ( ATIS )",
          "labels": ["Dataset"]
        },
        "id": 1014
      },
            {
        "value":         {
          "start": 4478,
          "end": 4500,
          "text": "Overnight ( OVERNIGHT )",
          "labels": ["Dataset"]
        },
        "id": 1015
      },
            {
        "value":         {
          "start": 5324,
          "end": 5353,
          "text": "sequence-to-sequence RNN model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 5376,
          "end": 5424,
          "text": "attention-based neural machine translation models",
          "labels": ["Method"]
        },
        "id": 1017
      },
            {
        "value":         {
          "start": 5506,
          "end": 5538,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 5550,
          "end": 5567,
          "text": "copying mechanisms",
          "labels": ["Method"]
        },
        "id": 1042
      },
            {
        "value":         {
          "start": 5808,
          "end": 5824,
          "text": "bidirectional RNN",
          "labels": ["Method"]
        },
        "id": 1019
      },
            {
        "value":         {
          "start": 5984,
          "end": 5987,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 5993,
          "end": 6003,
          "text": "forward RNN",
          "labels": ["Method"]
        },
        "id": 1022
      },
            {
        "value":         {
          "start": 6011,
          "end": 6022,
          "text": "backward RNN",
          "labels": ["Method"]
        },
        "id": 1022
      },
            {
        "value":         {
          "start": 6030,
          "end": 6040,
          "text": "forward RNN",
          "labels": ["Method"]
        },
        "id": 1022
      },
            {
        "value":         {
          "start": 6222,
          "end": 6225,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 6271,
          "end": 6282,
          "text": "backward RNN",
          "labels": ["Method"]
        },
        "id": 1022
      },
            {
        "value":         {
          "start": 6539,
          "end": 6559,
          "text": "attention-based model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 7761,
          "end": 7793,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 8417,
          "end": 8439,
          "text": "Attention-based copying",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 8511,
          "end": 8531,
          "text": "attention-based model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 8567,
          "end": 8581,
          "text": "Pointer Network",
          "labels": ["Method"]
        },
        "id": 1478
      },
            {
        "value":         {
          "start": 8618,
          "end": 8632,
          "text": "Pointer Network",
          "labels": ["Method"]
        },
        "id": 1478
      },
            {
        "value":         {
          "start": 8875,
          "end": 8898,
          "text": "sequence-to-sequence RNN",
          "labels": ["Method"]
        },
        "id": 1025
      },
            {
        "value":         {
          "start": 9194,
          "end": 9202,
          "text": "RNN model",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 11184,
          "end": 11224,
          "text": "synchronous context-free grammar ( SCFG )",
          "labels": ["Method"]
        },
        "id": 1025
      },
            {
        "value":         {
          "start": 11284,
          "end": 11287,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 11563,
          "end": 11566,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 11657,
          "end": 11660,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 11796,
          "end": 11799,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12028,
          "end": 12037,
          "text": "SCFG-based",
          "labels": ["Method"]
        },
        "id": 1025
      },
            {
        "value":         {
          "start": 12063,
          "end": 12066,
          "text": "WASP",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12136,
          "end": 12139,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12203,
          "end": 12206,
          "text": "WASP",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12223,
          "end": 12230,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 12284,
          "end": 12287,
          "text": "WASP",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12422,
          "end": 12425,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 12539,
          "end": 12547,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 12555,
          "end": 12563,
          "text": "RNN model",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 12593,
          "end": 12598,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 12675,
          "end": 12678,
          "text": "SCFG",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 13188,
          "end": 13199,
          "text": "ABSENTI-TIES",
          "labels": ["Method"]
        },
        "id": 1027
      },
            {
        "value":         {
          "start": 13983,
          "end": 13992,
          "text": "GEO domain",
          "labels": ["Dataset"]
        },
        "id": 1028
      },
            {
        "value":         {
          "start": 14089,
          "end": 14104,
          "text": "ABSW-HOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1029
      },
            {
        "value":         {
          "start": 14396,
          "end": 14407,
          "text": "AB-SENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 15368,
          "end": 15384,
          "text": "CONCAT-k strategy",
          "labels": ["Method"]
        },
        "id": 1031
      },
            {
        "value":         {
          "start": 15628,
          "end": 15638,
          "text": "ABSENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 15644,
          "end": 15659,
          "text": "ABSWHOLE-PHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 15944,
          "end": 15962,
          "text": "attention-based RNN",
          "labels": ["Method"]
        },
        "id": 1034
      },
            {
        "value":         {
          "start": 16733,
          "end": 16735,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 16739,
          "end": 16742,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 16750,
          "end": 16758,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 16766,
          "end": 16769,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 16808,
          "end": 16815,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 16823,
          "end": 16825,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 16831,
          "end": 16839,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 17117,
          "end": 17131,
          "text": "ABSWHOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 17136,
          "end": 17138,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17144,
          "end": 17152,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 17172,
          "end": 17187,
          "text": "ABSWHOLE-PHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 17192,
          "end": 17195,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17385,
          "end": 17387,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17393,
          "end": 17396,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17664,
          "end": 17667,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17688,
          "end": 17710,
          "text": "attention-based copying",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 18336,
          "end": 18362,
          "text": "stochastic gradient descent",
          "labels": ["Method"]
        },
        "id": 1039
      },
            {
        "value":         {
          "start": 18656,
          "end": 18661,
          "text": "Theano",
          "labels": ["Tool"]
        },
        "id": 1039
      },
            {
        "value":         {
          "start": 19280,
          "end": 19290,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19392,
          "end": 19394,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19400,
          "end": 19408,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 19547,
          "end": 19550,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19679,
          "end": 19711,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 19815,
          "end": 19831,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 19935,
          "end": 19937,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19943,
          "end": 19946,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19954,
          "end": 19970,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 20011,
          "end": 20018,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20049,
          "end": 20051,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20071,
          "end": 20074,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20091,
          "end": 20099,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 20114,
          "end": 20130,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 20224,
          "end": 20240,
          "text": "OVERNIGHT dataset",
          "labels": ["Dataset"]
        },
        "id": 1041
      },
            {
        "value":         {
          "start": 20367,
          "end": 20375,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 20417,
          "end": 20433,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 20675,
          "end": 20692,
          "text": "copying mechanisms",
          "labels": ["Method"]
        },
        "id": 1042
      },
            {
        "value":         {
          "start": 21151,
          "end": 21158,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21286,
          "end": 21300,
          "text": "ABSWHOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21304,
          "end": 21314,
          "text": "ABSENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21322,
          "end": 21331,
          "text": "CONCAT - 2",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21423,
          "end": 21425,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 21472,
          "end": 21480,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21497,
          "end": 21499,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 21519,
          "end": 21526,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21668,
          "end": 21671,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 21776,
          "end": 21790,
          "text": "ABSWHOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21845,
          "end": 21852,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21867,
          "end": 21877,
          "text": "ABSENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 21893,
          "end": 21902,
          "text": "CONCAT - 3",
          "labels": ["Method"]
        },
        "id": 1043
      },
            {
        "value":         {
          "start": 22132,
          "end": 22154,
          "text": "attention-based copying",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 22210,
          "end": 22212,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22218,
          "end": 22221,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22256,
          "end": 22264,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 22271,
          "end": 22273,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22327,
          "end": 22334,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22443,
          "end": 22446,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22480,
          "end": 22489,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 22615,
          "end": 22622,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22627,
          "end": 22635,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 22704,
          "end": 22711,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22768,
          "end": 22776,
          "text": "OVERNIGHT",
          "labels": ["Dataset"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 23115,
          "end": 23130,
          "text": "ABSWHOLE-PHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 23136,
          "end": 23145,
          "text": "CONCAT - 2",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 23401,
          "end": 23421,
          "text": "attention-based model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 23462,
          "end": 23469,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23536,
          "end": 23550,
          "text": "ABSWHOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 23587,
          "end": 23597,
          "text": "ABSENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 24725,
          "end": 24735,
          "text": "ABSENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 24846,
          "end": 24860,
          "text": "ABSWHOLEPHRASES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 24874,
          "end": 24885,
          "text": "AB-SENTITIES",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 25097,
          "end": 25104,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 25870,
          "end": 25877,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 25884,
          "end": 25913,
          "text": "sequence-to-sequence RNN model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 25960,
          "end": 25991,
          "text": "synchronous context-free grammar",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 26169,
          "end": 26193,
          "text": "attention-based RNN model",
          "labels": ["Method"]
        },
        "id": 1044
      },
            {
        "value":         {
          "start": 26306,
          "end": 26331,
          "text": "non-recurrent neural model",
          "labels": ["Method"]
        },
        "id": 1045
      },
            {
        "value":         {
          "start": 26422,
          "end": 26430,
          "text": "RNN model",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 26498,
          "end": 26530,
          "text": "attention-based copying mechanism",
          "labels": ["Method"]
        },
        "id": 1046
      },
            {
        "value":         {
          "start": 26666,
          "end": 26682,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 27290,
          "end": 27296,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 28983,
          "end": 28986,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 29067,
          "end": 29099,
          "text": "synchronous context free grammars",
          "labels": ["Method"]
        },
        "id": 1046
      }
    ],
    "data": {"text": "Data Recombination for Neural Semantic Parsing Abstract Modeling crisp logical regularities is crucial in semantic parsing, making it difficult for neural models with no task-specific prior knowledge to achieve good results. In this paper, we introduce data recombination, a novel framework for injecting such prior knowledge into a model. From the training data , we induce a high-precision synchronous context-free grammar , which captures important conditional independence properties commonly found in semantic parsing . We then train a sequence-to-sequence recurrent network ( RNN ) model with a novel attention-based copying mechanism on datapoints sampled from this grammar , thereby teaching the model about these structural properties . Data recombination improves the accuracy of our RNN model on three semantic parsing datasets , leading to new state-of-the-art performance on the standard GeoQuery dataset for models with comparable supervision . 1 Introduction Semantic parsing—the precise translation of natural language utterances into logical forms—has many applications, including question answering ( Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Liang et al., 2011; Berant et al., 2013 ), instruction following ( Artzi and Zettlemoyer, 2013b ), and regular expression generation ( Kushman and Barzilay, 2013 ). Modern semantic parsers ( Artzi and Zettlemoyer, 2013a; Berant et al., 2013 ) are complex pieces of software, requiring handcrafted features, lexicons, and grammars. Meanwhile , recurrent neural networks ( RNNs ) have made swift inroads into many structured prediction tasks in NLP , including machine translation ( Sutskever et al . , 2014 ; Bahdanau et al . , 2014 ) and syntactic parsing ( Vinyals et al . , 2015b ; Dyer et al . , 2015 ) . Because RNNs make very few domain-specific assumptions , they have the potential to succeed at a wide variety of tasks with minimal feature engineering . However , this flexibility also puts RNNs at a disadvantage compared to standard semantic parsers , which can generalize naturally by leveraging their built-in awareness of logical compositionality . In this paper, we introduce data recombination, a generic framework for declaratively injecting prior knowledge into a domain-general structured prediction model. In data recombination, prior knowledge about a task is used to build a high-precision generative model that expands the empirical distribution by allowing fragments of different examples to be combined in particular ways. Samples from this generative model are then used to train a domain-general model. In the case of semantic parsing , we construct a generative model by inducing a synchronous context-free grammar ( SCFG ) , creating new examples such as those shown in Figure 1 ; our domain-general model is a sequence-to-sequence RNN with a novel attention-based copying mechanism . Data recombination boosts the accuracy of our RNN model on three semantic parsing datasets . On the GEO dataset , data recombination improves test accuracy by 4.3 percentage points over our baseline RNN , leading to new state-of-the-art results for models that do not use a seed lexicon for predicates . 2 Problem statement We cast semantic parsing as a sequence-to-sequence task. The input utterance x is a sequence of words x1, . . . , xm ∈ V ( in ), the input vocabulary; similarly, the output logical form y is a sequence of tokens y1, . . . , yn ∈ V ( out ), the output vocabulary. A linear sequence of tokens might appear to lose the hierarchical structure of a logical form , but there is precedent for this choice : Vinyals et al . ( 2015b ) showed that an RNN can reliably predict tree-structured outputs in a linear fashion . We evaluate our system on three existing semantic parsing datasets. Figure 2 shows sample input-output pairs from each of these datasets. GeoQuery ( GEO ) contains natural language questions about US geography paired with corresponding Prolog database queries . We use the standard split of 600 training examples and 280 test examples introduced by Zettlemoyer and Collins ( 2005 ). We preprocess the logical forms to De Brujin index notation to standardize variable naming. ATIS ( ATIS ) contains natural language queries for a flights database paired with corresponding database queries written in lambda calculus . We train on 4473 examples and evaluate on the 448 test examples used by Zettlemoyer and Collins ( 2007 ). Overnight ( OVERNIGHT ) contains logical forms paired with natural language paraphrases across eight varied subdomains . Wang et al. ( 2015 ) constructed the dataset by generating all possible logical forms up to some depth threshold, then getting multiple natural language paraphrases for each logical form from workers on Amazon Mechanical Turk. We evaluate on the same train/test splits as Wang et al. ( 2015 ). In this paper, we only explore learning from logical forms. In the last few years, there has an emergence of semantic parsers learned from denotations ( Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013b ). While our system cannot directly learn from denotations, it could be used to rerank candidate derivations generated by one of these other systems. 3 Sequence-to-sequence RNN Model Our sequence-to-sequence RNN model is based on existing attention-based neural machine translation models ( Bahdanau et al . , 2014 ; Luong et al . , 2015a ) , but also includes a novel attention-based copying mechanism . Similar copying mechanisms have been explored in parallel by Gu et al . ( 2016 ) and Gulcehre et al . ( 2016 ) . 3.1 Basic Model Encoder. The encoder converts the input sequence x1 , . . . , xm into a sequence of context-sensitive embeddings b1 , . . . , bm using a bidirectional RNN ( Bahdanau et al . , 2014 ) . First, a word embedding function φ( in ) maps each word xi to a fixed-dimensional vector. These vectors are fed as input to two RNNs : a forward RNN and a backward RNN . The forward RNN starts with an initial hidden state hF0 , and generates a sequence of hidden states hF1 , . . . , h F m by repeatedly applying the recurrence . The recurrence takes the form of an LSTM ( Hochreiter and Schmidhuber , 1997 ) . The backward RNN similarly generates hidden states hBm , . . . , h B 1 by processing the input sequence in reverse order . Finally, for each input position i, we define the context-sensitive embedding bi to be the concatenation of hFi and h B i Decoder. The decoder is an attention-based model ( Bahdanau et al . , 2014 ; Luong et al . , 2015a ) that generates the output sequence y1 , . . . , yn one token at a time . At each time step j, it writes yj based on the current hidden state sj , then updates the hidden state to sj+1 based on sj and yj . Formally, the decoder is defined by the following equations. When not specified, i ranges over {1, . . . ,m} and j ranges over {1, . . . , n}. Intuitively, the αji’s define a probability distribution over the input words, describing what words in the input the decoder is focusing on at time j. They are computed from the unnormalized attention scores eji. The matrices W ( s ), W ( a ), and U , as well as the embedding function φ( out ), are parameters of the model. 3.2 Attention-based Copying In the basic model of the previous section, the next output word yj is chosen via a simple softmax over all words in the output vocabulary. However, this model has difficulty generalizing to the long tail of entity names commonly found in semantic parsing datasets. Conveniently, entity names in the input often correspond directly to tokens in the output ( e.g., “iowa” becomes iowa in Figure 2 ). To capture this intuition , we introduce a new attention-based copying mechanism . At each time step j, the decoder generates one of two types of actions. As before, it can write any word in the output vocabulary. In addition, it can copy any input word xi directly to the output, where the probability with which we copy xi is determined by the attention score on xi. Formally, we define a latent action aj that is either Write[w] for some w ∈ V ( out ) or Copy[i] for some i ∈ {1, . . . ,m}. We then have. The decoder chooses aj with a softmax over all these possible actions; yj is then a deterministic function of aj and x. During training, we maximize the log-likelihood of y, marginalizing out a. Attention-based copying can be seen as a combination of a standard softmax output layer of an attention-based model ( Bahdanau et al . , 2014 ) and a Pointer Network ( Vinyals et al . , 2015a ) ; in a Pointer Network , the only way to generate output is to copy a symbol from the input . 4 Data Recombination 4.1 Motivation The main contribution of this paper is a novel data recombination framework that injects important prior knowledge into our oblivious sequence-to-sequence RNN . In this framework, we induce a high-precision generative model from the training data, then sample from it to generate new training examples. The process of inducing this generative model can leverage any available prior knowledge , which is transmitted through the generated examples to the RNN model . A key advantage of our two-stage approach is that it allows us to declare desired properties of the task which might be hard to capture in the model architecture. Our approach generalizes data augmentation, which is commonly employed to inject prior knowledge into a model. Data augmentation techniques focus on modeling invariances— transformations like translating an image or adding noise that alter the inputs x, but do not change the output y. These techniques have proven effective in areas like computer vision ( Krizhevsky et al., 2012 ) and speech recognition ( Jaitly and Hinton, 2013 ). In semantic parsing, however, we would like to capture more than just invariance properties. Consider an example with the utterance “what states border texas ? ”. Given this example, it should be easy to generalize to questions where “texas” is replaced by the name of any other state: simply replace the mention of Texas in the logical form with the name of the new state. Underlying this phenomenon is a strong conditional independence principle: the meaning of the rest of the sentence is independent of the name of the state in question. Standard data augmentation is not sufficient to model such phenomena: instead of holding y fixed, we would like to apply simultaneous transformations to x and y such that the new x still maps to the new y. Data recombination addresses this need. 4.2 General Setting In the general setting of data recombination, we start with a training set D of ( x, y ) pairs, which defines the empirical distribution pˆ( x, y ). We then fit a generative model p˜( x, y ) to pˆ which generalizes beyond the support of pˆ, for example by splicing together fragments of different examples. We refer to examples in the support of p˜ as recombinant examples. Finally, to train our actual model pθ( y | x ), we maximize the expected value of log pθ( y | x ), where ( x, y ) is drawn from p˜. 4.3 SCFGs for Semantic Parsing For semantic parsing , we induce a synchronous context-free grammar ( SCFG ) to serve as the backbone of our generative model p ˜ . An SCFG consists of a set of production rules X → 〈 α , β 〉 , whereX is a category ( non-terminal ) , and α and β are sequences of terminal and non-terminal symbols . Any non-terminal symbols in α must be aligned to the same non-terminal symbol in β, and vice versa. Therefore , an SCFG defines a set of joint derivations of aligned pairs of strings . In our case , we use an SCFG to represent joint derivations of utterances x and logical forms y ( which for us is just a sequence of tokens ) . After we induce an SCFG G from D , the corresponding generative model p ˜ ( x , y ) is the distribution over pairs ( x , y ) defined by sampling from G , where we choose production rules to apply uniformly at random . It is instructive to compare our SCFG-based data recombination with WASP ( Wong and Mooney , 2006 ; Wong and Mooney , 2007 ) , which uses an SCFG as the actual semantic parsing model . The grammar induced by WASP must have good coverage in order to generalize to new inputs at test time . WASP also requires the implementation of an efficient algorithm for computing the conditional probability p ( y | x ) . In contrast , our SCFG is only used to convey prior knowledge about conditional independence structure , so it only needs to have high precision ; our RNN model is responsible for boosting recall over the entire input space . We also only need to forward sample from the SCFG , which is considerably easier to implement than conditional inference . Below, we examine various strategies for inducing a grammar G from a dataset D. We first encode D as an initial grammar with rules ROOT → 〈x, y〉 for each ( x, y ) ∈ D. Next, we will define each grammar induction strategy as a mapping from an input grammar Gin to a new grammar Gout. This formulation allows us to compose grammar induction strategies ( Section 4.3.4 ). 4.3.1 Abstracting Entities Our first grammar induction strategy , ABSENTI-TIES , simply abstracts entities with their types . We assume that each entity e ( e.g., texas ) has a corresponding type e.t ( e.g., state ), which we infer based on the presence of certain predicates in the logical form ( e.g. stateid ). For each grammar rule X → 〈α, β〉 in Gin, where α contains a token ( e.g., “texas” ) that string matches an entity ( e.g., texas ) in β, we add two rules to Gout: ( i ) a rule where both occurrences are replaced with the type of the entity ( e.g., state ), and ( ii ) a new rule that maps the type to the entity ( e.g., STATEID → 〈“texas”,texas〉; we reserve the category name STATE for the next section ). Thus, Gout generates recombinant examples that fuse most of one example with an entity found in a second example. A concrete example from the GEO domain is given in Figure 3 . 4.3.2 Abstracting Whole Phrases Our second grammar induction strategy , ABSW-HOLEPHRASES , abstracts both entities and whole phrases with their types . For each grammar rule X → 〈α, β〉 in Gin, we add up to two rules to Gout. First , if α contains tokens that string match to an entity in β , we replace both occurrences with the type of the entity , similarly to rule ( i ) from AB-SENTITIES . Second, if we can infer that the entire expression β evaluates to a set of a particular type ( e.g. state ) we create a rule that maps the type to 〈α, β〉. In practice, we also use some simple rules to strip question identifiers from α, so that the resulting examples are more natural. Again, refer to Figure 3 for a concrete example. This strategy works because of a more general conditional independence property: the meaning of any semantically coherent phrase is conditionally independent of the rest of the sentence, the cornerstone of compositional semantics. Note that this assumption is not always correct in general: for example, phenomena like anaphora that involve long-range context dependence violate this assumption. However, this property holds in most existing semantic parsing datasets. 4.3.3 Concatenation The final grammar induction strategy is a surprisingly simple approach we tried that turns out to work. For any k ≥ 2 , we define the CONCAT-k strategy , which creates two types of rules . First, we create a single rule that has ROOT going to a sequence of k SENT’s. Then, for each rootlevel rule ROOT → 〈α, β〉 in Gin, we add the rule SENT → 〈α, β〉 to Gout. See Figure 3 for an example. Unlike ABSENTITIES and ABSWHOLE-PHRASES , concatenation is very general , and can be applied to any sequence transduction problem . Of course, it also does not introduce additional information about compositionality or independence properties present in semantic parsing. However , it does generate harder examples for the attention-based RNN , since the model must learn to attend to the correct parts of the now-longer input sequence . Related work has shown that training a model on more difficult examples can improve generalization, the most canonical case being dropout ( Hinton et al., 2012; Wager et al., 2013 ). 4.3.4 Composition We note that grammar induction strategies can be composed, yielding more complex grammars. Given any two grammar induction strategies f1 and f2, the composition f1 ◦ f2 is the grammar induction strategy that takes in Gin and returns f1( f2( Gin ) ). For the strategies we have defined, we can perform this operation symbolically on the grammar rules, without having to sample from the intermediate grammar f2( Gin ). 5 Experiments We evaluate our system on three domains : GEO , ATIS , and OVERNIGHT . For ATIS , we report logical form exact match accuracy . For GEO and OVERNIGHT , we determine correctness based on denotation match , as in Liang et al . ( 2011 ) and Wang et al . ( 2015 ) , respectively . 5.1 Choice of Grammar Induction Strategy We note that not all grammar induction strategies make sense for all domains. In particular , we only apply ABSWHOLEPHRASES to GEO and OVERNIGHT . We do not apply ABSWHOLE-PHRASES to ATIS , as the dataset has little nesting structure . 5.2 Implementation Details We tokenize logical forms in a domain-specific manner, based on the syntax of the formal language being used. On GEO and ATIS , we disallow copying of predicate names to ensure a fair comparison to previous work , as string matching between input words and predicate names is not commonly used . We prevent copying by prepending underscores to predicate tokens; see Figure 2 for examples. On ATIS alone , when doing attention-based copying and data recombination , we leverage an external lexicon that maps natural language phrases ( e.g . , “ kennedy airport ” ) to entities ( e.g . , jfk : ap ) . When we copy a word that is part of a phrase in the lexicon, we write the entity associated with that lexicon entry. When performing data recombination, we identify entity alignments based on matching phrases and entities from the lexicon. We run all experiments with 200 hidden units and 100-dimensional word vectors. We initialize all parameters uniformly at random within the interval [−0.1, 0.1]. We maximize the loglikelihood of the correct logical form using stochastic gradient descent . We train the model for a total of 30 epochs with an initial learning rate of 0.1, and halve the learning rate every 5 epochs, starting after epoch 15. We replace word vectors for words that occur only once in the training set with a universal <unk> word vector. Our model is implemented in Theano ( Bergstra et al . , 2010 ) . When performing data recombination, we sample a new round of recombinant examples from our grammar at each epoch. We add these examples to the original training dataset, randomly shuffle all examples, and train the model for the epoch. Figure 4 gives pseudocode for this training procedure. One important hyperparameter is how many examples to sample at each epoch: we found that a good rule of thumb is to sample as many recombinant examples as there are examples in the training dataset, so that half of the examples the model sees at each epoch are recombinant. At test time , we use beam search with beam size 5 . We automatically balance missing right parentheses by adding them at the end. On GEO and OVERNIGHT , we then pick the highest-scoring logical form that does not yield an executor error when the corresponding denotation is computed . On ATIS , we just pick the top prediction on the beam . 5.3 Impact of the Copying Mechanism First , we measure the contribution of the attention-based copying mechanism to the model ’ s overall performance . On each task , we train and evaluate two models : one with the copying mechanism , and one without . Training is done without data recombination. The results are shown in Table 1. On GEO and ATIS , the copying mechanism helps significantly : it improves test accuracy by 10.4 percentage points on GEO and 6.4 points on ATIS . However , on OVERNIGHT , adding the copying mechanism actually makes our model perform slightly worse . This result is somewhat expected , as the OVERNIGHT dataset contains a very small number of distinct entities . It is also notable that both systems surpass the previous best system on OVERNIGHT by a wide margin . We choose to use the copying mechanism in all subsequent experiments , as it has a large advantage in realistic settings where there are many distinct entities in the world . The concurrent work of Gu et al . ( 2016 ) and Gulcehre et al . ( 2016 ) , both of whom propose similar copying mechanisms , provides additional evidence for the utility of copying on a wide range of NLP tasks . 5.4 Main Results For our main results, we train our model with a variety of data recombination strategies on all three datasets. These results are summarized in Tables 2 and 3. We compare our system to the baseline of not using any data recombination, as well as to state-of-the-art systems on all three datasets. We find that data recombination consistently improves accuracy across the three domains we evaluated on , and that the strongest results come from composing multiple strategies . Combining ABSWHOLEPHRASES , ABSENTITIES , and CONCAT - 2 yields a 4.3 percentage point improvement over the baseline without data recombination on GEO , and an average of 1.7 percentage points on OVERNIGHT . In fact , on GEO , we achieve test accuracy of 89.3% , which surpasses the previous state-of-the-art , excluding Liang et al . ( 2011 ) , which used a seed lexicon for predicates . On ATIS , we experiment with concatenating more than 2 examples , to make up for the fact that we cannot apply ABSWHOLEPHRASES , which generates longer examples . We obtain a test accuracy of 83.3 with ABSENTITIES composed with CONCAT - 3 , which beats the baseline by 7 percentage points and is competitive with the state-of-the-art . Data recombination without copying. For completeness , we also investigated the effects of data recombination on the model without attention-based copying . We found that recombination helped significantly on GEO and ATIS , but hurt the model slightly on OVERNIGHT . On GEO , the best data recombination strategy yielded test accuracy of 82.9% , for a gain of 8.3 percentage points over the baseline with no copying and no recombination ; on ATIS , data recombination gives test accuracies as high as 74.6% , a 4.7 point gain over the same baseline . However , no data recombination strategy improved average test accuracy on OVERNIGHT ; the best one resulted in a 0.3 percentage point decrease in test accuracy . We hypothesize that data recombination helps less on OVERNIGHT in general because the space of possible logical forms is very limited , making it more like a large multiclass classification task . Therefore, it is less important for the model to learn good compositional representations that generalize to new logical forms at test time. 5.5 Effect of Longer Examples Interestingly , strategies like ABSWHOLE-PHRASES and CONCAT - 2 help the model even though the resulting recombinant examples are generally not in the support of the test distribution . In particular , these recombinant examples are on average longer than those in the actual dataset , which makes them harder for the attention-based model . Indeed , for every domain , our best accuracy numbers involved some form of concatenation , and often involved ABSWHOLEPHRASES as well . In comparison , applying ABSENTITIES alone , which generates examples of the same length as those in the original dataset , was generally less effective . We conducted additional experiments on artificial data to investigate the importance of adding longer, harder examples. We experimented with adding new examples via data recombination, as well as adding new independent examples ( e.g. to simulate the acquisition of more training data ). We constructed a simple world containing a set of entities and a set of binary relations. For any n, we can generate a set of depth-n examples, which involve the composition of n relations applied to a single entity. Example data points are shown in Figure 5. We train our model on various datasets, then test it on a set of 500 randomly chosen depth-2 examples. The model always has access to a small seed training set of 100 depth-2 examples. We then add one of four types of examples to the training set: Same length, independent: New randomly chosen depth-2 examples.3 Longer, independent: Randomly chosen depth-4 examples. Same length , recombinant : Depth - 2 examples sampled from the grammar induced by applying ABSENTITIES to the seed dataset . Longer , recombinant : Depth - 4 examples sampled from the grammar induced by applying ABSWHOLEPHRASES followed by AB-SENTITIES to the seed dataset . To maintain consistency between the independent and recombinant experiments, we fix the recombinant examples across all epochs, instead of resampling at every epoch. In Figure 6 , we plot accuracy on the test set versus the number of additional examples added of each of these four types . As expected, independent examples are more helpful than the recombinant ones, but both help the model improve considerably. In addition, we see that even though the test dataset only has short examples, adding longer examples helps the model more than adding shorter ones, in both the independent and recombinant cases. These results underscore the importance training on longer, harder examples. 6 Discussion In this paper, we have presented a novel framework we term data recombination, in which we generate new training examples from a high-precision generative model induced from the original training dataset. We have demonstrated its effectiveness in improving the accuracy of a sequence-to-sequence RNN model on three semantic parsing datasets , using a synchronous context-free grammar as our generative model . There has been growing interest in applying neural networks to semantic parsing and related tasks. Dong and Lapata ( 2016 ) concurrently developed an attention-based RNN model for semantic parsing , although they did not use data recombination . Grefenstette et al . ( 2014 ) proposed a non-recurrent neural model for semantic parsing , though they did not run experiments . Mei et al . ( 2016 ) use an RNN model to perform a related task of instruction following . Our proposed attention-based copying mechanism bears a strong resemblance to two models that were developed independently by other groups . Gu et al . ( 2016 ) apply a very similar copying mechanism to text summarization and singleturn dialogue generation . Gulcehre et al. ( 2016 ) propose a model that decides at each step whether to write from a “shortlist” vocabulary or copy from the input, and report improvements on machine translation and text summarization. Another piece of related work is Luong et al. ( 2015b ), who train a neural machine translation system to copy rare words, relying on an external system to generate alignments. Prior work has explored using paraphrasing for data augmentation on NLP tasks. Zhang et al . ( 2015 ) augment their data by swapping out words for synonyms from WordNet . Wang and Yang ( 2015 ) use a similar strategy, but identify similar words and phrases based on cosine distance between vector space embeddings. Unlike our data recombination strategies, these techniques only change inputs x, while keeping the labels y fixed. Additionally, these paraphrasing-based transformations can be described in terms of grammar induction, so they can be incorporated into our framework. In data recombination, data generated by a high-precision generative model is used to train a second, domain-general model. Generative oversampling ( Liu et al., 2007 ) learns a generative model in a multiclass classification setting, then uses it to generate additional examples from rare classes in order to combat label imbalance. Uptraining ( Petrov et al., 2010 ) uses data labeled by an accurate but slow model to train a computationally cheaper second model. Vinyals et al. ( 2015b ) generate a large dataset of constituency parse trees by taking sentences that multiple existing systems parse in the same way, and train a neural model on this dataset. Some of our induced grammars generate examples that are not in the test distribution, but nonetheless aid in generalization. Related work has also explored the idea of training on altered or out-of-domain data, often interpreting it as a form of regularization. Dropout training has been shown to be a form of adaptive regularization ( Hinton et al., 2012; Wager et al., 2013 ). Guu et al. ( 2015 ) showed that encouraging a knowledge base completion model to handle longer path queries acts as a form of structural regularization. Language is a blend of crisp regularities and soft relationships. Our work takes RNNs , which excel at modeling soft phenomena , and uses a highly structured tool - synchronous context free grammars - to infuse them with an understanding of crisp structure . We believe this paradigm for simultaneously modeling the soft and hard aspects of language should have broader applicability beyond semantic parsing. "}
  },
    {
    "id": "P16-1049",
    "result":     [
            {
        "value":         {
          "start": 254,
          "end": 260,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 674,
          "end": 681,
          "text": "Doc-Chat",
          "labels": ["Method"]
        },
        "id": 1142
      },
            {
        "value":         {
          "start": 686,
          "end": 691,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 697,
          "end": 702,
          "text": "QASent",
          "labels": ["Dataset"]
        },
        "id": 1172
      },
            {
        "value":         {
          "start": 883,
          "end": 889,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 896,
          "end": 903,
          "text": "XiaoIce2",
          "labels": ["Tool"]
        },
        "id": 1145
      },
            {
        "value":         {
          "start": 982,
          "end": 988,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 2872,
          "end": 2878,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 6193,
          "end": 6209,
          "text": "IBM model 1 score",
          "labels": ["Metric"]
        },
        "id": 1146
      },
            {
        "value":         {
          "start": 6325,
          "end": 6332,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 6740,
          "end": 6778,
          "text": "SMT ( statistical machine translation )",
          "labels": ["Method"]
        },
        "id": 1147
      },
            {
        "value":         {
          "start": 7669,
          "end": 7674,
          "text": "n-gram",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 8575,
          "end": 8615,
          "text": "attention-based sentence embedding method",
          "labels": ["Method"]
        },
        "id": 1148
      },
            {
        "value":         {
          "start": 8628,
          "end": 8661,
          "text": "convolution neural network ( CNN )",
          "labels": ["Method"]
        },
        "id": 1149
      },
            {
        "value":         {
          "start": 11515,
          "end": 11554,
          "text": "attention-based sentence embedding model",
          "labels": ["Method"]
        },
        "id": 1150
      },
            {
        "value":         {
          "start": 13790,
          "end": 13802,
          "text": "rel-CNN model",
          "labels": ["Method"]
        },
        "id": 1151
      },
            {
        "value":         {
          "start": 14186,
          "end": 14192,
          "text": "rel-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 14196,
          "end": 14202,
          "text": "rel-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 14459,
          "end": 14482,
          "text": "SimpleQuestions data set",
          "labels": ["Dataset"]
        },
        "id": 1166
      },
            {
        "value":         {
          "start": 14572,
          "end": 14579,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 14627,
          "end": 14633,
          "text": "rel-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 14680,
          "end": 14688,
          "text": "CNN model",
          "labels": ["Method"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 14703,
          "end": 14710,
          "text": "type-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 14901,
          "end": 14908,
          "text": "type-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 15332,
          "end": 15378,
          "text": "pLSI ( probabilistic latent semantic indexing )",
          "labels": ["Method"]
        },
        "id": 1155
      },
            {
        "value":         {
          "start": 15384,
          "end": 15418,
          "text": "LDA ( latent Dirichlet allocation )",
          "labels": ["Method"]
        },
        "id": 1156
      },
            {
        "value":         {
          "start": 15848,
          "end": 15856,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 16003,
          "end": 16011,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 16084,
          "end": 16090,
          "text": "rel-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 16096,
          "end": 16103,
          "text": "type-CNN",
          "labels": ["Method"]
        },
        "id": 1157
      },
            {
        "value":         {
          "start": 16155,
          "end": 16163,
          "text": "CNN model",
          "labels": ["Method"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 16178,
          "end": 16186,
          "text": "topic-CNN",
          "labels": ["Method"]
        },
        "id": 1158
      },
            {
        "value":         {
          "start": 16348,
          "end": 16356,
          "text": "topic-CNN",
          "labels": ["Method"]
        },
        "id": 1158
      },
            {
        "value":         {
          "start": 16594,
          "end": 16596,
          "text": "SGD",
          "labels": ["Method"]
        },
        "id": 1312
      },
            {
        "value":         {
          "start": 16900,
          "end": 16905,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 17551,
          "end": 17556,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 19793,
          "end": 19795,
          "text": "SMT",
          "labels": ["Method"]
        },
        "id": 1159
      },
            {
        "value":         {
          "start": 19913,
          "end": 19915,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 20451,
          "end": 20457,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 20658,
          "end": 20664,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 21311,
          "end": 21341,
          "text": "Knowledge-based semantic models",
          "labels": ["Method"]
        },
        "id": 1160
      },
            {
        "value":         {
          "start": 21515,
          "end": 21521,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 21698,
          "end": 21704,
          "text": "WikiQA6",
          "labels": ["Dataset"]
        },
        "id": 1161
      },
            {
        "value":         {
          "start": 21802,
          "end": 21810,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 22207,
          "end": 22212,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 22450,
          "end": 22457,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 22575,
          "end": 22585,
          "text": "WikiAnswers",
          "labels": ["Dataset"]
        },
        "id": 1162
      },
            {
        "value":         {
          "start": 22603,
          "end": 22610,
          "text": "Word2Vec",
          "labels": ["Method"]
        },
        "id": 1273
      },
            {
        "value":         {
          "start": 22689,
          "end": 22697,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 22772,
          "end": 22786,
          "text": "bilingual data8",
          "labels": ["Dataset"]
        },
        "id": 1163
      },
            {
        "value":         {
          "start": 22934,
          "end": 22941,
          "text": "GIZA + +",
          "labels": ["Tool"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 23012,
          "end": 23026,
          "text": "Yahoo Answers10",
          "labels": ["Dataset"]
        },
        "id": 1164
      },
            {
        "value":         {
          "start": 23265,
          "end": 23273,
          "text": "CNN model",
          "labels": ["Method"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 23350,
          "end": 23366,
          "text": "English Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 23473,
          "end": 23481,
          "text": "CNN model",
          "labels": ["Method"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 23609,
          "end": 23634,
          "text": "SimpleQuestions data set11",
          "labels": ["Dataset"]
        },
        "id": 1165
      },
            {
        "value":         {
          "start": 23791,
          "end": 23798,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 24029,
          "end": 24052,
          "text": "SimpleQuestions data set",
          "labels": ["Dataset"]
        },
        "id": 1166
      },
            {
        "value":         {
          "start": 24156,
          "end": 24163,
          "text": "LightLDA",
          "labels": ["Method"]
        },
        "id": 1166
      },
            {
        "value":         {
          "start": 24319,
          "end": 24335,
          "text": "English Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 24516,
          "end": 24545,
          "text": "Mean Average Precision ( MAP )",
          "labels": ["Metric"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 24551,
          "end": 24578,
          "text": "Mean Reciprocal Rank ( MRR )",
          "labels": ["Metric"]
        },
        "id": 1167
      },
            {
        "value":         {
          "start": 24622,
          "end": 24627,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 25136,
          "end": 25143,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 25156,
          "end": 25164,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 25307,
          "end": 25315,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 25384,
          "end": 25390,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 25395,
          "end": 25400,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 25635,
          "end": 25651,
          "text": "bi-gram CNN model",
          "labels": ["Method"]
        },
        "id": 1168
      },
            {
        "value":         {
          "start": 25729,
          "end": 25732,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25894,
          "end": 25896,
          "text": "CNN",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 25948,
          "end": 25970,
          "text": "WikiQA ’ s training set",
          "labels": ["Dataset"]
        },
        "id": 1175
      },
            {
        "value":         {
          "start": 26019,
          "end": 26025,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 26127,
          "end": 26135,
          "text": "CNN model",
          "labels": ["Method"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 26186,
          "end": 26204,
          "text": "WikiQA training set",
          "labels": ["Dataset"]
        },
        "id": 1170
      },
            {
        "value":         {
          "start": 26293,
          "end": 26299,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 26555,
          "end": 26560,
          "text": "WikiQA",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 26566,
          "end": 26571,
          "text": "QASent",
          "labels": ["Dataset"]
        },
        "id": 1172
      },
            {
        "value":         {
          "start": 26837,
          "end": 26853,
          "text": "WikiQA-like tasks",
          "labels": ["Dataset"]
        },
        "id": 1171
      },
            {
        "value":         {
          "start": 26939,
          "end": 26945,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 26986,
          "end": 26991,
          "text": "QASent",
          "labels": ["Dataset"]
        },
        "id": 1172
      },
            {
        "value":         {
          "start": 27049,
          "end": 27057,
          "text": "CNNWikiQA",
          "labels": ["Method"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27063,
          "end": 27071,
          "text": "CNNQASent",
          "labels": ["Method"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27142,
          "end": 27151,
          "text": "CNN models",
          "labels": ["Method"]
        },
        "id": 1174
      },
            {
        "value":         {
          "start": 27168,
          "end": 27190,
          "text": "WikiQA ’ s training set",
          "labels": ["Dataset"]
        },
        "id": 1175
      },
            {
        "value":         {
          "start": 27196,
          "end": 27218,
          "text": "QASent ’ s training set",
          "labels": ["Dataset"]
        },
        "id": 1175
      },
            {
        "value":         {
          "start": 27287,
          "end": 27312,
          "text": "QASent ’ s development set",
          "labels": ["Dataset"]
        },
        "id": 1176
      },
            {
        "value":         {
          "start": 27332,
          "end": 27338,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 27352,
          "end": 27360,
          "text": "CNNWikiQA",
          "labels": ["Method"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27374,
          "end": 27376,
          "text": "MAP",
          "labels": ["Metric"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27382,
          "end": 27384,
          "text": "MRR",
          "labels": ["Metric"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27432,
          "end": 27440,
          "text": "CNNQASent",
          "labels": ["Method"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 27505,
          "end": 27511,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 27716,
          "end": 27722,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 27800,
          "end": 27806,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 28171,
          "end": 28179,
          "text": "Precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 28183,
          "end": 28188,
          "text": "Recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 28196,
          "end": 28203,
          "text": "F1 score",
          "labels": ["Metric"]
        },
        "id": 1317
      },
            {
        "value":         {
          "start": 28229,
          "end": 28250,
          "text": "WikiQA development set",
          "labels": ["Dataset"]
        },
        "id": 1177
      },
            {
        "value":         {
          "start": 28640,
          "end": 28646,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 28983,
          "end": 28989,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 29087,
          "end": 29093,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 29100,
          "end": 29106,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 29254,
          "end": 29265,
          "text": "Baidu Zhidao",
          "labels": ["Dataset"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 29327,
          "end": 29343,
          "text": "Chinese Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1181
      },
            {
        "value":         {
          "start": 29621,
          "end": 29632,
          "text": "Baidu Zhidao",
          "labels": ["Dataset"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 29711,
          "end": 29727,
          "text": "Chinese Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1181
      },
            {
        "value":         {
          "start": 29792,
          "end": 29808,
          "text": "Chinese Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1181
      },
            {
        "value":         {
          "start": 29828,
          "end": 29838,
          "text": "topic − CNN",
          "labels": ["Method"]
        },
        "id": 1181
      },
            {
        "value":         {
          "start": 30045,
          "end": 30056,
          "text": "Baidu Zhidao",
          "labels": ["Dataset"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30434,
          "end": 30440,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30484,
          "end": 30490,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30599,
          "end": 30605,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30701,
          "end": 30707,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30756,
          "end": 30762,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 30775,
          "end": 30781,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31104,
          "end": 31110,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31151,
          "end": 31157,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31184,
          "end": 31190,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31207,
          "end": 31213,
          "text": "XiaoIce",
          "labels": ["Tool"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31290,
          "end": 31296,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31382,
          "end": 31388,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 31856,
          "end": 31862,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      },
            {
        "value":         {
          "start": 32093,
          "end": 32099,
          "text": "DocChat",
          "labels": ["Method"]
        },
        "id": 1182
      }
    ],
    "data": {"text": "DocChat: An Information Retrieval Approach for Chatbot Engines Using Unstructured Documents Abstract Most current chatbot engines are designed to reply to user utterances based on existing utterance-response ( or Q-R )1 pairs. In this paper , we present DocChat , a novel information retrieval approach for chatbot engines that can leverage unstructured documents , instead of Q-R pairs , to respond to utterances . A learning to rank model with features designed at different levels of granularity is proposed to measure the relevance between utterances and responses directly. We evaluate our proposed approach in both English and Chinese: ( i ) For English , we evaluate Doc-Chat on WikiQA and QASent , two answer sentence selection tasks , and compare it with state-of-the-art methods . Reasonable improvements and good adaptability are observed. ( ii ) For Chinese , we compare DocChat with XiaoIce2 , a famous chitchat engine in China , and side-by-side evaluation shows that DocChat is a perfect complement for chatbot engines using Q-R pairs as main source of responses . 1 Introduction Building chatbot engines that can interact with humans with natural language is one of the most challenging problems in artificial intelligence. Along with the explosive growth of social media, like community question answering ( CQA ) websites ( e.g., Yahoo Answers and WikiAnswers ) and social media websites ( e.g., Twitter and Weibo ), the amount of utterance-response ( or Q-R ) pairs has experienced massive growth in recent years, and such a corpus greatly promotes the emergence of various data-driven chatbot approaches. Instead of multiple rounds of conversation, we only consider a much simplified task, short text conversation ( STC ) in which the response R is a short text and only depends on the last user utteranceQ. Previous methods for the STC task mostly rely on Q-R pairs and fall into two categories: Retrieval-based methods ( e.g., Ji et al., 2014 ). This type of methods first retrieve the most possible 〈Qˆ, Rˆ〉 pair from a set of existing Q-R pairs, which best matches current utterance Q based on semantic matching models, then take Rˆ as the response R. One disadvantage of such a method is that, for many specific domains, collecting such Q-R pairs is intractable. Generation based methods ( e.g., Shang et al., 2015 ). This type of methods usually uses an encoder-decoder framework which first encode Q as a vector representation, then feed this representation to decoder to generate response R. Similar to retrieval-based methods, such approaches also depend on existing Q-R pairs as training data. Like other language generation tasks, such as machine translation and paraphrasing, the fluency and naturality of machine generated text is another drawback. To overcome the issues mentioned above , we present a novel response retrieval approach , DocChat , to find responses based on unstructured documents . For each user utterance, instead of looking for the best Q-R pair or generating a word sequence based on language generation techniques, our method selects a sentence from given documents directly, by ranking all possible sentences based on features designed at different levels of granularity. On one hand, using documents rather than Q-R pairs greatly improve the adaptability of chatbot engines on different chatting topics. On the other hand, all responses come from existing documents, which guarantees their fluency and naturality. We also show promising results in experiments, on both QA and chatbot scenarios. 2 Task Description Formally, given an utteranceQ and a document set D, the document-based chatbot engine retrieves responseR based on the following three steps: response retrieval, which retrieves response candidates C from D based on Q. Each S ∈ C is a sentence existing in D. response ranking, which ranks all response candidates in C and selects the most possible response candidate as Sˆ, response triggering, which decides whether it is confident enough to responseQ using Sˆ: where I is a binary value. When I equals to true, let the response R = Sˆ and output R; otherwise, output nothing. In the following three sections, we will describe solutions of these three components one by one. 3 Response Retrieval Given a user utterance Q, the goal of response retrieval is to efficiently find a small number of sentences fromD, which have high possibility to contain suitable sentences as Q’s response. Although it is not necessarily true that a good response always shares more words with a given utterance, this measurement is still helpful in finding possible response candidates ( Ji et al., 2014 ). In this paper, the BM25 term weighting formulas ( Jones et al., 2000 ) is used to retrieve response candidates from documents. Given each document Dk ∈ D, we collect a set of sentence triples 〈Sprev,S,Snext〉 fromDk, where S denotes a sentence in Dk, Sprev and Snext denote S’s previous sentence and next sentence respectively. Two special tags, 〈BOD〉 and 〈EOD〉, are added at the beginning and end of each passage, to make sure that such sentence triples can be extracted for every sentence in the document. The reason for indexing each sentence together with its context sentences is intuitive: If a sentence within a document can respond to an utterance, then its context should be revelent to the utterance as well. 4 Response Ranking Given a user utteranceQ and a response candidate S, the ranking function Rank( S,Q ) is designed as an ensemble of individual matching features: where hk( · ) denotes the k-th feature function, λk denotes hk( · )’s corresponding weight. We design features at different levels of granularity to measure the relevance between S and Q, including word-level, phrase-level, sentencelevel, document-level, relation-level, type-level and topic-level, which will be introduced below. 4.1 Word-level Feature We define three word-level features in this work: ( 1 ) hWM ( S,Q ) denotes a word matching feature that counts the number ( weighted by the IDF value of each word in S ) of non-stopwords shared by S and Q. ( 2 ) hW2W ( S , Q ) denotes a word-to-word translation-based feature that calculates the IBM model 1 score ( Brown et al . , 1993 ) of S and Q based on word alignments trained on ‘ question-related question ’ pairs using GIZA + + ( Och and Ney , 2003 ) . ( 3 ) hW2V ( S,Q ) denotes a word embedding-based feature that calculates the average cosine distance between word embeddings of all non-stopword pairs 〈vSj , vQi〉. vSj represent the word vector of jth word in S and vQj represent the word vector of ith word in Q. 4.2 Phrase-level Feature 4.2.1 Paraphrase We first describe how to extract phrase-level paraphrases from an existing SMT ( statistical machine translation ) phrase table . PT = {〈si, ti, p( ti|si ), p( si|ti )〉}3 is a phrase table, which is extracted from a bilingual corpus, where si ( or ti ) denotes a phrase, in source ( or target ) language, p( ti|si ) ( or p( si|ti ) ) denotes the translation probability from si ( or ti ) to ti ( or si ). We follow Bannard and Callison-Burch ( 2005 ) to extract a paraphrase table PP = {〈si, sj , score( sj ; si )〉}. si and sj denote two phrases in source language, score( sj ; si ) denotes a confidence score that si can be paraphrased to sj , which is computed based on PT . The underlying idea of this approach is that, two source phrases that are aligned to the same target phrase trend to be paraphrased. We then define a paraphrase-based feature as : where Sj + n − 1j denotes the consecutive word sequence ( or phrase ) in S , which starts from Sj and ends with Sj + n − 1 , N denotes the maximum n-gram order ( here is 3 ) . CountPP ( Sj+n−1j ,Q ) is computed based on the following rules: If Sj+n−1j ∈ Q, then CountPP ( Sj+n−1j ,Q ) = 1; Else, if 〈Sj+n−1j , s, score( s;Sj+n−1j  )〉 ∈ PP and Sj+n−1j ’s paraphrase s occurs in Q, then CountPP ( Sj+n−1j ,Q ) = score( s;Sj+n−1j  ) Else, CountPP ( Sj+n−1j ,Q ) = 0. 4.2.2 Phrase-to-Phrase Translation Similar to hPP ( S,Q ), a phrase translation-based feature based on a phrase table PT is defined as: where CountPT ( Sj+n−1j ,Q ) is computed based on the following rules: If Sj+n−1j ∈ Q, then CountPT ( Sj+n−1j ,Q ) = 1; Else, if 〈Sj+n−1j , s, p( Sj+n−1j |s ), p( s|Sj+n−1j  )〉 ∈ PT and Sj+n−1j ’s translation s ∈ Q, then CountPT ( Sj+n−1j ,Q ) = p( Sj+n−1j |s ) · p( s|Sj+n−1j  ) Else, CountPT ( Sj+n−1j ,Q ) = 0 We train a phrase table based on ‘question-answer’ pairs crawled from community QA websites. 4.3 Sentence-level Feature We first present an attention-based sentence embedding method based on a convolution neural network ( CNN ) , whose input is a sentence pair and output is a sentence embedding pair . Two features will be introduced in Section 4.3.1 and 4.3.2, which are designed based on two sentence embedding models trained using different types of data. In the input layer, given a sentence pair 〈SX ,SY 〉, an attention matrix A ∈ R|SX |×|SY | is generated based on pre-trained word embeddings of SX and SY , where each element Ai,j ∈ A is computed as: where vSXi ( or v SY j  ) denotes the embedding vector of the ith ( or jth ) word in SX ( or SY  ). Then, column-wise and row-wise max-pooling are applied to A to generate two attention vectors V SX ∈ R|SX | and V SY ∈ R|SY |, where the kth elements of V SX and V SY are computed as:  )can be interpreted as the attention score of the kth word in SX ( or SY  ) with regard to all words in SY ( or SX  ). Next, two attention distributions DSX ∈ R|SX | and DSY ∈ R|SY | are generated for SX and SY based on V SX and V SY respectively, where the kth elements of DSX and DSY are computed as: can be interpreted as the normalized attention score of the kth word in SX ( or SY  ) with regard to all words in SY ( or SX  ). Last, we update each pre-trained word embedding vSXk ( or v SY k  ) to vˆ SX k ( or vˆ SY k  ), by multiplying every value in vSXk ( or v SY k  ) with D SX k ( or D SY k  ). The underlying intuition of updating pre-trained word embeddings is to re-weight the importance of each word in SX ( or SY  ) based on SY ( or SX  ), instead of treating them in an equal manner. In the convolution layer, we first derive an input matrix ZSX = {l1, ..., l|SX |}, where lt is the concatenation of a sequence ofm = 2d−14 updated word embeddings [vˆSXt−d, ..., vˆ SX t , ..., vˆ SX t+d], centralized in the tth word in SX . Then, the convolution layer performs sliding window-based feature extraction to project each vector representation lt ∈ ZSX to a contextual feature vector hSXt : where Wc is the convolution matrix, is the activation function. The same operation is performed to SY as well. In the pooling layer, we aggregate local features extracted by the convolution layer from SX , and form a sentence-level global feature vector with a fixed size independent of the length of the input sentence. Here, max-pooling is used to force the network to retain the most useful local features by hSXt ( i ) denotes the ith value in the vector h SX t . The same operation are performed to SY as well. In the output layer, one more non-linear transformation is applied to lSXp . Ws is the semantic projection matrix, y( SX ) is the final sentence embedding of SX . The same operation is performed to SY to obtain y( SY  ). We train model parameters Wc and Ws by minimizing the following ranking loss function: where M is a constant, S−Y is a negative instance. 4.3.1 Causality Relationship Modeling We train the first attention-based sentence embedding model based on a set of ‘ question-answer ’ pairs as input sentence pairs , and then design a causality relationship-based feature as : ySCR ( S ) and ySCR ( Q ) denote the sentence embeddings of S and Q respectively . We expect this feature captures the causality relationship between questions and their corresponding answers, and works on question-like utterances. 4.3.2 Discourse Relationship Modeling We train the second attention-based sentence embedding model based on a set of ‘sentence-next sentence’ pairs as input sentence pairs, and then design a discourse relationship-based feature as: ySDR( S ) and ySDR( Q ) denote the sentence embeddings of S and Q respectively. We expect this feature learns and captures the discourse relationship between sentences and their next sentences, and works on statement-like utterances. Here, a large number of ‘sentence-next sentence’ pairs can be easily obtained from documents. 4.4 Document-level Feature We take document-level information into consideration to measure the semantic similarity between Q and S, and define two context features as: where S∗ can be Sprev and Snext that denote previous and next sentences of S in the original document. The sentence embedding model trained based on ‘question-answer’ pairs ( in Section 4.3.1 ) is directly used to generate context embeddings for hDM ( Sprev,Q ) and hDM ( Snext,Q ). So no further training data is needed for this feature. 4.5 Relation-level Feature Given a structured knowledge base, such as Freebase5, a single relation question Q ( in natural language ) with its answer can be first parsed into a fact formatted as 〈esbj , rel, eobj〉, where esbj denotes a subject entity detected from the question, rel denotes the relationship expressed by the question, eobj denotes an object entity found from the knowledge base based on esbj and rel. Then we can get 〈Q, rel〉 pairs. This rel can help for modeling semantic relationships between Q and R. For example, the Q-A pair 〈What does Jimmy Neutron do? − inventor〉 can be parsed into 〈Jimmy Neutron, fictional character occupation, inventor〉 where the rel is fictional character occupation. Similar to Yih et al . ( 2014 ) , We use 〈 Q , rel 〉 pairs as training data , and learn a rel-CNN model , which can encode each question Q ( or each relation rel ) into a relation embedding . For a given question Q, the corresponding relation rel+ is treated as a positive example, and randomly selected other relations are used as negative examples rel−. The posterior probability of rel + givenQ is computed as : y ( rel ) and y ( Q ) denote relation embeddings of rel and Q based on rel-CNN . rel-CNN is trained by maximizing the log-posterior . We then define a relation-based feature as: yRE( S ) and yRE( Q ) denote relation embeddings of S and Q respectively, coming from rel-CNN. 4.6 Type-level Feature We extend each 〈 Q , esbj , rel , eobj 〉 in the SimpleQuestions data set to 〈 Q , esbj , rel , eobj , type 〉 , where type denotes the type name of eobj based on Freebase . Thus, we obtain 〈Q, type〉 pairs. Similar to rel-CNN , we use 〈 Q , type 〉 pairs to train another CNN model , denoted as type-CNN . Based on which , we define a type-based feature as : hTE ( S , Q ) = cosine ( yTE ( Q ) , yTE ( S ) ) yTE ( S ) and yTE ( Q ) denote type embeddings of S and Q respectively , coming from type-CNN . 4.7 Topic-level Feature 4.7.1 Unsupervised Topic Model As the assumption that Q-R pair should share similar topic distribution, We define an unsupervised topic model-based feature hUTM as the average cosine distance between topic vectors of all non-stopword pairs 〈vSj , vQi〉, where vw = [p( t1|w ), ..., p( tN |w )]T denotes the topic vector of a given word w. Given a corpus , various topic modeling methods , such as pLSI ( probabilistic latent semantic indexing ) and LDA ( latent Dirichlet allocation ) , can be used to estimate p ( ti | w ) , which denotes the probability thatw belongs to a topic ti . 4.7.2 Supervised Topic Model One shortcoming of the unsupervised topic model is that, the topic size is pre-defined, which might not reflect the truth on a specific corpus. In this paper, we explore a supervised topic model approach as well, based on ‘sentence-topic’ pairs. We crawl a large number of 〈 S , topic 〉 pairs from Wikipedia documents , where S denotes a sentence , topic denotes the content name of the section that S extracted from . Such content names are labeled by Wikipedia article editors , and can be found in the Contents fields . Similar to rel-CNN and type-CNN , we use the 〈 S , topic 〉 pairs to train another CNN model , denoted as topic-CNN . Based on which , we define a supervised topic model-based feature as : ySTM ( S ) and ySTM ( Q ) denote topic embeddings of S andQ respectively , coming from topic-CNN . 4.8 Learning to Ranking Model We employ a regression-based learning to rank method ( Nallapati , 2004 ) to train response ranking model , based on a set of labeled 〈 Q , C 〉 pairs , Feature weights in the ranking model are trained by SGD based on the training data that consists of a set of 〈 Q , C 〉 pairs , where Q denotes a user utterance and C denotes a set of response candidates . Each candidate S in C is labeled by + or−, which indicates whether S is a suitable response of Q ( + ), or not ( − ). As manually labeled data , such as WikiQA ( Yang et al . , 2015 ) , needs expensive human annotation effort , we propose an automatic way to collect training data . First, ‘question-answer’ ( or Q-A ) pairs {Qi, Ai}Mi=1 are crawled from community QA websites. Qi denotes a question. Ai denotes Qi’s answer, which includes one or more sentences Ai = {s1, ..., sK}. Then, we index answer sentences of all questions. Next, for each question Qi, we run response retrieval to obtain answer sentence candidates Ci = {s′1, ..., s ′ N}. Last, if we know the correct answer sentences of each questionQi, we can then label each candidate in Ci as + or −. In experiments , manually labeled data ( WikiQA ) is used in open domain question answering scenario , and automatically generated data is used in chatbot scenario . 5 Response Triggering There are two types of utterances, chit-chat utterances and informative utterances. The former should be handled by chit-chat engines, and the latter is more suitable to our work, as documents usually contain formal and informative contents. Thus, we have to respond to informative utterances only. Response retrieval cannot always guarantee to return a candidate set that contains at least one suitable response, but response ranking will output the best possible candidate all the time. So, we have to decide which responses are confident enough to be output, and which are not. In this paper, we define response triggering as a function that decides whether a response candidate S has enough confidence to be output: where Trigger( Q,S ) returns true, if and only if all its three sub-functions return true. IU ( Q ) returns true, if Q is an informative query. We collect and label chit-chat queries based on conversational exchanges from social media websites to train the classifier. IRank( S,Q ) returns true, if the score s( S,Q ) exceeds an empirical threshold τ : where α is the scaling factor that controls the distribution of s( · ) smooth or sharp. Both α and τ are selected based on a separated development set. IR( S ) returns true, if ( i ) the length of S is less than a pre-defined threshold, and ( ii ) S does not start with a phrase that expresses a progressive relation, such as but also, besides, moreover and etc., as the contents of sentences starting with such phrases usually depend on their context sentences, and they are not suitable for responses. 6 Related Work For modeling dialogue. Previous works mainly focused on rule-based or learning-based approaches ( Litman et al., 2000; Schatzmann et al., 2006; Williams and Young, 2007 ). These methods require efforts on designing rules or labeling data for training, which suffer the coverage issue. For short text conversation. With the fast development of social media, such as microblog and CQA services, large scale conversation data and data-driven approaches become possible. Ritter et al . ( 2011 ) proposed an SMT based method , which treats response generation as a machine translation task . Shang et al . ( 2015 ) presented an RNN based method , which is trained based on a large number of single round conversation data . Grammatical and fluency problems are the biggest issue for such generation-based approaches. Retrieval-based methods selects the most suitable response to the current utterance from the large number of Q-R pairs. Ji et al. ( 2014 ) built a conversation system using learning to rank and semantic matching techniques. However, collecting enough Q-R pairs to build chatbots is often intractable for many domains. Compared to previous methods , DocChat learns internal relationships between utterances and responses based on statistical models at different levels of granularity , and relax the dependency on Q-R pairs as response sources . These make DocChat as a general response generation solution to chatbots , with high adaptation capability . For answer sentence selection. Prior work in measuring the relevance between question and answer is mainly in word-level and syntactic-level ( Wang and Manning, 2010; Heilman and Smith, 2010; Yih et al., 2013 ). Learning representation by neural network architecture ( Yu et al., 2014; Wang and Nyberg, 2015; Severyn and Moschitti, 2015 ) has become a hot research topic to go beyond word-level or phrase-level methods. Compared to previous works we find that, ( i ) Large scale existing resources with noise have more advantages as training data. ( ii ) Knowledge-based semantic models can play important roles . 7 Experiments 7.1 Evaluation on QA ( English ) Take into account response ranking task and answer selection task are similar , we first evaluate DocChat in a QA scenario as a simulation . Here, response ranking is treated as the answer selection task, and response triggering is treated as the answer triggering task. We select WikiQA6 as the evaluation data , as it is precisely constructed based on natural language questions and Wikipedia documents , which contains 2,118 ‘ question-document ’ pairs in the training set , 296 ‘ question-document ’ pairs in development set , and 633 ‘ question-document ’ pairs in testing set . Each sentence in the document of a given question is labeled as 1 or 0, where 1 denotes the current sentence is a correct answer sentence, and 0 denotes the opposite meaning. Given a question , the task of WikiQA is to select answer sentences from all sentences in a question ’ s corresponding document . The training data settings of response ranking features are described below. Fw denotes 3 word-level features, hWM , hW2W and hW2V . For hW2W , GIZA + + is used to train word alignments on 11.6M ‘ question-related question ’ pairs ( Fader et al . , 2013 ) crawled from WikiAnswers .7 . For hW2V , Word2Vec ( Mikolov et al . , 2013 ) is used to train word embedding on sentences from Wikipedia in English . Fp denotes 2 phrase-level features, hPP and hPT . For hPP , bilingual data8 is used to extract a phrase-based translation table ( Koehn et al . , 2003 ) , from which paraphrases are extracted ( Section 4.2.1 ) . For hPT , GIZA + + trains word alignments on 4M ‘ question-answer ’ pairs9 crawled from Yahoo Answers10 , and then a phrase table is extracted from word alignments using the intersect-diag-grow refinement . Fs denotes 2 sentence-level features, hSCR and hSDR. For hSCR , 4M ‘ question-answer ’ pairs ( the same to hPT ) is used to train the CNN model . For hSDR , we randomly select 0.5M ‘ sentence-next sentence ’ pairs from English Wikipedia . Fd denotes document-level feature hDM . Here, we didn’t train a new model. Instead , we just reuse the CNN model used in hSCR . Fr and Fty denote relation-level feature hRE and type-level feature hTE . Bordes et al . ( 2015 ) released the SimpleQuestions data set11 , which consists of 108,442 English questions . Each question ( e.g . , What does Jimmy Neutron do ? ) is written by human annotators based on a triple in Freebase which formatted as 〈 esbj , rel , eobj 〉 ( e.g . , 〈 Jimmy Neutron , fictional character occupation , inventor 〉 ) . Here , as described in Section 4.5 and 4.6 , ‘ question-relation ’ pairs and ‘ question-type ’ pairs based upon SimpleQuestions data set are used to train hRE and hTE . Fto denotes 2 topic-level features, hUTM and hSTM . For hUTM , we run LightLDA ( Yuan et al . , 2015 ) on sentences from English Wikipedia , where the topic is set to 1,000 . For hSTM , 4M ‘ sentence-topic ’ pairs are extracted from English Wikipedia ( Section 4.7.2 ) , where the most frequent 25,000 content names are used as topics . 7.1.2 Results on Answer Selection ( AS ) The performance of answer selection is evaluated by Mean Average Precision ( MAP ) and Mean Reciprocal Rank ( MRR ) . Among all ‘ questiondocument ’ pairs in WikiQA , only one-third of documents contain answer sentences to their corresponding questions . Similar to previous work, questions without correct answers in the candidate sentences are not taken into account. We first evaluate the impact of features at each level, and show results in Table 1. Fw, Fp, and Fs perform best among all features, which makes sense, as they can capture lexical features. Fr and Fty perform not very good , but make sense , as the training data ( i.e . SimpleQuestions ) are based on Freebase instead of Wikipedia . Interestingly, we find that Fto and Fd can achieve comparable results as well. We think the reason is that , their training data come from Wikipedia , which fit the WikiQA task very well . We evaluate the quality of DocChat on WikiQA , and show results in Table 2 . The first four rows in Table 2 represent four baseline methods , including : ( 1 ) Yih et al . ( 2013 ) , which makes use of rich lexical semantic features ; ( 2 ) Yang et al . ( 2015 ) , which uses a bi-gram CNN model with average pooling ; ( 3 ) Miao et al . ( 2015 ) , which uses an enriched LSTM with a latent stochastic attention mechanism to model similarity between Q-R pairs ; and ( 4 ) Yin et al . ( 2015 ) , which adds the attention mechanism to the CNN architecture . Table 2 shows that , without using WikiQA ’ s training set ( only development set for ranking weights ) , DocChat can achieve comparable performance with state-of-the-art baselines . Furthermore , by combining the CNN model proposed by Yang et al . ( 2015 ) and trained on WikiQA training set , we achieve the best result on both metrics . Compared to previous methods , we think DocChat has the following two advantages : First , our feature models depending on existing resources are readily available ( such as Q-Q pairs , Q-A pairs , ‘ sentence-next sentence ’ pairs , and etc . ) , instead of requiring manually annotated data ( such as WikiQA and QASent ) . Training of the response ranking model does need labeled data, but the size demanded is acceptable. Second , as the training data used in our approach come from open domain resources , we can expect a high adaptation capability and comparable results on other WikiQA-like tasks , as our models are task-independent . To verify the second advantage , we evaluate DocChat on another answer selection data set , QASent ( Wang et al . , 2007 ) , and list results in Table 3 . CNNWikiQA and CNNQASent refer to the results of Yang et al . ( 2015 ) ’ s method , where the CNN models are trained on WikiQA ’ s training set and QASent ’ s training set respectively . All these three methods train feature weights using QASent ’ s development set . Table 3 tells , DocChat outperforms CNNWikiQA in terms of MAP and MRR , and achieves comparable results compared to CNNQASent . The comparisons results show a good adaptation capability of DocChat . Table 4 evaluates the contributions of features at different levels of granularity. To highlight the differences , we report the percent deviation by removing different features at the same level from DocChat . From Table 4 we can see that , 1 ) Each feature group is indispensable to DocChat ; 2 ) Features at sentence-level are most important than other feature groups ; 3 ) Compared to results in Table 1 , combining all features can significantly promote the performance . 7.1.3 Evaluation of Answer Triggering ( AT ) In both QA and chatbot, response triggering is important. Similar to Yang et al . ( 2015 ) , we also evaluate answer triggering using Precision , Recall , and F1 score as metrics . We use the WikiQA development set to tune the scaling factor α and trigger threshold τ that are described in Section 5 , where α is set to 0.9 and τ is set to 0.5 . Table 5 shows the evaluation results compare to Yang et al. ( 2015 ). We think the improvements come from the fact that our response ranking model are more discriminative, as more semantic-level features are leveraged. 7.2 Evaluation on Chatbot ( Chinese ) XiaoIce is a famous Chinese chatbot engine , which can be found in many platforms including WeChat official accounts ( like business pages on Facebook Messenger ) . The documents that each official account maintains and post to their followers can be easily obtained from the Web. Meanwhile , a WeChat official account can choose to authorize XiaoIce to respond to its followers ’ utterances . We design an interesting evaluation below to compare DocChat with XiaoIce , based on the publicly available documents . 7.2.1 Experiment Setup For ranking features , 17M ‘ question-related questions ’ pairs crawled from Baidu Zhidao are used to train word alignments for hW2W ; sentences from Chinese Wikipedia are used to train word embeddings for hW2V and a topic model for hUTM ; the same bilingual phrase table described in last experiment is also used to extract a Chinese paraphrase table for hPP which use Chinese as the source language; 5M ‘ question-answer ’ pairs crawled from Baidu Zhidao are used for hPT , hSCR and hDM ; 0.5M ‘ sentence-next sentence ’ pairs from Chinese Wikipedia are used for hSDR ; 1.3M ‘ sentence-topic pairs ’ crawled from Chinese Wikipedia are used to train topic − CNN for hSTM . As there is no knowledge base based labeled data for Chinese, we ignore relation-level feature hRE and type-level feature hTE . For ranking weights , we generate 90,321 〈 Q , C 〉 pairs based on Baidu Zhidao Q-A pairs by the automatic method described in Section 4.8 . This data set is used to train the learning to rank model feature weights {λk} by SGD. For documents, we randomly select 10 WeChat official accounts, and index their documents separately. The average number of documents is 600. Human annotators are asked to freely issue 100 queries to each official account to get XiaoIce response . Thus , we obtain 100 〈 query , XiaoIce response 〉 pairs for each official account . We also send the same 100 queries of each official account to DocChat based on official account ’ s corresponding document index , and obtain another 100 〈 query , DocChat response 〉 pairs . Given these 1,000 〈 query , XiaoIce response , DocChat response 〉 triples , we let human annotators do a side-by-side evaluation , by asking them which response is better for each query . Note that, the source of each response is masked during evaluation procedure. Table 6 gives an example. 7.2.2 DocChat v.s. XiaoIce Table 7 shows the results. Better ( or Worse ) denotes a DocChat response is better ( or worse ) than a XiaoIce response , Tie denotes a DocChat response and a XiaoIce response are equally good or bad . From Table 7 we observe that: ( 1 ) 156 DocChat responses ( 58 + 47 + 51 ) out of 1,000 queries are triggered . The trigger rate of DocChat is 15.6% . We check un-triggered queries, and find most of them are chitchat, such as ”hi”, ”hello”, ”who are you? ”. ( 2 ) Better cases are more than worse cases. Most queries in better cases are non-chitchat ones, and their contents are highly related to the domain of their corresponding WeChat official accounts. ( 3 ) Our proposed method is a perfect complement for chitchat engines on informative utterances. The reasons for bad cases are two-fold : First , a DocChat response overlaps with a query , but cannot actually response it . For this issue, we need to refine the capability of our response ranking model on measuring causality relationships. Second , we wrongly send a chitchat query to DocChat , as currently , we only use a white list of chitchat queries for chitchat / non-chitchat classification ( Section 5 ) . 8 Conclusion This paper presents a response retrieval method for chatbot engines based on unstructured documents. We evaluate our method on both question answering and chatbot scenarios, and obtain promising results. We leave better triggering component and multiple rounds of conversation handling to be addressed in our future work. "}
  },
    {
    "id": "P17-1005",
    "result":     [
            {
        "value":         {
          "start": 531,
          "end": 536,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 542,
          "end": 555,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 591,
          "end": 599,
          "text": "GEO-QUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 605,
          "end": 616,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 3472,
          "end": 3483,
          "text": "CCG grammars",
          "labels": ["Method"]
        },
        "id": 1186
      },
            {
        "value":         {
          "start": 3638,
          "end": 3662,
          "text": "transition-based approach",
          "labels": ["Method"]
        },
        "id": 1188
      },
            {
        "value":         {
          "start": 4003,
          "end": 4027,
          "text": "transition-based approach",
          "labels": ["Method"]
        },
        "id": 1188
      },
            {
        "value":         {
          "start": 4670,
          "end": 4677,
          "text": "GEOQUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 4733,
          "end": 4738,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 4766,
          "end": 4778,
          "text": "WEB-QUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1189
      },
            {
        "value":         {
          "start": 4812,
          "end": 4826,
          "text": "GRAPH-QUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1190
      },
            {
        "value":         {
          "start": 4932,
          "end": 4937,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 4943,
          "end": 4956,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 4999,
          "end": 5006,
          "text": "GEOQUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 5012,
          "end": 5023,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 5969,
          "end": 5973,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 6191,
          "end": 6195,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 6337,
          "end": 6341,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 6765,
          "end": 6769,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 6898,
          "end": 6902,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 6950,
          "end": 6974,
          "text": "recurrent neural networks",
          "labels": ["Method"]
        },
        "id": 1192
      },
            {
        "value":         {
          "start": 7064,
          "end": 7068,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 7351,
          "end": 7355,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 7455,
          "end": 7459,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 9184,
          "end": 9209,
          "text": "transition-based algorithm",
          "labels": ["Method"]
        },
        "id": 1193
      },
            {
        "value":         {
          "start": 9412,
          "end": 9416,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 9886,
          "end": 9918,
          "text": "recurrent neural network grammars",
          "labels": ["Method"]
        },
        "id": 1194
      },
            {
        "value":         {
          "start": 9922,
          "end": 9926,
          "text": "RNNGs",
          "labels": ["Method"]
        },
        "id": 1195
      },
            {
        "value":         {
          "start": 9963,
          "end": 9966,
          "text": "RNNG",
          "labels": ["Method"]
        },
        "id": 1196
      },
            {
        "value":         {
          "start": 11437,
          "end": 11441,
          "text": "FunQL",
          "labels": ["Tool"]
        },
        "id": 1197
      },
            {
        "value":         {
          "start": 12684,
          "end": 12687,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 12755,
          "end": 12764,
          "text": "stack-LSTM",
          "labels": ["Method"]
        },
        "id": 1198
      },
            {
        "value":         {
          "start": 13068,
          "end": 13077,
          "text": "stack-LSTM",
          "labels": ["Method"]
        },
        "id": 1198
      },
            {
        "value":         {
          "start": 15000,
          "end": 15003,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 15601,
          "end": 15608,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 18299,
          "end": 18319,
          "text": "discriminative ranker",
          "labels": ["Method"]
        },
        "id": 1203
      },
            {
        "value":         {
          "start": 18326,
          "end": 18345,
          "text": "maximumentropy model",
          "labels": ["Method"]
        },
        "id": 1199
      },
            {
        "value":         {
          "start": 18942,
          "end": 18962,
          "text": "discriminative ranker",
          "labels": ["Method"]
        },
        "id": 1203
      },
            {
        "value":         {
          "start": 19192,
          "end": 19199,
          "text": "GEOQUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 19436,
          "end": 19441,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 19506,
          "end": 19514,
          "text": "CLUEWEB09",
          "labels": ["Dataset"]
        },
        "id": 1200
      },
            {
        "value":         {
          "start": 19853,
          "end": 19864,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 19942,
          "end": 19947,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 19966,
          "end": 19973,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 20093,
          "end": 20106,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 20201,
          "end": 20208,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 20361,
          "end": 20369,
          "text": "GEO-QUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 20691,
          "end": 20696,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 20737,
          "end": 20744,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 20792,
          "end": 20803,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 20809,
          "end": 20822,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 20995,
          "end": 21002,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 21031,
          "end": 21047,
          "text": "Freebase / KG API",
          "labels": ["Dataset"]
        },
        "id": 1201
      },
            {
        "value":         {
          "start": 21115,
          "end": 21126,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 21132,
          "end": 21146,
          "text": "GRAPHQUES-TIONS",
          "labels": ["Dataset"]
        },
        "id": 1202
      },
            {
        "value":         {
          "start": 21451,
          "end": 21471,
          "text": "discriminative ranker",
          "labels": ["Method"]
        },
        "id": 1203
      },
            {
        "value":         {
          "start": 21884,
          "end": 21891,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 21938,
          "end": 21951,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 22109,
          "end": 22112,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 22238,
          "end": 22253,
          "text": "Glove embeddings",
          "labels": ["Method"]
        },
        "id": 1203
      },
            {
        "value":         {
          "start": 22470,
          "end": 22476,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 22499,
          "end": 22529,
          "text": "SymboliC meANiNg rEpResentation",
          "labels": ["Method"]
        },
        "id": 1205
      },
            {
        "value":         {
          "start": 22602,
          "end": 22609,
          "text": "GEOQUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 22752,
          "end": 22759,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23022,
          "end": 23026,
          "text": "LSTMs",
          "labels": ["Method"]
        },
        "id": 1414
      },
            {
        "value":         {
          "start": 23074,
          "end": 23081,
          "text": "SCAN-NER",
          "labels": ["Method"]
        },
        "id": 1207
      },
            {
        "value":         {
          "start": 23263,
          "end": 23271,
          "text": "GEO-QUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 23393,
          "end": 23399,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 23420,
          "end": 23425,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 23437,
          "end": 23444,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 23478,
          "end": 23479,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23719,
          "end": 23726,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 23917,
          "end": 23923,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 24310,
          "end": 24316,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 24357,
          "end": 24368,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 24398,
          "end": 24404,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 24795,
          "end": 24801,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 24984,
          "end": 24990,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 25224,
          "end": 25235,
          "text": "WEBQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 25257,
          "end": 25265,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 25323,
          "end": 25330,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 25429,
          "end": 25435,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 25519,
          "end": 25532,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 25546,
          "end": 25547,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25553,
          "end": 25559,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 25653,
          "end": 25659,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 25729,
          "end": 25730,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 26020,
          "end": 26027,
          "text": "GEOQUERY",
          "labels": ["Dataset"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 26996,
          "end": 27002,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 27025,
          "end": 27032,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 27287,
          "end": 27294,
          "text": "EASY-CCG",
          "labels": ["Method"]
        },
        "id": 1208
      },
            {
        "value":         {
          "start": 27335,
          "end": 27342,
          "text": "coverage",
          "labels": ["Metric"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 27353,
          "end": 27360,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 27362,
          "end": 27371,
          "text": "CCG parser",
          "labels": ["Method"]
        },
        "id": 1209
      },
            {
        "value":         {
          "start": 27375,
          "end": 27381,
          "text": "EASYCCG",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 27437,
          "end": 27443,
          "text": "F-score",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 27678,
          "end": 27683,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 27689,
          "end": 27701,
          "text": "WE-BQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1211
      },
            {
        "value":         {
          "start": 27761,
          "end": 27767,
          "text": "EASYCCG",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 27820,
          "end": 27833,
          "text": "GRAPHQUESTIONS",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 28255,
          "end": 28260,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 28630,
          "end": 28636,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 28696,
          "end": 28702,
          "text": "EASYCCG",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 28734,
          "end": 28739,
          "text": "SPADES",
          "labels": ["Dataset"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 29166,
          "end": 29172,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 29587,
          "end": 29593,
          "text": "SCANNER",
          "labels": ["Method"]
        },
        "id": 1212
      },
            {
        "value":         {
          "start": 31157,
          "end": 31164,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      }
    ],
    "data": {"text": "Learning Structured Natural Language Representations for Semantic Parsing Abstract We introduce a neural semantic parser which is interpretable and scalable. Our model converts natural language utterances to intermediate, domain-general natural language representations in the form of predicate-argument structures, which are induced with a transition system and subsequently mapped to target domains. The semantic parser is trained end-to-end using annotated logical forms or their denotations. We achieve the state of the art on SPADES and GRAPHQUESTIONS and obtain competitive results on GEO-QUERY and WEBQUESTIONS . The induced predicate-argument structures shed light on the types of representations useful for semantic parsing and how these are different from linguistically motivated ones.1 1 Introduction Semantic parsing is the task of mapping natural language utterances to machine interpretable meaning representations. Despite differences in the choice of meaning representation and model structure, most existing work conceptualizes semantic parsing following two main approaches. Under the first approach, an utterance is parsed and grounded to a meaning representation directly via learning a task-specific grammar ( Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Wong and Mooney, 2006; Kwiatkowksi et al., 2010; Liang et al., 2011; Berant et al., 2013; Flanigan et al., 2014; Pasupat and Liang, 2015; Groschwitz et al., 2015 ). Under the second approach, the utterance is first parsed to an intermediate task-independent representation tied to a syntactic parser and then mapped to a grounded representation ( Kwiatkowski et al., 2013; Reddy et al., 2016, 2014; Krishnamurthy and Mitchell, 2015; Gardner and Krishnamurthy, 2017 ). A merit of the two-stage approach is that it creates reusable intermediate interpretations, which potentially enables the handling of unseen words and knowledge transfer across domains ( Bender et al., 2015 ). The successful application of encoder-decoder models ( Bahdanau et al., 2015; Sutskever et al., 2014 ) to a variety of NLP tasks has provided strong impetus to treat semantic parsing as a sequence transduction problem where an utterance is mapped to a target meaning representation in string format ( Dong and Lapata, 2016; Jia and Liang, 2016; Kocˇisky´ et al., 2016 ). Such models still fall under the first approach, however, in contrast to previous work ( Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011 ) they reduce the need for domain-specific assumptions, grammar learning, and more generally extensive feature engineering. But this modeling flexibility comes at a cost since it is no longer possible to interpret how meaning composition is performed. Such knowledge plays a critical role in understand modeling limitations so as to build better semantic parsers. Moreover, without any taskspecific prior knowledge, the learning problem is fairly unconstrained, both in terms of the possible derivations to consider and in terms of the target output which can be ill-formed ( e.g., with extra or missing brackets ). In this work, we propose a neural semantic parser that alleviates the aforementioned problems. Our model falls under the second class of approaches where utterances are first mapped to an intermediate representation containing natural language predicates. However , rather than using an external parser ( Reddy et al . , 2014 , 2016 ) or manually specified CCG grammars ( Kwiatkowski et al . , 2013 ) , we induce intermediate representations in the form of predicate-argument structures from data . This is achieved with a transition-based approach which by design yields recursive semantic structures , avoiding the problem of generating ill-formed meaning representations . Compared to most existing semantic parsers which employ a CKY style bottom-up parsing strategy ( Krishnamurthy and Mitchell , 2012 ; Cai and Yates , 2013 ; Berant et al . , 2013 ; Berant and Liang , 2014 ) , the transition-based approach we proposed does not require feature decomposition over structures and thereby enables the exploration of rich , non-local features . The output of the transition system is then grounded ( e.g., to a knowledge base ) with a neural mapping model under the assumption that grounded and ungrounded structures are isomorphic.2 As a result, we obtain a neural model that jointly learns to parse natural language semantics and induce a lexicon that helps grounding. The whole network is trained end-to-end on natural language utterances paired with annotated logical forms or their denotations. We conduct experiments on four datasets , including GEOQUERY ( which has logical forms ; Zelle and Mooney 1996 ) , SPADES ( Bisk et al . , 2016 ) , WEB-QUESTIONS ( Berant et al . , 2013 ) , and GRAPH-QUESTIONS ( Su et al . , 2016 ) ( which have denotations ) . Our semantic parser achieves the state of the art on SPADES and GRAPHQUESTIONS , while obtaining competitive results on GEOQUERY and WEBQUESTIONS . A side-product of our modeling framework is that the induced intermediate representations can contribute to rationalizing neural predictions ( Lei et al., 2016 ). Specifically, they can shed light on the kinds of representations ( especially predicates ) useful for semantic parsing. Evaluation of the induced predicate-argument relations against syntax-based ones reveals that they are interpretable and meaningful compared to heuristic baselines, but they sometimes deviate from linguistic conventions. 2 Preliminaries Problem Formulation Let K denote a knowledge base or more generally a reasoning system, and x an utterance paired with a grounded meaning representationG or its denotation y. Our problem is to learn a semantic parser that maps x to G via an intermediate ungrounded representation U . When G is executed against K, it outputs denotation y. Grounded Meaning Representation. We represent grounded meaning representations in FunQL ( Kate et al . , 2005 ) amongst many other alternatives such as lambda calculus ( Zettlemoyer and Collins , 2005 ) , λ-DCS ( Liang , 2013 ) or graph queries ( Holzschuher and Peinl , 2013 ; Harris et al . , 2013 ) . FunQL is a variable-free query language , where each predicate is treated as a function symbol that modifies an argument list . For example , the FunQL representation for the utterance which states do not border texas is : where next to is a domain-specific binary predicate that takes one argument ( i.e . , the entity texas ) and returns a set of entities ( e.g . , the states bordering Texas ) as its denotation . all is a special predicate that returns a collection of entities. exclude is a predicate that returns the difference between two input sets. An advantage of FunQL is that the resulting s-expression encodes semantic compositionality and derivation of the logical forms . This property makes FunQL logical forms convenient to be predicted with recurrent neural networks ( Vinyals et al . , 2015 ; Choe and Charniak , 2016 ; Dyer et al . , 2016 ) . However , FunQL is less expressive than lambda calculus , partially due to the elimination of variables . A more compact logical formulation which our method also applies to is λ-DCS ( Liang, 2013 ). In the absence of anaphora and composite binary predicates , conversion algorithms exist between FunQL and λ-DCS . However, we leave this to future work. Ungrounded Meaning Representation. We also use FunQL to express ungrounded meaning representations . The latter consist primarily of natural language predicates and domain-general predicates. Assuming for simplicity that domaingeneral predicates share the same vocabulary in ungrounded and grounded representations, the ungrounded representation for the example utterance is: answer( exclude( states( all ), border( texas ) ) ) where states and border are natural language predicates. In this work we consider five types of domain-general predicates illustrated in Table 1. Notice that domain-general predicates are often implicit, or represent extra-sentential knowledge. For example, the predicate all in the above utterance represents all states in the domain which are not mentioned in the utterance but are critical for working out the utterance denotation. Finally, note that for certain domain-general predicates, it also makes sense to extract natural language rationales ( e.g., not is indicative for exclude ). But we do not find this helpful in experiments. In this work we constrain ungrounded representations to be structurally isomorphic to grounded ones. In order to derive the target logical forms, all we have to do is replacing predicates in the ungrounded representations with symbols in the knowledge base. 3 Modeling In this section, we discuss our neural model which maps utterances to target logical forms. The semantic parsing task is decomposed in two stages: we first explain how an utterance is converted to an intermediate representation ( Section 3.1 ), and then describe how it is grounded to a knowledge base ( Section 3.2 ). 3.1 Generating Ungrounded Representations At this stage , utterances are mapped to intermediate representations with a transition-based algorithm . In general, the transition system generates the representation by following a derivation tree ( which contains a set of applied rules ) and some canonical generation order ( e.g., depth-first ). For FunQL , a simple solution exists since the representation itself encodes the derivation . Consider again answer( exclude( states( all ), border( texas ) ) ) which is tree structured. Each predicate ( e.g., border ) can be visualized as a non-terminal node of the tree and each entity ( e.g., texas ) as a terminal. The predicate all is a special case which acts as a terminal directly. We can generate the tree with a top-down , depth first transition system reminiscent of recurrent neural network grammars ( RNNGs ; Dyer et al . 2016 ) . Similar to RNNG , our algorithm uses a buffer to store input tokens in the utterance and a stack to store partially completed trees . A major difference in our semantic parsing scenario is that tokens in the buffer are not fetched in a sequential order or removed from the buffer. This is because the lexical alignment between an utterance and its semantic representation is hidden. Moreover, some predicates cannot be clearly anchored to a token span. Therefore, we allow the generation algorithm to pick tokens and combine logical forms in arbitrary orders, conditioning on the entire set of sentential features. Alternative solutions in the traditional semantic parsing literature include a floating chart parser ( Pasupat and Liang, 2015 ) which allows to construct logical predicates out of thin air. Our transition system defines three actions, namely NT, TER, and RED, explained below. NT( X ) generates a Non-Terminal predicate. This predicate is either a natural language expression such as border, or one of the domain-general predicates exemplified in Table 1 ( e.g., exclude ). The type of predicate is determined by the placeholder X and once generated, it is pushed onto the stack and represented as a non-terminal followed by an open bracket ( e.g., ‘border( ’ ). The open bracket will be closed by a reduce operation. TER( X ) generates a TERminal entity or the special predicate all. Note that the terminal choice does not include variable ( e.g . , $0 , $1 ) , since FunQL is a variable-free language which sufficiently captures the semantics of the datasets we work with . The framework could be extended to generate directly acyclic graphs by incorporating variables with additional transition actions for handling variable mentions and co-reference. RED stands for REDuce and is used for subtree completion. It recursively pops elements from the stack until an open non-terminal node is encountered. The non-terminal is popped as well, after which a composite term representing the entire subtree, e.g., border( texas ), is pushed back to the stack. If a RED action results in having no more open non-terminals left on the stack, the transition system terminates. Table 2 shows the transition actions used to generate our running example. The model generates the ungrounded representation U conditioned on utterance x by recursively calling one of the above three actions. Note that U is defined by a sequence of actions ( denoted by a ) and a sequence of term choices ( denoted by u ) as shown in Table 2. The conditional probability p( U |x ) is factorized over time steps as: where I is an indicator function. To predict the actions of the transition system , we encode the input buffer with a bidirectional LSTM ( Hochreiter and Schmidhuber , 1997 ) and the output stack with a stack-LSTM ( Dyer et al . , 2015 ) . At each time step, the model uses the representation of the transition system et to predict an action: where et is the concatenation of the buffer representation bt and the stack representation st. While the stack representation st is easy to retrieve as the top state of the stack-LSTM , obtaining the buffer representation bt is more involved . This is because we do not have an explicit buffer representation due to the non-projectivity of semantic parsing. We therefore compute at each time step an adaptively weighted representation of bt ( Bahdanau et al., 2015 ) conditioned on the stack representation st. This buffer representation is then concatenated with the stack representation to form the system representation et. When the predicted action is either NT or TER, an ungrounded term ut ( either a predicate or an entity ) needs to be chosen from the candidate list depending on the specific placeholder X. To select a domain-general term, we use the same representation of the transition system et to compute a probability distribution over candidate terms. To choose a natural language term, we directly compute a probability distribution of all natural language terms ( in the buffer ) conditioned on the stack representation st and select the most relevant term ( Jia and Liang, 2016 ). When the predicted action is RED, the completed subtree is composed into a single representation on the stack. For the choice of composition function, we use a single-layer neural network as in Dyer et al. ( 2015 ), which takes as input the concatenated representation of the predicate and argument of the subtree. 3.2 Generating Grounded Representations Since we constrain the network to learn ungrounded structures that are isomorphic to the target meaning representation, converting ungrounded representations to grounded ones becomes a simple lexical mapping problem. For simplicity, hereafter we do not differentiate natural language and domain-general predicates. To map an ungrounded term ut to a grounded term gt , we compute the conditional probability of gt given ut with a bi-linear neural network : where ~ ut is the contextual representation of the ungrounded term given by the bidirectional LSTM , ~ gt is the grounded term embedding , and Wug is the weight matrix . The above grounding step can be interpreted as learning a lexicon: the model exclusively relies on the intermediate representation U to predict the target meaning representation G without taking into account any additional features based on the utterance. In practice , U may provide sufficient contextual background for closed domain semantic parsing where an ungrounded predicate often maps to a single grounded predicate , but is a relatively impoverished representation for parsing large open-domain knowledge bases like Freebase . In this case, we additionally rely on a discriminative reranker which ranks the grounded representations derived from ungrounded representations ( see Section 3.4 ). 3.3 Training Objective When the target meaning representation is available, we directly compare it against our predictions and back-propagate. When only denotations are available, we compare surrogate meaning representations against our predictions ( Reddy et al., 2014 ). Surrogate representations are those with the correct denotations. When there exist multi-ple surrogate representations,3 we select one randomly and back-propagate. The global effect of the above update rule is close to maximizing the marginal likelihood of denotations, which differs from recent work on weakly-supervised semantic parsing based on reinforcement learning ( Neelakantan et al., 2017 ). Consider utterance x with ungrounded meaning representation U , and grounded meaning representation G. Both U and G are defined with a sequence of transition actions ( same for U and G ) and a sequence of terms ( different for U and G ). Recall that a = [a1, · · · , an] denotes the transition action sequence defining U and G; let u = [u1, · · · , uk] denote the ungrounded terms ( e.g., predicates ), and g = [g1, · · · , gk] the grounded terms. We aim to maximize the likelihood of the grounded meaning representation p( G|x ) over all training examples. This likelihood can be decomposed into the likelihood of the grounded action sequence p( a|x ) and the grounded term sequence p( g|x ), which we optimize separately. For the grounded action sequence ( which by design is the same as the ungrounded action sequence and therefore the output of the transition system ), we can directly maximize the log likelihood log p( a|x ) for all examples: where T denotes examples in the training data. For the grounded term sequence g, since the intermediate ungrounded terms are latent, we maximize the expected log likelihood of the grounded terms ∑ u [p( u|x ) log p( g|u, x )] for all examples, which is a lower bound of the log likelihood log p( g|x ). The final objective is the combination of La and Lg, denoted as LG = La + Lg. We optimize this objective with the method described in Lei et al. ( 2016 ). 3.4 Reranker As discussed above, for open domain semantic parsing, solely relying on the ungrounded representation would result in an impoverished model lacking sentential context useful for disambiguation decisions. For all Freebase experiments, we followed previous work ( Berant et al., 2013; Berant and Liang, 2014; Reddy et al., 2014 ) in additionally training a discriminative ranker to re-rank grounded representations globally. The discriminative ranker is a maximumentropy model ( Berant et al . , 2013 ) . The objective is to maximize the log likelihood of the correct answer y given x by summing over all grounded candidates G with denotation y ( i.e.,[[G]]K = y ): where f( G, x ) is a feature function that maps pair ( G, x ) into a feature vector. We give details on the features we used in Section 4.2. 4 Experiments In this section, we verify empirically that our semantic parser derives useful meaning representations. We give details on the evaluation datasets and baselines used for comparison. We also describe implementation details and the features used in the discriminative ranker . 4.1 Datasets We evaluated our model on the following datasets which cover different domains, and use different types of training data, i.e., pairs of natural language utterances and grounded meanings or question-answer pairs. GEOQUERY ( Zelle and Mooney , 1996 ) contains 880 questions and database queries about US geography . The utterances are compositional, but the language is simple and vocabulary size small. The majority of questions include at most one entity. SPADES ( Bisk et al . , 2016 ) contains 93,319 questions derived from CLUEWEB09 ( Gabrilovich et al . , 2013 ) sentences . Specifically, the questions were created by randomly removing an entity, thus producing sentence-denotation pairs ( Reddy et al., 2014 ). The sentences include two or more entities and although they are not very compositional, they constitute a large-scale dataset for neural network training. WEBQUESTIONS ( Berant et al . , 2013 ) contains 5,810 question-answer pairs . Similar to SPADES , it is based on Freebase and the questions are not very compositional . However, they are real questions asked by people on the Web. Finally , GRAPHQUESTIONS ( Su et al . , 2016 ) contains 5,166 question-answer pairs which were created by showing 500 Freebase graph queries to Amazon Mechanical Turk workers and asking them to paraphrase them into natural language . Amongst the four datasets described above , GEO-QUERY has annotated logical forms which we directly use for training . For the other three datasets, we treat surrogate meaning representations which lead to the correct answer as gold standard. The surrogates were selected from a subset of candidate Freebase graphs, which were obtained by entity linking. Entity mentions in SPADES have been automatically annotated with Freebase entities ( Gabrilovich et al . , 2013 ) . For WEBQUESTIONS and GRAPHQUESTIONS , we follow the procedure described in Reddy et al . ( 2016 ) . We identify potential entity spans using seven handcrafted part-of-speech patterns and associate them with Freebase entities obtained from the Freebase / KG API . We use a structured perceptron trained on the entities found in WEBQUESTIONS and GRAPHQUES-TIONS to select the top 10 non-overlapping entity disambiguation possibilities . We treat each possibility as a candidate input utterance, and use the perceptron score as a feature in the discriminative reranker, thus leaving the final disambiguation to the semantic parser. Apart from the entity score , the discriminative ranker uses the following basic features . The first feature is the likelihood score of a grounded representation aggregating all intermediate representations. The second set of features include the embedding similarity between the relation and the utterance, as well as the similarity between the relation and the question words. The last set of features includes the answer type as indicated by the last word in the Freebase relation ( Xu et al . , 2016 ) . We used the Adam optimizer for training with an initial learning rate of 0.001 , two momentum parameters [ 0.99 , 0.999 ] , and batch size 1 . The dimensions of the word embeddings , LSTM states , entity embeddings and relation embeddings are [ 50 , 100 , 100 , 100 ] . The word embeddings were initialized with Glove embeddings ( Pennington et al . , 2014 ) . All other embeddings were randomly initialized. 4.3 Results Experimental results on the four datasets are summarized in Tables 3–6. We present comparisons of our system which we call SCANNER ( as a shorthand for SymboliC meANiNg rEpResentation ) against a variety of models previously described in the literature . GEOQUERY results are shown in Table 5 . The first block contains symbolic systems, whereas neural models are presented in the second block. We report accuracy which is defined as the proportion of the utterance that are correctly parsed to their gold standard logical forms . All previous neural systems ( Dong and Lapata , 2016 ; Jia and Liang , 2016 ) treat semantic parsing as a sequence transduction problem and use LSTMs to directly map utterances to logical forms . SCAN-NER yields performance improvements over these systems when using comparable data sources for training . Jia and Liang ( 2016 ) achieve better results with synthetic data that expands GEO-QUERY ; we could adopt their approach to improve model performance , however , we leave this to future work . Table 6 reports SCANNER ’ s performance on SPADES . For all Freebase related datasets we use average F1 ( Berant et al . , 2013 ) as our evaluation metric . Previous work on this dataset has used a semantic parsing framework similar to ours where natural language is converted to an intermediate syntactic representation and then grounded to Freebase . Specifically, Bisk et al. ( 2016 ) evaluate the effectiveness of four different CCG parsers on the semantic parsing task when varying the amount of supervision required. As can be seen , SCANNER outperforms all CCG variants ( from unsupervised to fully supervised ) without having access to any manually annotated derivations or lexicons . For fair comparison, we also built a neural baseline that encodes an utterance with a recurrent neural network and then predicts a grounded meaning representation directly ( Ture and Jojic, 2016; Yih et al., 2016 ). Again , we observe that SCANNER outperforms this baseline . Results on WEBQUESTIONS are summarized in Table 3 . SCANNER obtains performance on par with the best symbolic systems ( see the first block in the table ) . It is important to note that Bast and Haussmann ( 2015 ) develop a question answering system, which contrary to ours cannot produce meaning representations whereas Berant and Liang ( 2015 ) propose a sophisticated agenda-based parser which is trained borrowing ideas from imitation learning. SCANNER is conceptually similar to Reddy et al . ( 2016 ) who also learn a semantic parser via intermediate representations which they generate based on the output of a dependency parser . SCANNER performs competitively despite not having access to any linguistically-informed syntactic structures . The second block in Table 3 reports the results of several neural systems. Xu et al . ( 2016 ) represent the state of the art on WEBQUESTIONS . Their system uses Wikipedia to prune out erroneous candidate answers extracted from Freebase . Our model would also benefit from a similar post-processing step. As in previous experiments , SCANNER outperforms the neural baseline , too . Finally , Table 4 presents our results on GRAPHQUESTIONS . We report F1 for SCANNER , the neural baseline model , and three symbolic systems presented in Su et al . ( 2016 ) . SCANNER achieves a new state of the art on this dataset with a gain of 4.23 F1 points over the best previously reported model . 4.4 Analysis of Intermediate Representations Since a central feature of our parser is that it learns intermediate representations with natural language predicates, we conducted additional experiments in order to inspect their quality. For GEOQUERY which contains only 280 test examples , we manually annotated intermediate representations for the test instances and evaluated the learned representations against them . The experimental setup aims to shows how humans can participate in improving the semantic parser with feedback at the intermediate stage. In terms of evaluation, we use three metrics shown in Table 7. The first row shows the percentage of exact matches between the predicted representations and the human annotations. The second row refers to the percentage of structure matches, where the predicted representations have the same structure as the human annotations, but may not use the same lexical terms. Among structurally correct predictions, we additionally compute how many tokens are correct, as shown in the third row. As can be seen, the induced meaning representations overlap to a large extent with the human gold standard. We also evaluated the intermediate representations created by SCANNER on the other three ( Freebase ) datasets . Since creating a manual gold standard for these large datasets is time-consuming, we compared the induced representations against the output of a syntactic parser. Specifically , we converted the questions to event-argument structures with EASY-CCG ( Lewis and Steedman , 2014 ) , a high coverage and high accuracy CCG parser . EASYCCG extracts predicate-argument structures with a labeled F-score of 83.37% . For further comparison, we built a simple baseline which identifies predicates based on the output of the Stanford POStagger ( Manning et al., 2014 ) following the ordering VBD\u001dVBN\u001dVB\u001dVBP\u001dVBZ\u001dMD. As shown in Table 8 , on SPADES and WE-BQUESTIONS , the predicates learned by our model match the output of EASYCCG more closely than the heuristic baseline . But for GRAPHQUESTIONS which contains more compositional questions , the mismatch is higher . However, since the key idea of our model is to capture salient meaning for the task at hand rather than strictly obey syntax, we would not expect the predicates induced by our system to entirely agree with those produced by the syntactic parser. To further analyze how the learned predicates differ from syntax-based ones , we grouped utterances in SPADES into four types of linguistic constructions : coordination ( conj ) , control and raising ( control ) , prepositional phrase attachment ( pp ) , and subordinate clauses ( subord ) . Table 8 also shows the breakdown of matching scores per linguistic construction, with the number of utterances in each type. In Table 9 , we provide examples of predicates identified by SCANNER , indicating whether they agree or not with the output of EASYCCG . As a reminder , the task in SPADES is to predict the entity masked by a blank symbol ( ) . As can be seen in Table 8, the matching score is relatively high for utterances involving coordination and prepositional phrase attachments. The model will often identify informative predicates ( e.g., nouns ) which do not necessarily agree with linguistic intuition. For example , in the utterance wilhelm maybach and his son started maybach in 1909 ( see Table 9 ) , SCANNER identifies the predicateargument structure son ( wilhelm maybach ) rather than started ( wilhelm maybach ) . We also observed that the model struggles with control and subordinate constructions. It has difficulty distinguishing control from raising predicates as exemplified in the utterance ceo john thain agreed to leave from Table 9, where it identifies the raising predicate agreed. For subordinate clauses , SCANNER tends to take shortcuts identifying as predicates words closest to the blank symbol . 5 Discussion We presented a neural semantic parser which converts natural language utterances to grounded meaning representations via intermediate predicate-argument structures. Our model essentially jointly learns how to parse natural language semantics and the lexicons that help grounding. Compared to previous neural semantic parsers, our model is more interpretable as the intermediate structures are useful for inspecting what the model has learned and whether it matches linguistic intuition. An assumption our model imposes is that ungrounded and grounded representations are structurally isomorphic. An advantage of this assumption is that tokens in the ungrounded and grounded representations are strictly aligned. This allows the neural network to focus on parsing and lexical mapping, sidestepping the challenging structure mapping problem which would result in a larger search space and higher variance. On the negative side, the structural isomorphism assumption restricts the expressiveness of the model, especially since one of the main benefits of adopting a two-stage parser is the potential of capturing domain-independent semantic information via the intermediate representation. While it would be challenging to handle drastically non-isomorphic structures in the current model, it is possible to perform local structure matching, i.e., when the mapping between natural language and domainspecific predicates is many-to-one or one-to-many. For instance , Freebase does not contain a relation representing daughter , using instead two relations representing female and child . Previous work ( Kwiatkowski et al., 2013 ) models such cases by introducing collapsing ( for many-to-one mapping ) and expansion ( for one-to-many mapping ) operators. Within our current framework, these two types of structural mismatches can be handled with semi-Markov assumptions ( Sarawagi and Cohen, 2005; Kong et al., 2016 ) in the parsing ( i.e., predicate selection ) and the grounding steps, respectively. Aside from relaxing strict isomorphism, we would also like to perform cross-domain semantic parsing where the first stage of the semantic parser is shared across domains. "}
  },
    {
    "id": "P17-1006",
    "result":     [
            {
        "value":         {
          "start": 151,
          "end": 184,
          "text": "distributional vector space models",
          "labels": ["Method"]
        },
        "id": 1213
      },
            {
        "value":         {
          "start": 2334,
          "end": 2367,
          "text": "distributional vector space models",
          "labels": ["Method"]
        },
        "id": 1213
      },
            {
        "value":         {
          "start": 5944,
          "end": 5967,
          "text": "neural-network DST model",
          "labels": ["Method"]
        },
        "id": 1213
      },
            {
        "value":         {
          "start": 6496,
          "end": 6528,
          "text": "Multilingual SimLex - 999 dataset",
          "labels": ["Dataset"]
        },
        "id": 1214
      },
            {
        "value":         {
          "start": 6622,
          "end": 6631,
          "text": "Wikipedias",
          "labels": ["Dataset"]
        },
        "id": 1215
      },
            {
        "value":         {
          "start": 6919,
          "end": 6941,
          "text": "ATTRACT-REPEL algorithm",
          "labels": ["Method"]
        },
        "id": 1215
      },
            {
        "value":         {
          "start": 7004,
          "end": 7022,
          "text": "ATTRACT-REPEL model",
          "labels": ["Method"]
        },
        "id": 1216
      },
            {
        "value":         {
          "start": 9685,
          "end": 9691,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 9719,
          "end": 9737,
          "text": "Paraphrase Database",
          "labels": ["Dataset"]
        },
        "id": 1217
      },
            {
        "value":         {
          "start": 9801,
          "end": 9808,
          "text": "BabelNet",
          "labels": ["Dataset"]
        },
        "id": 1218
      },
            {
        "value":         {
          "start": 10237,
          "end": 10249,
          "text": "ATTRACT-REPEL",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 14167,
          "end": 14213,
          "text": "skip-gram with negative sampling ( SGNS ) model",
          "labels": ["Method"]
        },
        "id": 1220
      },
            {
        "value":         {
          "start": 14256,
          "end": 14264,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 14756,
          "end": 14773,
          "text": "Common-Crawl GloVe",
          "labels": ["Method"]
        },
        "id": 1221
      },
            {
        "value":         {
          "start": 14807,
          "end": 14810,
          "text": "SGNS",
          "labels": ["Method"]
        },
        "id": 1222
      },
            {
        "value":         {
          "start": 14871,
          "end": 14873,
          "text": "BOW",
          "labels": ["Method"]
        },
        "id": 1223
      },
            {
        "value":         {
          "start": 14877,
          "end": 14888,
          "text": "bag-of-words",
          "labels": ["Method"]
        },
        "id": 1302
      },
            {
        "value":         {
          "start": 14948,
          "end": 14965,
          "text": "Polyglot Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1224
      },
            {
        "value":         {
          "start": 15020,
          "end": 15027,
          "text": "word2vec",
          "labels": ["Method"]
        },
        "id": 1273
      },
            {
        "value":         {
          "start": 15251,
          "end": 15253,
          "text": "SVD",
          "labels": ["Method"]
        },
        "id": 1260
      },
            {
        "value":         {
          "start": 15283,
          "end": 15291,
          "text": "Count-SVD",
          "labels": ["Method"]
        },
        "id": 1226
      },
            {
        "value":         {
          "start": 15356,
          "end": 15359,
          "text": "CBOW",
          "labels": ["Method"]
        },
        "id": 1227
      },
            {
        "value":         {
          "start": 15366,
          "end": 15384,
          "text": "bidirectional LSTMs",
          "labels": ["Method"]
        },
        "id": 1228
      },
            {
        "value":         {
          "start": 15506,
          "end": 15511,
          "text": "BiSkip",
          "labels": ["Method"]
        },
        "id": 1229
      },
            {
        "value":         {
          "start": 15542,
          "end": 15549,
          "text": "MultiCCA",
          "labels": ["Method"]
        },
        "id": 1230
      },
            {
        "value":         {
          "start": 16966,
          "end": 16994,
          "text": "Spearman ’ s rank correlation",
          "labels": ["Metric"]
        },
        "id": 1231
      },
            {
        "value":         {
          "start": 17042,
          "end": 17061,
          "text": "SimLex - 999 dataset",
          "labels": ["Dataset"]
        },
        "id": 1232
      },
            {
        "value":         {
          "start": 17076,
          "end": 17089,
          "text": "SimVerb - 3500",
          "labels": ["Dataset"]
        },
        "id": 1233
      },
            {
        "value":         {
          "start": 17187,
          "end": 17198,
          "text": "SimLex - 999",
          "labels": ["Dataset"]
        },
        "id": 1247
      },
            {
        "value":         {
          "start": 17566,
          "end": 17571,
          "text": "SimLex",
          "labels": ["Dataset"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 17577,
          "end": 17583,
          "text": "SimVerb",
          "labels": ["Dataset"]
        },
        "id": 1237
      },
            {
        "value":         {
          "start": 18011,
          "end": 18017,
          "text": "SimVerb",
          "labels": ["Dataset"]
        },
        "id": 1237
      },
            {
        "value":         {
          "start": 18070,
          "end": 18080,
          "text": "Context2vec",
          "labels": ["Method"]
        },
        "id": 1237
      },
            {
        "value":         {
          "start": 19289,
          "end": 19301,
          "text": "ATTRACT-REPEL",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 19390,
          "end": 19402,
          "text": "ATTRACT-REPEL",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 19859,
          "end": 19871,
          "text": "ATTRACT-REPEL",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 23142,
          "end": 23166,
          "text": "conditional random fields",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 23482,
          "end": 23502,
          "text": "Neural Belief Tracker",
          "labels": ["Method"]
        },
        "id": 1238
      },
            {
        "value":         {
          "start": 23798,
          "end": 23826,
          "text": "Neural Belief Tracker ( NBT )",
          "labels": ["Method"]
        },
        "id": 1239
      },
            {
        "value":         {
          "start": 23962,
          "end": 23964,
          "text": "NBT",
          "labels": ["Method"]
        },
        "id": 1241
      },
            {
        "value":         {
          "start": 24171,
          "end": 24173,
          "text": "NBT",
          "labels": ["Method"]
        },
        "id": 1241
      },
            {
        "value":         {
          "start": 24343,
          "end": 24370,
          "text": "Multilingual WOZ 2.0 Dataset",
          "labels": ["Dataset"]
        },
        "id": 1241
      },
            {
        "value":         {
          "start": 24409,
          "end": 24419,
          "text": "WOZ dataset",
          "labels": ["Dataset"]
        },
        "id": 1242
      },
            {
        "value":         {
          "start": 24685,
          "end": 24689,
          "text": "DSTC2",
          "labels": ["Dataset"]
        },
        "id": 1243
      },
            {
        "value":         {
          "start": 24818,
          "end": 24830,
          "text": "DSTC datasets",
          "labels": ["Dataset"]
        },
        "id": 1244
      },
            {
        "value":         {
          "start": 24993,
          "end": 24999,
          "text": "WOZ 2.0",
          "labels": ["Dataset"]
        },
        "id": 1245
      },
            {
        "value":         {
          "start": 25264,
          "end": 25271,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 25457,
          "end": 25466,
          "text": "NBT models",
          "labels": ["Method"]
        },
        "id": 1247
      },
            {
        "value":         {
          "start": 25855,
          "end": 25866,
          "text": "SimLex - 999",
          "labels": ["Dataset"]
        },
        "id": 1247
      },
            {
        "value":         {
          "start": 26226,
          "end": 26235,
          "text": "NBT models",
          "labels": ["Method"]
        },
        "id": 1247
      },
            {
        "value":         {
          "start": 27378,
          "end": 27384,
          "text": "Sim-Lex",
          "labels": ["Metric"]
        },
        "id": 1247
      },
            {
        "value":         {
          "start": 27499,
          "end": 27504,
          "text": "SimLex",
          "labels": ["Metric"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 27609,
          "end": 27614,
          "text": "SimLex",
          "labels": ["Metric"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 27867,
          "end": 27872,
          "text": "SimLex",
          "labels": ["Metric"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 27953,
          "end": 27958,
          "text": "SimLex",
          "labels": ["Metric"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 29745,
          "end": 29749,
          "text": "CELEX",
          "labels": ["Dataset"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 29812,
          "end": 29820,
          "text": "Morfessor",
          "labels": ["Method"]
        },
        "id": 1248
      },
            {
        "value":         {
          "start": 31137,
          "end": 31165,
          "text": "generative Bayesian framework",
          "labels": ["Method"]
        },
        "id": 1249
      },
            {
        "value":         {
          "start": 31446,
          "end": 31452,
          "text": "WordNet",
          "labels": ["Dataset"]
        },
        "id": 1250
      }
    ],
    "data": {"text": "Morph-fitting: Fine-Tuning Word Vector Spaces with Simple Language-Specific Rules Abstract Morphologically rich languages accentuate two properties of distributional vector space models : 1 ) the difficulty of inducing accurate representations for low-frequency word forms ; and 2 ) insensitivity to distinct lexical relations that have similar distributional signatures . These effects are detrimental for language understanding systems, which may infer that inexpensive is a rephrasing for expensive or may not associate acquire with acquires. In this work, we propose a novel morph-fitting procedure which moves past the use of curated semantic lexicons for improving distributional vector spaces. Instead, our method injects morphological constraints generated using simple language-specific rules, pulling inflectional forms of the same word close together and pushing derivational antonyms far apart. In intrinsic evaluation over four languages, we show that our approach: 1 ) improves low-frequency word estimates; and 2 ) boosts the semantic quality of the entire word vector collection. Finally, we show that morph-fitted vectors yield large gains in the downstream task of dialogue state tracking, highlighting the importance of morphology for tackling long-tail phenomena in language understanding tasks. 1 Introduction Word representation learning has become a research area of central importance in natural language processing ( NLP ), with its usefulness demonstrated across many application areas such as parsing ( Chen and Manning, 2014; Johannsen et al., 2015 ), machine translation ( Zou et al., 2013 ), and many others ( Turian et al., 2010; Collobert et al., 2011 ). Most prominent word representation techniques are grounded in the distributional hypothesis ( Harris, 1954 ), relying on word co-occurrence information in large textual corpora ( Curran, 2004; Turney and Pantel, 2010; Mikolov et al., 2013; Mnih and Kavukcuoglu, 2013; Levy and Goldberg, 2014; Schwartz et al., 2015, i.a. ). Morphologically rich languages, in which “substantial grammatical information. . . is expressed at word level” ( Tsarfaty et al., 2010 ), pose specific challenges for NLP. This is not always considered when techniques are evaluated on languages such as English or Chinese, which do not have rich morphology. In the case of distributional vector space models , morphological complexity brings two challenges to the fore : Estimating Rare Words: A single lemma can have many different surface realisations. Naively treating each realisation as a separate word leads to sparsity problems and a failure to exploit their shared semantics. On the other hand, lemmatising the entire corpus can obfuscate the differences that exist between different word forms even though they share some aspects of meaning. Embedded Semantics: Morphology can encode semantic relations such as antonymy ( e.g. literate and illiterate, expensive and inexpensive ) or ( near- )synonymy ( north, northern, northerly ). In this work, we tackle the two challenges jointly by introducing a resource-light vector space finetuning procedure termed morph-fitting. The proposed method does not require curated knowledge bases or gold lexicons. Instead, it makes use of the observation that morphology implicitly encodes semantic signals pertaining to synonymy ( e.g., German word inflections katalanisch, katalanischem, katalanischer denote the same semantic concept in different grammatical roles ), and antonymy ( e.g., mature vs. immature ), capitalising on the proliferation of word forms in morphologically rich languages. Formalised as an instance of the post-processing semantic specialisation paradigm ( Faruqui et al., 2015; Mrkšic´ et al., 2016 ), morphfitting is steered by a set of linguistic constraints derived from simple language-specific rules which describe ( a subset of ) morphological processes in a language. The constraints emphasise similarity on one side ( e.g., by extracting morphological synonyms ), and antonymy on the other ( by extracting morphological antonyms ), see Fig. 1 and Tab. 2. The key idea of the fine-tuning process is to pull synonymous examples described by the constraints closer together in the transformed vector space, while at the same time pushing antonymous examples away from each other. The explicit post-hoc injection of morphological constraints enables: a ) the estimation of more accurate vectors for low-frequency words which are linked to their high-frequency forms by the constructed constraints;1 this tackles the data sparsity problem; and b ) specialising the distributional space to distinguish between similarity and relatedness ( Kiela et al., 2015 ), thus supporting language understanding applications such as dialogue state tracking ( DST ).2 As a post-processor, morph-fitting allows the integration of morphological rules with any distributional vector space in any language: it treats an input distributional word vector space as a black box and fine-tunes it so that the transformed space reflects the knowledge coded in the input morphological constraints ( e.g., Italian words rispettoso and irrispetosa should be far apart in the transformed vector space, see Fig. 1 ). Tab. 1 illustrates the effects of morph-fitting by qualitative examples in three languages: the vast majority of nearest neighbours are “morphological” synonyms. We demonstrate the efficacy of morph-fitting in four languages ( English, German, Italian, Russian ), yielding large and consistent improvements on benchmarking word similarity evaluation sets such as SimLex-999 ( Hill et al., 2015 ), its multilingual extension ( Leviant and Reichart, 2015 ), and SimVerb-3500 ( Gerz et al., 2016 ). The improvements are reported for all four languages, and with a variety of input distributional spaces, verifying the robustness of the approach. We then show that incorporating morph-fitted vectors into a state-of-the-art neural-network DST model results in improved tracking performance , especially for morphologically rich languages . We report an improvement of 4% on Italian, and 6% on German when using morph-fitted vectors instead of the distributional ones, setting a new state-of-the-art DST performance for the two datasets.3 2 Morph-fitting: Methodology Preliminaries. In this work, we focus on four languages with varying levels of morphological complexity: English ( EN ), German ( DE ), Italian ( IT ), and Russian ( RU ). These correspond to languages in the Multilingual SimLex - 999 dataset . Vocabularies Wen , Wde , Wit , Wru are compiled by retaining all word forms from the four Wikipedias with word frequency over 10 , see Tab . 3 . We then extract sets of linguistic constraints from these ( large ) vocabularies using a set of simple language-specific if-then-else rules, see Tab. 2.4 These constraints ( Sect . 2.2 ) are used as input for the vector space post-processing ATTRACT-REPEL algorithm ( outlined in Sect . 2.1 ) . 2.1 The ATTRACT-REPEL Model The ATTRACT-REPEL model , proposed by Mrkšic ´ et al . ( 2017b ) , is an extension of the PARAGRAM procedure proposed by Wieting et al . ( 2015 ) . It provides a generic framework for incorporating similarity ( e.g. successful and accomplished ) and antonymy constraints ( e.g. nimble and clumsy ) into pre-trained word vectors. Given the initial vector space and collections of ATTRACT and REPEL constraints A and R, the model gradually modifies the space to bring the designated word vectors closer together or further apart. The method’s cost function consists of three terms. The first term pulls the ATTRACT examples ( xl, xr ) ∈ A closer together. If BA denotes the current mini-batch of ATTRACT examples, this term can be expressed as: where δatt is the similarity margin which determines how much closer synonymous vectors should be to each other than to each of their respective negative examples. ReLU( x ) = max( 0, x ) is the standard rectified linear unit ( Nair and Hinton, 2010 ). The ‘negative’ example ti for each word xi in any ATTRACT pair is the word vector closest to xi among the examples in the current minibatch ( distinct from its target synonym and xi itself ). This means that this term forces synonymous words from the in-batch ATTRACT constraints to be closer to one another than to any other word in the current mini-batch. The second term pushes antonyms away from each other. If ( xl, xr ) ∈ BR is the current minibatch of REPEL constraints, this term can be expressed as follows. In this case, each word’s ‘negative’ example is the ( in-batch ) word vector furthest away from it ( and distinct from the word’s target antonym ). The intuition is that we want antonymous words from the input REPEL constraints to be further away from each other than from any other word in the current mini-batch; δrpl is now the repel margin. The final term of the cost function serves to retain the abundance of semantic information encoded in the starting distributional space. If xiniti is the initial distributional vector and V ( B ) is the set of all vectors present in the given mini-batch, this term ( per mini-batch ) is expressed as follows where λreg is the L2 regularisation constant.5 This term effectively pulls word vectors towards their initial ( distributional ) values, ensuring that relations encoded in initial vectors persist as long as they do not contradict the newly injected ones. 2.2 Language-Specific Rules and Constraints Semantic Specialisation with Constraints The fine-tuning ATTRACT-REPEL procedure is entirely driven by the input ATTRACT and REPEL sets of constraints. These can be extracted from a variety of semantic databases such as WordNet ( Fellbaum , 1998 ) , the Paraphrase Database ( Ganitkevitch et al . , 2013 ; Pavlick et al . , 2015 ) , or BabelNet ( Navigli and Ponzetto , 2012 ; Ehrmann et al . , 2014 ) as done in prior work ( Faruqui et al . , 2015 ; Wieting et al . , 2015 ; Mrkšic ´ et al . , 2016 , i.a . ) . In this work, we investigate another option: extracting constraints without curated knowledge bases in a spectrum of languages by exploiting inherent language-specific properties related to linguistic morphology. This relaxation ensures a wider portability of ATTRACT-REPEL to languages and domains without readily available or adequate resources . Extracting ATTRACT Pairs. The core difference between inflectional and derivational morphology can be summarised in a few lines as follows: the former refers to a set of processes through which the word form expresses meaningful syntactic information, e.g., verb tense, without any change to the semantics of the word. On the other hand, the latter refers to the formation of new words with semantic shifts in meaning ( Schone and Jurafsky, 2001; Haspelmath and Sims, 2013; Lazaridou et al., 2013; Zeller et al., 2013; Cotterell and Schütze, 2017 ). For the ATTRACT constraints, we focus on inflectional rather than on derivational morphology rules as the former preserve the full meaning of a word, modifying it only to reflect grammatical roles such as verb tense or case markers ( e.g., ( en_read, en_reads ) or ( de_katalanisch, de_katalanischer ) ). This choice is guided by our intent to fine-tune the original vector space in order to improve the embedded semantic relations. We define two rules for English, widely recognised as morphologically simple ( Avramidis and Koehn, 2008; Cotterell et al., 2016b ). These are: ( R1 ) if w1, w2 ∈Wen, where w2 = w1 + ing/ed/s, then add ( w1, w2 ) and ( w2, w1 ) to the set of AT-TRACT constraints A. This rule yields pairs such as ( look, looks ), ( look, looking ), ( look, looked ). If w[: −1] is a function which strips the last character from word w, the second rule is: ( R2 ) if w1 ends with the letter e and w1 ∈ Wen and w2 ∈ Wen, where w2 = w1[: −1] + ing/ed, then add ( w1, w2 ) and ( w2, w1 ) to A. This creates pairs such as ( create, creating ) and ( create, created ). Naturally, introducing more sophisticated rules is possible in order to cover for other special cases and morphological irregularities ( e.g., sweep / swept ), but in all our EN experiments, A is based on the two simple EN rules R1 and R2. The other three languages, with more complicated morphology, yield a larger number of rules. In Italian, we rely on the sets of rules spanning: ( 1 ) regular formation of plural ( libro / libri ); ( 2 ) regular verb conjugation ( aspettare / aspettiamo ); ( 3 ) regular formation of past participle ( aspettare / aspettato ); and ( 4 ) rules regarding grammatical gender ( bianco / bianca ). Besides these, another set of rules is used for German and Russian: ( 5 ) regular declension ( e.g., asiatisch / asiatischem ). Extracting REPEL Pairs. As another source of implicit semantic signals, W also contains words which represent derivational antonyms: e.g., two words that denote concepts with opposite meanings, generated through a derivational process. We use a standard set of EN “antonymy” prefixes: APen = {dis, il, un, in, im, ir, mis, non, anti} ( Fromkin et al., 2013 ). If w1, w2 ∈ Wen, where w2 is generated by adding a prefix from APen to w1, then ( w1, w2 ) and ( w2, w1 ) are added to the set of REPEL constraints R. This rule generates pairs such as ( advantage, disadvantage ) and ( regular, irregular ). An additional rule replaces the suffix -ful with -less, extracting antonyms such as ( careful, careless ). Following the same principle, we use APde = {un, nicht, anti, ir, in, miss}, APit = {in, ir, im, anti}, and APru = {не, анти}. For instance, this generates an IT pair ( rispettoso, irrispettoso ) ( see Fig. 1 ). For DE, we use another rule targeting suffix replacement: -voll is replaced by -los. We further expand the set of REPEL constraints by transitively combining antonymy pairs from the previous step with inflectional ATTRACT pairs. This step yields additional constraints such as ( rispettosa, irrispettosi ) ( see Fig. 1 ). The final A andR constraint counts are given in Tab. 3. The full sets of rules are available as supplemental material. 3 Experimental Setup Training Data and Setup For each of the four languages we train the skip-gram with negative sampling ( SGNS ) model ( Mikolov et al . , 2013 ) on the latest Wikipedia dump of each language . We induce 300-dimensional word vectors, with the frequency cut-off set to 10. The vocabulary sizes |W | for each language are provided in Tab. 3.6 We label these collections of vectors SGNS-LARGE. Other Starting Distributional Vectors. We also analyse the impact of morph-fitting on other collections of well-known EN word vectors. These vectors have varying vocabulary coverage and are trained with different architectures. We test standard distributional models : Common-Crawl GloVe ( Pennington et al . , 2014 ) , SGNS vectors ( Mikolov et al . , 2013 ) with various contexts ( BOW = bag-of-words ; DEPS = dependency contexts ) , and training data ( PW = Polyglot Wikipedia from Al-Rfou et al . ( 2013 ) ; 8B = 8 billion token word2vec corpus ) , following ( Levy and Goldberg , 2014 ) and ( Schwartz et al . , 2015 ) . We also test the symmetricpattern based vectors of Schwartz et al . ( 2016 ) ( SymPat-Emb ) , count-based PMI-weighted vectors reduced by SVD ( Baroni et al . , 2014 ) ( Count-SVD ) , a model which replaces the context modelling function from CBOW with bidirectional LSTMs ( Melamud et al . , 2016 ) ( Context2Vec ) , and two sets of EN vectors trained by injecting multilingual information : BiSkip ( Luong et al . , 2015 ) and MultiCCA ( Faruqui and Dyer , 2014 ) . We also experiment with standard well-known distributional spaces in other languages ( IT and DE ), available from prior work ( Dinu et al., 2015; Luong et al., 2015; Vulic´ and Korhonen, 2016a ). Morph-fixed Vectors. A baseline which utilises an equal amount of knowledge as morph-fitting, termed morph-fixing, fixes the vector of each word to the distributional vector of its most frequent inflectional synonym, tying the vectors of low-frequency words to their more frequent inflections. For each word w1, we construct a set of M + 1 words Ww1 = {w1, w′1, . . . , w′M} consisting of the word w1 itself and all M words which cooccur with w1 in the ATTRACT constraints. We then choose the word w′max from the set Ww1 with the maximum frequency in the training data, and fix all other word vectors in Ww1 to its word vector. The morph-fixed vectors ( MFIX ) serve as our primary baseline, as they outperformed another straightforward baseline based on stemming across all of our intrinsic and extrinsic experiments. Morph-fitting Variants .We analyse two variants of morph-fitting: ( 1 ) using ATTRACT constraints only ( MFIT-A ), and ( 2 ) using both AT-TRACT and REPEL constraints ( MFIT-AR ). 4 Intrinsic Evaluation: Word Similarity Evaluation Setup and Datasets. The first set of experiments intrinsically evaluates morph-fitted vector spaces on word similarity benchmarks , using Spearman ’ s rank correlation as the evaluation metric . First , we use the SimLex - 999 dataset , as well as SimVerb - 3500 , a recent EN verb pair similarity dataset providing similarity ratings for 3,500 verb pairs .7 SimLex - 999 was translated to DE , IT , and RU by Leviant and Reichart ( 2015 ) , and they crowdsourced similarity scores from native speakers . We use this dataset for our multilingual evaluation.8 Morph-fitting EN Word Vectors. As the first experiment, we morph-fit a wide spectrum of EN distributional vectors induced by various architectures ( see Sect. 3 ). The results on SimLex and SimVerb are summarised in Tab . 4 . The results with EN SGNS-LARGE vectors are shown in Fig. 3a. Morphfitted vectors bring consistent improvement across all experiments, regardless of the quality of the initial distributional space. This finding confirms that the method is robust: its effectiveness does not depend on the architecture used to construct the initial space. To illustrate the improvements , note that the best score on SimVerb for a model trained on running text is achieved by Context2vec ( ρ = 0.388 ) ; injecting morphological constraints into this vector space results in a gain of 7.1 ρ points . Experiments on Other Languages .We next extend our experiments to other languages, testing both morph-fitting variants. The results are summarised in Tab. 5, while Fig. 3a-3d show results for the morph-fitted SGNS-LARGE vectors. These scores confirm the effectiveness and robustness of morph-fitting across languages, suggesting that the idea of fitting to morphological constraints is indeed language-agnostic, given the set of language-specific rule-based constraints. Fig. 3 also demonstrates that the morph-fitted vector spaces consistently outperform the morph-fixed ones. The comparison between MFIT-A and MFIT-AR indicates that both sets of constraints are important for the fine-tuning process. MFIT-A yields consistent gains over the initial spaces, and ( consistent ) further improvements are achieved by also incorporating the antonymous REPEL constraints. This demonstrates that both types of constraints are useful for semantic specialisation. Comparison to Other Specialisation Methods. We also tried using other post-processing specialisation models from the literature in lieu of ATTRACT-REPEL using the same set of “ morphological ” synonymy and antonymy constraints . We compare ATTRACT-REPEL to the retrofitting model of ( Faruqui et al . , 2015 ) and counter-fitting ( Mrkšic ´ et al . , 2017a ) . The two baselines were trained for 20 iterations using suggested settings. The results for EN, DE, and IT are summarised in Fig. 2. They clearly indicate that MFIT-AR outperforms the two other post-processors for each language. We hypothesise that the difference in performance mainly stems from context-sensitive vector space updates performed by ATTRACT-REPEL . Conversely, the other two models perform pairwise updates which do not consider what effect each update has on the example pair’s relation to other word vectors ( for a detailed comparison, see ( Mrkšic´ et al., 2017b ) ). Besides their lower performance, the two other specialisation models have additional disadvantages compared to the proposed morph-fitting model. First, retrofitting is able to incorporate only synonymy/ATTRACT pairs, while our results demonstrate the usefulness of both types of constraints, both for intrinsic evaluation ( Tab. 5 ) and downstream tasks ( see later Fig. 3 ). Second, counter-fitting is computationally intractable with SGNS-LARGE vectors, as its regularisation term involves the computation of all pairwise distances between words in the vocabulary. Further Discussion. The simplicity of the used language-specific rules does come at a cost of occasionally generating incorrect linguistic constraints such as ( tent, intent ), ( prove, improve ) or ( press, impress ). In future work, we will study how to further refine extracted sets of constraints. We also plan to conduct experiments with gold standard morphological lexicons on languages for which such resources exist ( Sylak-Glassman et al., 2015; Cotterell et al., 2016b ), and investigate approaches which learn morphological inflections and derivations in different languages automatically as another potential source of morphological constraints ( Soricut and Och, 2015; Cotterell et al., 2016a; Faruqui et al., 2016; Kann et al., 2017; Aharoni and Goldberg, 2017, i.a. ). 5 Downstream Task: Dialogue State Tracking ( DST ) Goal-oriented dialogue systems provide conversational interfaces for tasks such as booking flights or finding restaurants. In slot-based systems, application domains are specified using ontologies that define the search constraints which users can express. An ontology consists of a number of slots and their assorted slot values. In a restaurant search domain, sets of slot-values could include PRICE = [cheap, expensive] or FOOD = [Thai, Indian, ...]. The DST model is the first component of modern dialogue pipelines ( Young, 2010 ). It serves to capture the intents expressed by the user at each dialogue turn and update the belief state. This probability distribution over the possible dialogue states ( defined by the domain ontology ) is the system’s internal estimate of the user’s goals. It is used by the downstream dialogue manager component to choose the subsequent system response ( Su et al., 2016 ). The following example shows the true dialogue state in a multi-turn dialogue: User: What’s good in the southern part of town? inform( area=south ) System: Vedanta is the top-rated Indian place. User: How about something cheaper? inform( area=south, price=cheap ) System: Seven Days is very popular. Great hot pot. User: What’s the address? inform( area=south, price=cheap ); request( address ) System: Seven Days is at 66 Regent Street. The Dialogue State Tracking Challenge ( DSTC ) shared task series formalised the evaluation and provided labelled DST datasets ( Henderson et al., 2014a,b; Williams et al., 2016 ). While a plethora of DST models are available based on , e.g . , handcrafted rules ( Wang et al . , 2014 ) or conditional random fields ( Lee and Eskenazi , 2013 ) , the recent DST methodology has seen a shift towards neuralnetwork architectures ( Henderson et al . , 2014c , d ; Zilka and Jurcicek , 2015 ; Mrkšic ´ et al . , 2015 ; Perez and Liu , 2017 ; Liu and Perez , 2017 ; Vodolán et al . , 2017 ; Mrkšic ´ et al . , 2017a , i.a . ) . Model : Neural Belief Tracker . To detect intents in user utterances, most existing models rely on either ( or both ): 1 ) Spoken Language Understanding models which require large amounts of annotated training data; or 2 ) hand-crafted, domain-specific lexicons which try to capture lexical and morphological variation. The Neural Belief Tracker ( NBT ) is a novel DST model which overcomes both issues by reasoning purely over pre-trained word vectors ( Mrkšic ´ et al . , 2017a ) . The NBT learns to compose these vectors into intermediate utterance and context representations . These are then used to decide which of the ontology-defined intents ( goals ) have been expressed by the user. The NBT model keeps word vectors fixed during training , so that unseen , yet related words can be mapped to the right intent at test time ( e.g . northern to north ) . Data : Multilingual WOZ 2.0 Dataset . Our DST evaluation is based on the WOZ dataset , released by Wen et al . ( 2017 ) . In this Wizard-of-Oz setup , two Amazon Mechanical Turk workers assumed the role of the user and the system asking / providing information about restaurants in Cambridge ( operating over the same ontology and database used for DSTC2 ( Henderson et al . , 2014a ) ) . Users typed instead of speaking, removing the need to deal with noisy speech recognition. In DSTC datasets , users would quickly adapt to the system ’ s inability to deal with complex queries . Conversely, the WOZ setup allowed them to use sophisticated language. The WOZ 2.0 release expanded the dataset to 1,200 dialogues ( Mrkšic ´ et al . , 2017a ) . In this work, we use translations of this dataset to Italian and German, released by Mrkšic´ et al. ( 2017b ). The principal metric we use to measure DST performance is the joint goal accuracy , which represents the proportion of test set dialogue turns where all user goals expressed up to that point of the dialogue were decoded correctly ( Henderson et al . , 2014a ) . The NBT models for EN , DE and IT are trained using four variants of the SGNS-LARGE vectors : 1 ) the initial distributional vectors ; 2 ) morph-fixed vectors ; 3 ) and 4 ) the two variants of morph-fitted vectors ( see Sect . 3 ) . As shown by Mrkšic´ et al. ( 2017b ), semantic specialisation of the employed word vectors benefits DST performance across all three languages. However , large gains on SimLex - 999 do not always induce correspondingly large gains in downstream performance . In our experiments, we investigate the extent to which morph-fitting improves DST performance, and whether these gains exhibit stronger correlation with intrinsic performance. Results and Discussion . The dark bars ( against the right axes ) in Fig . 3 show the DST performance of NBT models making use of the four vector collections . IT and DE benefit from both kinds of morph-fitting: IT performance increases from 74.1→ 78.1 ( MFIT-A ) and DE performance rises even more: 60.6→ 66.3 ( MFIT-AR ), setting a new state-of-the-art score for both datasets. The morph-fixed vectors do not enhance DST performance, probably because fixing word vectors to their highest frequency inflectional form eliminates useful semantic content encoded in the original vectors. On the other hand, morph-fitting makes use of this information, supplementing it with semantic relations between different morphological forms. These conclusions are in line with the Sim-Lex gains, where morph-fitting outperforms both distributional and morph-fixed vectors. English performance shows little variation across the four word vector collections investigated here. This corroborates our intuition that, as a morphologically simpler language, English stands to gain less from fine-tuning the morphological variation for downstream applications. This result again points at the discrepancy between intrinsic and extrinsic evaluation : the considerable gains in Sim-Lex performance do not necessarily induce similar gains in downstream performance . Additional discrepancies between SimLex and downstream DST performance are detected for German and Italian . While we observe a slight drop in SimLex performance with the DE MFIT-AR vectors compared to the MFIT-A ones , their relative performance is reversed in the DST task . On the other hand , we see the opposite trend in Italian , where the MFIT-A vectors score lower than the MFIT-AR vectors on SimLex , but higher on the DST task . In summary , we believe these results show that SimLex is not a perfect proxy for downstream performance in language understanding tasks . Regardless, its performance does correlate with downstream performance to a large extent, providing a useful indicator for the usefulness of specific word vector spaces for extrinsic tasks such as DST. 6 Related Work Semantic Specialisation A standard approach to incorporating external information into vector spaces is to pull the representations of similar words closer together. Some models integrate such constraints into the training procedure, modifying the prior or the regularisation ( Yu and Dredze, 2014; Xu et al., 2014; Bian et al., 2014; Kiela et al., 2015 ), or using a variant of the SGNS-style objective ( Liu et al., 2015; Osborne et al., 2016 ). Another class of models, popularly termed retrofitting, injects lexical knowledge from available semantic databases ( e.g., WordNet, PPDB ) into pre-trained word vectors ( Faruqui et al., 2015; Jauhar et al., 2015; Wieting et al., 2015; Nguyen et al., 2016; Mrkšic´ et al., 2016 ). Morph-fitting falls into the latter category. However, instead of resorting to curated knowledge bases, and experimenting solely with English, we show that the morphological richness of any language can be exploited as a source of inexpensive supervision for fine-tuning vector spaces, at the same time specialising them to better reflect true semantic similarity, and learning more accurate representations for low-frequency words. Word Vectors and Morphology. The use of morphological resources to improve the representations of morphemes and words is an active area of research. The majority of proposed architectures encode morphological information , provided either as gold standard morphological resources ( SylakGlassman et al . , 2015 ) such as CELEX ( Baayen et al . , 1995 ) or as an external analyser such as Morfessor ( Creutz and Lagus , 2007 ) , along with distributional information jointly at training time in the language modelling ( LM ) objective ( Luong et al . , 2013 ; Botha and Blunsom , 2014 ; Qiu et al . , 2014 ; Cotterell and Schütze , 2015 ; Bhatia et al . , 2016 , i.a . ) . The key idea is to learn a morphological composition function ( Lazaridou et al., 2013; Cotterell and Schütze, 2017 ) which synthesises the representation of a word given the representations of its constituent morphemes. Contrary to our work, these models typically coalesce all lexical relations. Another class of models, operating at the character level, shares a similar methodology: such models compose token-level representations from subcomponent embeddings ( subwords, morphemes, or characters ) ( dos Santos and Zadrozny, 2014; Ling et al., 2015; Cao and Rei, 2016; Kim et al., 2016; Wieting et al., 2016; Verwimp et al., 2017, i.a. ). In contrast to prior work, our model decouples the use of morphological information, now provided in the form of inflectional and derivational rules transformed into constraints, from the actual training. This pipelined approach results in a simpler, more portable model. In spirit , our work is similar to Cotterell et al . ( 2016b ) , who formulate the idea of post-training specialisation in a generative Bayesian framework . Their work uses gold morphological lexicons; we show that competitive performance can be achieved using a non-exhaustive set of simple rules. Our framework facilitates the inclusion of antonyms at no extra cost and naturally extends to constraints from other sources ( e.g . , WordNet ) in future work . Another practical difference is that we focus on similarity and evaluate morph-fitting in a well-defined downstream task where the artefacts of the distributional hypothesis are known to prompt statistical system failures. 7 Conclusion and Future Work We have presented a novel morph-fitting method which injects morphological knowledge in the form of linguistic constraints into word vector spaces. The method makes use of implicit semantic signals encoded in inflectional and derivational rules which describe the morphological processes in a language. The results in intrinsic word similarity tasks show that morph-fitting improves vector spaces induced by distributional models across four languages. Finally, we have shown that the use of morph-fitted vectors boosts the performance of downstream language understanding models which rely on word representations as features, especially for morphologically rich languages such as German. Future work will focus on other potential sources of morphological knowledge, porting the framework to other morphologically rich languages and downstream tasks, and on further refinements of the post-processing specialisation algorithm and the constraint selection. "}
  },
    {
    "id": "P17-1032",
    "result":     [
            {
        "value":         {
          "start": 929,
          "end": 936,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2095,
          "end": 2119,
          "text": "Recursive Neural Networks",
          "labels": ["Method"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 2298,
          "end": 2319,
          "text": "Long-Short Term Memory",
          "labels": ["Method"]
        },
        "id": 1250
      },
            {
        "value":         {
          "start": 2640,
          "end": 2669,
          "text": "Support Vector Machine ( SVM )",
          "labels": ["Method"]
        },
        "id": 1251
      },
            {
        "value":         {
          "start": 3585,
          "end": 3594,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 4366,
          "end": 4382,
          "text": "Nystro ¨ m method",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 4598,
          "end": 4607,
          "text": "Nystro ¨ m",
          "labels": ["Dataset"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 4726,
          "end": 4735,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 4816,
          "end": 4847,
          "text": "deep feed-forward neural network",
          "labels": ["Method"]
        },
        "id": 1254
      },
            {
        "value":         {
          "start": 5004,
          "end": 5041,
          "text": "Kernel-based Deep Architecture ( KDA )",
          "labels": ["Method"]
        },
        "id": 1260
      },
            {
        "value":         {
          "start": 5782,
          "end": 5803,
          "text": "Nystro ¨ m methodology",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 5809,
          "end": 5811,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 7046,
          "end": 7049,
          "text": "SVMs",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 9910,
          "end": 9912,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 11429,
          "end": 11431,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 11816,
          "end": 11832,
          "text": "Nystro ¨ m method",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 12396,
          "end": 12405,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14097,
          "end": 14106,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14393,
          "end": 14422,
          "text": "Multi-Layer Perceptron ( MLP )",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 14455,
          "end": 14464,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14485,
          "end": 14494,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14557,
          "end": 14594,
          "text": "Kernel-based Deep Architecture ( KDA )",
          "labels": ["Method"]
        },
        "id": 1260
      },
            {
        "value":         {
          "start": 14598,
          "end": 14600,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14625,
          "end": 14634,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 14901,
          "end": 14903,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 15217,
          "end": 15226,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 15407,
          "end": 15416,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 15496,
          "end": 15498,
          "text": "SVD",
          "labels": ["Method"]
        },
        "id": 1260
      },
            {
        "value":         {
          "start": 16422,
          "end": 16424,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 17139,
          "end": 17141,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 17621,
          "end": 17623,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 17851,
          "end": 17860,
          "text": "Nystro ¨ m",
          "labels": ["Tool"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 17900,
          "end": 17914,
          "text": "KeLP framework3",
          "labels": ["Tool"]
        },
        "id": 1260
      },
            {
        "value":         {
          "start": 17961,
          "end": 17971,
          "text": "Tensorflow4",
          "labels": ["Tool"]
        },
        "id": 1261
      },
            {
        "value":         {
          "start": 18055,
          "end": 18064,
          "text": "Nystro ¨ m",
          "labels": ["Tool"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 18388,
          "end": 18401,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 18753,
          "end": 18762,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 19020,
          "end": 19031,
          "text": "UIUC dataset",
          "labels": ["Dataset"]
        },
        "id": 1264
      },
            {
        "value":         {
          "start": 19561,
          "end": 19563,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 19593,
          "end": 19602,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 19703,
          "end": 19705,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 19778,
          "end": 19781,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 19887,
          "end": 19894,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19975,
          "end": 19986,
          "text": "UIUC dataset",
          "labels": ["Dataset"]
        },
        "id": 1264
      },
            {
        "value":         {
          "start": 20144,
          "end": 20160,
          "text": "Nystro ¨ m method",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 20435,
          "end": 20438,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 20533,
          "end": 20535,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 20560,
          "end": 20562,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 20598,
          "end": 20607,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 20627,
          "end": 20629,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 20646,
          "end": 20675,
          "text": "Dual Coordinate Descent method",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 20726,
          "end": 20731,
          "text": "SVMDCD",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 20773,
          "end": 20809,
          "text": "Convolutional Neural Network6 ( CNN )",
          "labels": ["Method"]
        },
        "id": 1266
      },
            {
        "value":         {
          "start": 20854,
          "end": 20861,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20908,
          "end": 20913,
          "text": "SVMDCD",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 21008,
          "end": 21010,
          "text": "CNN",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 21055,
          "end": 21057,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 21099,
          "end": 21106,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21207,
          "end": 21216,
          "text": "Nystro ¨ m",
          "labels": ["Metric"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 21235,
          "end": 21238,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 21258,
          "end": 21260,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 21539,
          "end": 21546,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21683,
          "end": 21703,
          "text": "SemEval - 2016 task 3",
          "labels": ["Dataset"]
        },
        "id": 1267
      },
            {
        "value":         {
          "start": 22214,
          "end": 22216,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 22630,
          "end": 22665,
          "text": "Kernel-based SVM classifier ( KSVM )",
          "labels": ["Method"]
        },
        "id": 1268
      },
            {
        "value":         {
          "start": 23078,
          "end": 23080,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 23123,
          "end": 23132,
          "text": "F1 measure",
          "labels": ["Metric"]
        },
        "id": 1269
      },
            {
        "value":         {
          "start": 23147,
          "end": 23156,
          "text": "Nystro ¨ m",
          "labels": ["Metric"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 23211,
          "end": 23214,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 23232,
          "end": 23241,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 23340,
          "end": 23343,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 23387,
          "end": 23395,
          "text": "F1 scores",
          "labels": ["Metric"]
        },
        "id": 1270
      },
            {
        "value":         {
          "start": 23521,
          "end": 23522,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23540,
          "end": 23545,
          "text": "SVMDCD",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 23579,
          "end": 23581,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 23619,
          "end": 23621,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 23666,
          "end": 23667,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23746,
          "end": 23751,
          "text": "ConvKN",
          "labels": ["Method"]
        },
        "id": 1270
      },
            {
        "value":         {
          "start": 23903,
          "end": 23930,
          "text": "convolutional neural network",
          "labels": ["Method"]
        },
        "id": 1271
      },
            {
        "value":         {
          "start": 25583,
          "end": 25598,
          "text": "Framenet dataset",
          "labels": ["Dataset"]
        },
        "id": 1272
      },
            {
        "value":         {
          "start": 26002,
          "end": 26004,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 26340,
          "end": 26347,
          "text": "Word2Vec",
          "labels": ["Method"]
        },
        "id": 1273
      },
            {
        "value":         {
          "start": 26390,
          "end": 26398,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 26453,
          "end": 26477,
          "text": "kernel-based SVM ( KSVM )",
          "labels": ["Method"]
        },
        "id": 1273
      },
            {
        "value":         {
          "start": 26491,
          "end": 26492,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 26599,
          "end": 26602,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 26770,
          "end": 26779,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 26879,
          "end": 26908,
          "text": "Dual Coordinate Descent method",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 26937,
          "end": 26942,
          "text": "SVMDCD",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 26954,
          "end": 26956,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 27023,
          "end": 27024,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27064,
          "end": 27069,
          "text": "SVMDCD",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 27113,
          "end": 27114,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27138,
          "end": 27141,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 27181,
          "end": 27183,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 27187,
          "end": 27189,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 27211,
          "end": 27212,
          "text": "F1",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27285,
          "end": 27288,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 27505,
          "end": 27508,
          "text": "KSVM",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 27812,
          "end": 27833,
          "text": "Nystro ¨ m methodology",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 28451,
          "end": 28479,
          "text": "k-nearest neighbors algorithm",
          "labels": ["Method"]
        },
        "id": 1274
      },
            {
        "value":         {
          "start": 29000,
          "end": 29015,
          "text": "gradient descent",
          "labels": ["Method"]
        },
        "id": 1275
      },
            {
        "value":         {
          "start": 29315,
          "end": 29343,
          "text": "convolutional neural networks",
          "labels": ["Method"]
        },
        "id": 1276
      },
            {
        "value":         {
          "start": 29424,
          "end": 29451,
          "text": "Convolutional Kernel Network",
          "labels": ["Method"]
        },
        "id": 1276
      },
            {
        "value":         {
          "start": 29559,
          "end": 29561,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 29632,
          "end": 29634,
          "text": "CNN",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 29881,
          "end": 29902,
          "text": "Nystro ¨ m methodology",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 30278,
          "end": 30294,
          "text": "Nystro ¨ m method",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 31091,
          "end": 31093,
          "text": "KDA",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 31223,
          "end": 31232,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 31589,
          "end": 31598,
          "text": "Nystro ¨ m",
          "labels": ["Method"]
        },
        "id": 1277
      },
            {
        "value":         {
          "start": 31751,
          "end": 31765,
          "text": "KDA methodology",
          "labels": ["Method"]
        },
        "id": 1277
      }
    ],
    "data": {"text": "Deep Learning in Semantic Kernel Spaces Abstract Kernel methods enable the direct usage of structured representations of textual data during language learning and inference tasks. Expressive kernels, such as Tree Kernels, achieve excellent performance in NLP. On the other side, deep neural networks have been demonstrated effective in automatically learning feature representations during training. However, their input is tensor data, i.e., they cannot manage rich structured information. In this paper, we show that expressive kernels and deep neural networks can be combined in a common framework in order to ( i ) explicitly model structured information and ( ii ) learn non-linear decision functions. We show that the input layer of a deep architecture can be pre-trained through the application of the Nystro¨m low-rank approximation of kernel spaces. The resulting “ kernelized ” neural network achieves state-of-the-art accuracy in three different tasks . 1 Introduction Learning for Natural Language Processing ( NLP ) requires to more or less explicitly account for trees or graphs to express syntactic and semantic information. A straightforward modeling of such information has been obtained in statistical language learning with Tree Kernels ( TKs ) ( Collins and Duffy, 2001 ), or by means of structured neural models ( Hochreiter and Schmidhuber, 1997; Socher et al., 2013 ). In particular, kernel-based methods ( Shawe-Taylor and Cristianini, 2004 ) have been largely applied in language processing for alleviating the need of complex activities of manual feature engineering ( e.g., ( Moschitti et al., 2008 ) ). Although ad-hoc features are adopted by many successful approaches to language learning ( e.g., ( Gildea and Jurafsky, 2002 ) ), kernels provide a natural way to capture textual generalizations directly operating over ( possibly complex ) linguistic structures. Sequence ( Cancedda et al., 2003 ) or tree kernels ( Collins and Duffy, 2001 ) are of particular interest as the feature space they implicitly generate reflects linguistic patterns. On the other hand , Recursive Neural Networks ( Socher et al . , 2013 ) have been shown to learn dense feature representations of the nodes in a structure , thus exploiting similarities between nodes and sub-trees . Also , Long-Short Term Memory ( Hochreiter and Schmidhuber , 1997 ) networks build intermediate representations of sequences , resulting in similarity estimates over sequences and their inner sub-sequences . While such methods are highly effective and reach state-of-the-art results in many tasks, their adoption can be problematic. In kernel-based Support Vector Machine ( SVM ) the classification model corresponds to the set of support vectors ( SVs ) and weights justifying the maximal margin hyperplane : the classification cost crucially depends on their number , as classifying a new instance requires a kernel computation against all SVs , making their adoption in large data settings prohibitive . This scalability issue is evident in many NLP and Information Retrieval applications, such as in answer re-ranking in question answering ( Severyn et al., 2013; Filice et al., 2016 ), where the number of SVs is typically very large. Improving the efficiency of kernel-based methods is a largely studied topic. The reduction of computational costs has been early designed by imposing a budget ( Dekel and Singer, 2006; Wang and Vucetic, 2010 ), that is limiting the maximum number of SVs in a model. However , in complex tasks , such methods still require large budgets to reach adequate accuracies . On the other hand, training complex neural networks is also difficult as no common design practice is established against complex data structures. In Levy et al. ( 2015 ), a careful analysis of neural word embedding models is carried out and the role of the hyper-parameter estimation is outlined. Different neural architectures result in the same performances, whenever optimal hyper-parameter tuning is applied. In this latter case, no significant difference is observed across different architectures, making the choice between different neural architectures a complex and empirical task. A general approach to the large scale modeling of complex structures is a critical and open problem. A viable and general solution to this scalability issue is provided by the Nystro ¨ m method ( Williams and Seeger , 2001 ) ; it allows to approximate the Gram matrix of a kernel function and support the embedding of future input examples into a low-dimensional space . For example , if used over TKs , the Nystro ¨ m projection corresponds to the embedding of any tree into a low-dimensional vector . In this paper , we show that the Nystro ¨ m based low-rank embedding of input examples can be used as the early layer of a deep feed-forward neural network . A standard NN back-propagation training can thus be applied to induce non-linear functions in the kernel space. The resulting deep architecture , called Kernel-based Deep Architecture ( KDA ) , is a mathematically justified integration of expressive kernel functions and deep neural architectures , with several advantages : it ( i ) directly operates over complex non-tensor structures , e.g . , trees , without any manual feature or architectural engineering , ( ii ) achieves a drastic reduction of the computational cost w.r.t . pure kernel methods , and ( iii ) exploits the non-linearity of NNs to produce accurate models . The experimental evaluation shows that the proposed approach achieves state-of-the-art results in three semantic inference tasks: Semantic Parsing, Question Classification and Community Question Answering. In the rest of the paper, Section 2 surveys some of the investigated kernels. In Section 3 the Nystro ¨ m methodology and KDA are presented . Experimental evaluations are described in Section 4. Finally, Section 5 derives the conclusions. 2 Kernel-based Semantic Inference In almost all NLP tasks, explicit models of complex syntactic and semantic structures are required, such as in Paraphrase Detection: deciding whether two sentences are valid paraphrases involves learning grammatical rewriting rules, such as semantics preserving mappings among subtrees. Also in Question Answering, the syntactic information about input questions is crucial. While manual feature engineering is always possible, kernel methods on structured representations of data objects, e.g., sentences, have been largely applied. Since Collins and Duffy ( 2001 ), sentences can be modeled through their corresponding parse tree, and Tree Kernels ( TKs ) result in similarity metrics directly operating over tree fragments. Such kernels corresponds to dot products in the ( implicit ) feature space made of all possible tree fragments ( Haussler, 1999 ). Notice that the number of tree fragments in a tree bank is combinatorial with the number of tree nodes and gives rise to billions of features, i.e., dimensions. In this high-dimensional space , kernel-based algorithms , such as SVMs , can implicitly learn robust prediction models ( Shawe-Taylor and Cristianini , 2004 ) , resulting in state-of-the-art approaches in several NLP tasks , e.g . , Semantic Role Labeling ( Moschitti et al . , 2008 ) , Question Classification ( Croce et al . , 2011 ) or Paraphrase Identification ( Filice et al . , 2015 ) . As the feature space generated by the structural kernels depends on the input structures, different tree representations can be adopted to reflect more or less expressive syntactic/semantic feature spaces. While constituency parse trees have been early used ( e.g., ( Collins and Duffy, 2001 ) ), dependency parse trees correspond to graph structures. TKs usually rely on their tree conversions, where grammatical edge labels corresponds to nodes. An expressive tree representation of dependency graphs is the Grammatical Relation Centered Tree ( GRCT ). As illustrated in Figure 1, PoS-Tags and grammatical functions correspond to nodes, dominating their associated lexicals. Types of tree kernels. While a variety of TK functions have been studied, e.g., the Partial Tree Kernel ( PTK ) ( Moschitti, 2006 ), the kernels used in this work model grammatical and semantic information, as triggered respectively by the dependency edge labels and lexical nodes. The latter is exploited through recent results in distributional models of lexical semantics, as proposed in word embedding methods ( e.g., ( Mikolov et al., 2013; Sahlgren, 2006 ). In particular, we adopt the Smoothed Partial Tree Kernel ( SPTK ) described in Croce et al. ( 2011 ): it extends the PTK formulation with a similarity function between lexical nodes in a GRCT, i.e., the cosine similarity between word vector representations based on word embeddings. We also use a further extension of the SPTK, called Compositionally Smoothed Partial Tree Kernel ( CSPTK ) ( as in Annesi et al. ( 2014 ) ). In CSPTK, the lexical information provided by the sentence words is propagated along the non-terminal nodes representing head-modifier dependencies. Figure 2 shows a compositionally-labeled tree, where the similarity function at the nodes can model lexical composition, i.e., capturing contextual information. For example, in the sentence, “What instrument does Hendrix play?”, the role of the word instrument can be fully captured only if its composition with the verb play is considered. The CSPTK applies a composition function between nodes: while several algebraic functions can be adopted to compose two word vectors representing a head/modifier pair, here we refer to a simple additive function that assigns to each ( h,m ) pair the linear combination of the involved vectors, i.e., ( h,m ) = Ah +Bm: although simple and efficient, it actually produces very effective CSPTK functions. Complexity. The training phase of an optimal maximum margin algorithm ( such as SVM ) requires a number of kernel operations that is more than linear ( almost O ( n2 ) ) with respect to the number of training examples n , as discussed in Chang and Lin ( 2011 ) . Also the classification phase depends on the size of the input dataset and the intrinsic complexity of the targeted task: classifying a new instance requires to evaluate the kernel function with respect to each support vector. For complex tasks, the number of selected support vectors tends to be very large, and using the resulting model can be impractical. This cost is also problematic as single kernel operations can be very expensive: the cost of evaluating the PTK on a single tree pair is almost linear in the number of nodes in the input trees, as shown in Moschitti ( 2006 ). When lexical semantics is considered, as in SPTKs and CSPTKs, it is more than linear in the number of nodes ( Croce et al., 2011 ). 3 Deep Learning in Kernel Spaces 3.1 The Nystro¨m method Given an input training dataset D, a kernel K( oi, oj ) is a similarity function over D2 that corresponds to a dot product in the implicit kernel space, i.e., K( oi, oj ) = Φ( oi ) · Φ( oj ). The advantage of kernels is that the projection function Φ( o ) = x ∈ Rn is never explicitly computed ( Shawe-Taylor and Cristianini, 2004 ). In fact, this operation may be prohibitive when the dimensionality n of the underlying kernel space is extremely large, as for Tree Kernels ( Collins and Duffy, 2001 ). Kernel functions are used by learning algorithms , such as SVM , to operate only implicitly on instances in the kernel space , by never accessing their explicit definition . Let us apply the projection function Φ over all examples from D to derive representations, x denoting the rows of the matrix X . The Gram matrix can always be computed asG = XX>, with each single element corresponding to Gij = Φ( oi )Φ( oj ) = K( oi, oj ). The aim of the Nystro ¨ m method is to derive a new low-dimensional embedding x ˜ in a l-dimensional space , with l n so that G ˜ = X ˜ X ˜ > and G ˜ ≈ G . This is obtained by generating an approximation G˜ of G using a subset of l columns of the matrix, i.e., a selection of a subset L ⊂ D of the available examples, called landmarks. Suppose we randomly sample l columns of G, and let C ∈ R|D|×l be the matrix of these sampled columns. Then, we can rearrange the columns and rows of G and define X = [X1 X2] such that: where W = X>1 X1, i.e., the subset of G that contains only landmarks. The Nystro ¨ m approximation can be defined as : where W † denotes the Moore-Penrose inverse of W . The Singular Value Decomposition ( SVD ) is used to obtain W † as it follows. First, W is decomposed so that W = USV >, where U and V are both orthogonal matrices, and S is a diagonal matrix containing the ( non-zero ) singular values of W on its diagonal. Since W is symmetric and positive definite W = USU>. Then W † = US−1U> = US− 1 2S− 1 2U> and the Equation 2 can be rewritten as. Given an input example o ∈ D, a new low-dimensional representation x˜ can be thus determined by considering the corresponding item of C as where c is the vector whose dimensions contain the evaluations of the kernel function between o and each landmark oj ∈ L. Therefore, the method produces l-dimensional vectors. If k is the average number of basic operations required during a single kernel computation, the overall cost of a single projection is O( kl + l2 ), where the first term corresponds to the cost of generating the vector c, while the second term is needed for the matrix multiplications in Equation 4. Typically, the number of landmarks l ranges from hundreds to few thousands and, for complex kernels ( such as Tree Kernels ), the projection cost can be reduced to O( kl ). Several policies have been defined to determine the best selection of landmarks to reduce the Gram Matrix approximation error. In this work the uniform sampling without replacement is adopted, as suggested by Kumar et al. ( 2012 ), where this policy has been theoretically and empirically shown to achieve results comparable with other ( more complex ) selection policies. 3.2 A Kernel-based Deep Architecture The above introduced Nystro ¨ m representation x ˜ of any input example o is linear and can be adopted to feed a neural network architecture . We assume a labeled dataset L = {( o, y ) | o ∈ D, y ∈ Y } being available, where o refers to a generic instance and y is its associated class. In this Section , we define a Multi-Layer Perceptron ( MLP ) architecture , with a specific Nystro ¨ m layer based on the Nystro ¨ m embeddings of Eq . 4 . We will refer to this architecture as Kernel-based Deep Architecture ( KDA ) . KDA has an input layer , a Nystro ¨ m layer , a possibly empty sequence of non-linear hidden layers and a final classification layer , which produces the output . The input layer corresponds to the input vector c, i.e., the row of the C matrix associated to an example o. Notice that , for adopting the KDA , the values of the matrix C should be all available . In the training stage, these values are in general cached. During the classification stage, the c vector corresponding to an example o is directly computed by l kernel computations between o and each one of the l landmarks. The input layer is mapped to the Nystro ¨ m layer , through the projection in Equation 4 . Notice that the embedding provides also the proper weights , defined by US − 1 2 , so that the mapping can be expressed through the Nystro ¨ m matrix HNy = US − 1 2 : it corresponds to a pre-trained stage derived through SVD , as discussed in Section 3.1 . Equation 4 provides a static definition for HNy whose weights can be left invariant during the neural network training. However, the values ofHNy can be made available for the standard back-propagation adjustments applied for training1. Formally, the low-dimensional embedding of an input example o, is x˜ = c HNy = c US− 1 2 . The resulting outcome x˜ is the input to one or more non-linear hidden layers. Each t-th hidden layer is realized through a matrix Ht ∈ Rht−1×ht and a bias vector bt ∈ R1×ht , whereas ht denotes the desired hidden layer dimensionality. Clearly, given that HNy ∈ Rl×l, h0 = l. The first hidden layer in fact receives in input x˜ = cHNy, that corresponds to t = 0 layer input x0 = x˜ and its computation is formally expressed by x1 = f( x0H1 + b1 ), where f is a non-linear activation function. In general, the generic t-th layer is modeled as. The final layer of KDA is the classification layer , realized through the output matrix HO and the output bias vector bO . Their dimensionality depends on the dimensionality of the last hidden layer ( called O−1 ) and the number |Y | of different classes, i.e., HO ∈ RhO−1×|Y | and bO ∈ R1×|Y |, respectively. In particular, this layer computes a linear classification function with a softmax operator so that yˆ = softmax( xO−1HO + bO ). In order to avoid over-fitting, two different regularization schemes are applied. First, the dropout is applied to the input xt of each hidden layer ( t ≥ 1 ) and to the input xO−1 of the final classifier. Second, a L2 regularization is applied to the norm of each layer2 Ht and HO. Finally , the KDA is trained by optimizing a loss function made of the sum of two factors : first , the cross-entropy function between the gold classes and the predicted ones ; second the L2 regularization , whose importance is regulated by a metaparameter λ . The final loss function is thus where yˆ are the softmax values computed by the network and y are the true one-hot encoding values associated with the example from the labeled training dataset L. 4 Empirical Investigation The proposed KDA has been applied adopting the same architecture but with different kernels to three NLP tasks , i.e . , Question Classification , Community Question Answering , and Automatic Boundary Detection in Semantic Role Labeling . The Nystro ¨ m projector has been implemented in the KeLP framework3 . The neural network has been implemented in Tensorflow4 , with 2 hidden layers whose dimensionality corresponds to the number of involved Nystro ¨ m landmarks . The rectified linear unit is the non-linear activation function in each layer. The dropout has been applied in each hidden layer and in the final classification layer. The values of the dropout parameter and the λ parameter of the L2-regularization have been selected from a set of values via grid-search. The Adam optimizer with a learning rate of 0.001 has been applied to minimize the loss function , with a multi-epoch ( 500 ) training , each fed with batches of size 256 . We adopted an early stop strategy, where the best model was selected according to the performance over the development set. Every performance measure is obtained against a specific sampling of the Nystro ¨ m landmarks . Results averaged against 5 such samplings are always hereafter reported. 4.1 Question Classification Question Classification ( QC ) is the task of mapping a question into a closed set of answer types in a Question Answering system. We used the UIUC dataset ( Li and Roth , 2006 ) , including a training and test set of 5 , 452 and 500 questions , respectively , organized in 6 classes ( like ENTITY or HUMAN ) . TKs resulted very effective, as shown in Croce et al. ( 2011 ); Annesi et al. ( 2014 ). In Annesi et al. ( 2014 ), QC is mapped into a One-vs-All multi-classification schema, where the CSPTK achieves state-of-the-art results of 95%: it acts directly over compositionally labeled trees without relying on any manually designed feature. In order to proof the benefits of the KDA architecture , we generated Nystro ¨ m representation of the CSPTK kernel function5 with default parameters ( i.e . , µ = λ = 0.4 ) . The SVM formulation by Chang and Lin ( 2011 ) , fed with the CSPTK ( hereafter KSVM ) , is here adopted to determine the reachable upper bound in classification quality , i.e . , a 95% of accuracy , at higher computational costs . It establishes the state-of-the-art over the UIUC dataset . The resulting model includes 3,873 support vectors: this corresponds to the number of kernel operations required to classify any input test question. The Nystro ¨ m method based on a number of landmarks ranging from 100 to 1,000 is adopted for modeling input vectors in the CSPTK kernel space . Results are reported in Table 1 : computational saving refers to the percentage of avoided kernel computations with respect to the application of the KSVM to each test instance . To justify the need of the Neural Network , we compared the proposed KDA to an efficient linear SVM that is directly trained over the Nystro ¨ m embeddings . This SVM implements the Dual Coordinate Descent method ( Hsieh et al . , 2008 ) and will be referred as SVMDCD . We also measured the state-of-the-art Convolutional Neural Network6 ( CNN ) of Kim ( 2014 ) , achieving the remarkable accuracy of 93.6% . Notice that the linear classifier SVMDCD operating over the approximated kernel space achieves the same classification quality of the CNN when just 1,000 landmarks are considered . KDA improves this results , achieving 94.3% accuracy even with fewer landmarks ( only 600 ) , showing the effectiveness of non-linear learning over the Nystro ¨ m input . Although KSVM improves to 95% , KDA provides a saving of more than 84% kernel computations at classification time . This result is straightforward as it confirms that linguistic information encoded in a tree is important in the analysis of questions and can be used as a pre-training strategy. Figure 3 shows the accuracy curves according to various approximations of the kernel space , i.e . , number of landmarks . 4.2 Community Question-Answering In the SemEval - 2016 task 3 , participants were asked to automatically provide good answers in a community question answering setting ( Nakov et al . , 2016 ) . We focused on the subtask A: given a question and a large collection of questioncomment threads created by a user community, the task consists in ( re- )ranking the comments w.r.t. their utility in answering the question. Subtask A can be modeled as a binary classification problem, where instances are ( question, comment ) pairs. Each pair generates an example for a binary SVM , where the positive label is associated to a good comment and the negative label refers to potentially useful and bad comments . The classification score achieved over different ( question, comment ) pairs is used to sort instances and produce the final ranking over comments. The above setting results in a train and test dataset made of 20,340 and 3,270 examples, respectively. In Filice et al . ( 2016 ) , a Kernel-based SVM classifier ( KSVM ) achieved state-of-the-art results by adopting a kernel combination that exploited ( i ) feature vectors containing linguistic similarities between the texts in a pair ; ( ii ) shallow syntactic trees that encode the lexical and morpho-syntactic information shared between text pairs ; ( iii ) feature vectors capturing task-specific information . Such model includes 11,322 support vectors. We investigated the KDA architecture , trained by maximizing the F1 measure , based on a Nystro ¨ m layer initialized using the same kernel functions as KSVM . We varied the Nystro ¨ m dimensions from 100 to 1,000 landmarks , i.e . , a much lower number than the support vectors of KSVM . Table 2 reports the results : very high F1 scores are observed with impressive savings in terms of kernel computations ( between 91.2% and 99% ) . Also on the cQA task , the F1 obtained by the SVMDCD is significantly lower than the KDA one . Moreover , with 800 landmarks KDA achieves the remarkable results of 0.68 of F1 , that is the state-of-the-art against other convolutional systems , e.g . , ConvKN ( Barro ´ n-Ceden ˜ o et al . , 2016 ) : this latter combines convolutional tree kernels with kernels operating on sentence embeddings generated by a convolutional neural network . 4.3 Argument Boundary Detection Semantic Role Labeling ( SRL ) consists of the detection of the semantic arguments associated with the predicate of a sentence ( called Lexical Unit ) and their classification into their specific roles ( Fillmore, 1985 ). For example, given the sentence “Bootleggers then copy the film onto hundreds of tapes” the task would be to recognize the verb copy as representing the DUPLICA-TION frame with roles, CREATOR for Bootleggers, ORIGINAL for the film and GOAL for hundreds of tapes. Argument Boundary Detection ( ABD ) corresponds to the SRL subtask of detecting the sentence fragments spanning individual roles. In the previous example the phrase “the film” represents a role ( i.e., ORIGINAL ), while “of tapes” or “film onto hundreds” do not, as they just partially cover one or multiple roles, respectively. The ABD task has been successfully tackled using TKs since Moschitti et al. ( 2008 ). It can be modeled as a binary classification task over each parse tree node n, where the argument span reflects words covered by the sub-tree rooted at n. In our experiments, Grammatical Relation Centered Tree ( GRCT ) derived from dependency grammar ( Fig. 4 ) are employed, as shown in Fig. 5. Each node is considered as a candidate in covering a possible argument. In particular, the structure in Fig. 5a is a positive example. On the contrary, in Fig. 5b the NMOD node only covers the phrase “of tapes”, i.e., a subset of the correct role, and it represents a negative example7. We selected all the sentences whose predicate word ( lexical unit ) is a verb ( they are about 60,000 ) , from the 1.3 version of the Framenet dataset ( Baker et al . , 1998 ) . This gives rise to about 1,400,000 sub-trees, i.e., the positive and negative instances. The dataset is split in train and test according to the 90/10 proportion ( as in ( Johansson and Nugues, 2008 ) ). This size makes the application of a traditional kernel-based method unfeasible, unless a significant instance sub-sampling is performed. We firstly experimented standard SVM learning over a sampled training set of 10,000 examples , a typical size for annotated datasets in computational linguistics tasks . We adopted the Smoothed Partial Tree Kernel ( Croce et al . , 2011 ) with standard parameters ( i.e . , µ = λ = 0.4 ) and lexical nodes expressed through 250 - dimensional vectors obtained by applying Word2Vec ( Mikolov et al . , 2013 ) to the entire Wikipedia . When trained over this 10k instances dataset , the kernel-based SVM ( KSVM ) achieves an F1 of 70.2% , over the same test set used in Croce and Basili ( 2016 ) that includes 146,399 examples . The KSVM learning produces a model including 2 , 994 support vectors , i.e . , the number of kernel operations required to classify each new test instance . We then apply the Nystro ¨ m linearization to a larger dataset made of 100k examples , and trained a classifier using both the Dual Coordinate Descent method ( Hsieh et al . , 2008 ) , SVMDCD , and the KDA proposed in this work . Table 3 presents the results in terms of F1 and saved kernel operation . Although SVMDCD with 500 landmarks already achieves 0.713 F1 , a score higher than KSVM , it is significantly improved by the KDA . KDA achieves up to 0.76 F1 with only 400 landmarks , resulting in a huge step forward w.r.t . the KSVM . This result is straightforward considering ( i ) the reduction of required kernel operations , i.e . , more than 86% are saved and ( ii ) the quality achieved since 100 landmarks ( i.e . , 0.711 , higher than the KSVM ) . 5 Discussion and Conclusions In this work, we promoted a methodology to embed structured linguistic information within NNs, according to mathematically rich semantic similarity models, based on kernel functions. Structured data , such as trees , are transformed into dense vectors according to the Nystro ¨ m methodology , and the NN is effective in capturing non-linearities in these representations , but still improving generalization at a reasonable complexity . At the best our knowledge, this work is one of the few attempts to systematically integrate linguistic kernels within a deep neural network architecture. The problem of combining such methodologies has been studied in specific works, such as ( Baldi et al., 2011; Cho and Saul, 2009; Yu et al., 2009 ). In Baldi et al. ( 2011 ) the authors propose a hybrid classifier, for bridging kernel methods and neural networks. In particular , they use the output of a kernelized k-nearest neighbors algorithm as input to a neural network . Cho and Saul ( 2009 ) introduced a family of kernel functions that mimic the computation of large multilayer neural networks. However, such kernels can be applied only on vector inputs. In Yu et al. ( 2009 ), deep neural networks for rapid visual recognition are trained with a novel regularization method taking advantage of kernels as an oracle representing prior knowledge. The authors transform the kernel regularizer into a loss function and carry out the neural network training by gradient descent . In Zhuang et al. ( 2011 ) a different approach has been promoted: a multiple ( two ) layer architecture of kernel functions, inspired by neural networks, is studied to find the best kernel combination in a Multiple Kernel Learning setting. In Mairal et al . ( 2014 ) the invariance properties of convolutional neural networks ( LeCun et al . , 1998 ) are modeled through kernel functions , resulting in a Convolutional Kernel Network . Other effort for combining NNs and kernel methods is described in Tymoshenko et al . ( 2016 ) , where a SVM adopts a tree kernels combinations with embeddings learned through a CNN . The approach here discussed departs from previous approaches in different aspects. First, a general framework is promoted: it is largely applicable to any complex kernel, e.g., structural kernels or combinations of them. The efficiency of the Nystro ¨ m methodology encourages its adoption , especially when complex kernel computations are required . Notice that other low-dimensional approximations of kernel functions have been studied, as for example the randomized feature mappings proposed in Rahimi and Recht ( 2008 ). However, these assume that ( i ) instances have vectorial form and ( ii ) shift-invariant kernels are adopted. The Nystro ¨ m method adopted here does not suffer of such limitations : as our target is the application to structured ( linguistic ) data , more general kernels , i.e . , non-shift-invariant convolution kernels are needed . Given the Nystro¨m approximation, the learning setting corresponds to a general well-known neural network architecture, i.e., a multilayer perceptron, and does not require any manual feature engineering or the design of ad-hoc network architectures. The success in three different tasks confirms its large applicability without major changes or adaptations. Second, we propose a novel learning strategy, as the capability of kernel methods to represent complex search spaces is combined with the ability of neural networks to find non-linear solutions to complex tasks. Last , the suggested KDA framework is fully scalable , as ( i ) the network can be parallelized on multiple machines , and ( ii ) the computation of the Nystro ¨ m reconstruction vector c can be easily parallelized on multiple processing units , ideally l , as each unit can compute one ci value . Future work will address experimentations with larger scale datasets ; moreover , it is interesting to experiment with more landmarks in order to better understand the trade-off between the representation capacity of the Nystro ¨ m approximation of the kernel functions and the over-fitting that can be introduced in a neural network architecture . Finally , the optimization of the KDA methodology through the suitable parallelization on multicore architectures , as well as the exploration of mechanisms for the dynamic reconstruction of kernel spaces ( e.g . , operating over HNy ) also constitute interesting future research directions on this topic . "}
  },
    {
    "id": "P17-1058",
    "result":     [
            {
        "value":         {
          "start": 623,
          "end": 625,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 1320,
          "end": 1354,
          "text": "interactive alignment model ( IAM )",
          "labels": ["Method"]
        },
        "id": 1278
      },
            {
        "value":         {
          "start": 1775,
          "end": 1777,
          "text": "IAM",
          "labels": ["Method"]
        },
        "id": 1281
      },
            {
        "value":         {
          "start": 6246,
          "end": 6280,
          "text": "interactive-alignment model ( IAM )",
          "labels": ["Method"]
        },
        "id": 1280
      },
            {
        "value":         {
          "start": 6846,
          "end": 6848,
          "text": "IAM",
          "labels": ["Method"]
        },
        "id": 1281
      },
            {
        "value":         {
          "start": 12325,
          "end": 12344,
          "text": "HCRC Map Task Corpus",
          "labels": ["Dataset"]
        },
        "id": 1281
      },
            {
        "value":         {
          "start": 12489,
          "end": 12491,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 12495,
          "end": 12502,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 13251,
          "end": 13253,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 13888,
          "end": 13905,
          "text": "Switchboard Corpus",
          "labels": ["Dataset"]
        },
        "id": 1284
      },
            {
        "value":         {
          "start": 14024,
          "end": 14062,
          "text": "Copenhagen Dependency Treebanks Corpus1",
          "labels": ["Dataset"]
        },
        "id": 1284
      },
            {
        "value":         {
          "start": 14097,
          "end": 14099,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 14282,
          "end": 14303,
          "text": "trigram language model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 14514,
          "end": 14526,
          "text": "trigram model",
          "labels": ["Method"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 14573,
          "end": 14586,
          "text": "SRILM software",
          "labels": ["Tool"]
        },
        "id": 1285
      },
            {
        "value":         {
          "start": 14891,
          "end": 14898,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 15189,
          "end": 15191,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 15700,
          "end": 15707,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 16309,
          "end": 16338,
          "text": "fast Fourier transform ( FFT )",
          "labels": ["Method"]
        },
        "id": 1286
      },
            {
        "value":         {
          "start": 16561,
          "end": 16570,
          "text": "R software",
          "labels": ["Tool"]
        },
        "id": 1287
      },
            {
        "value":         {
          "start": 18098,
          "end": 18133,
          "text": "augmented Dickey-Fuller ( ADF ) test",
          "labels": ["Method"]
        },
        "id": 1288
      },
            {
        "value":         {
          "start": 18170,
          "end": 18216,
          "text": "Kwiatkowski-Phillips-Schmidt-Shin ( KPSS ) test",
          "labels": ["Method"]
        },
        "id": 1289
      },
            {
        "value":         {
          "start": 18259,
          "end": 18285,
          "text": "Phillips-Perron ( PP ) test",
          "labels": ["Method"]
        },
        "id": 1290
      },
            {
        "value":         {
          "start": 18522,
          "end": 18538,
          "text": "Fourier transform",
          "labels": ["Method"]
        },
        "id": 1291
      },
            {
        "value":         {
          "start": 19528,
          "end": 19530,
          "text": "FFT",
          "labels": ["Method"]
        },
        "id": 1292
      },
            {
        "value":         {
          "start": 20514,
          "end": 20527,
          "text": "Ljung-Box test",
          "labels": ["Method"]
        },
        "id": 1293
      },
            {
        "value":         {
          "start": 20971,
          "end": 20977,
          "text": "MapTask",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 21010,
          "end": 21012,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 21280,
          "end": 21287,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 21293,
          "end": 21295,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 21916,
          "end": 21932,
          "text": "Breush-Pagan test",
          "labels": ["Method"]
        },
        "id": 1295
      },
            {
        "value":         {
          "start": 22024,
          "end": 22045,
          "text": "Box-Cox transformation",
          "labels": ["Method"]
        },
        "id": 1296
      },
            {
        "value":         {
          "start": 22207,
          "end": 22213,
          "text": "Box-Cox",
          "labels": ["Method"]
        },
        "id": 1297
      },
            {
        "value":         {
          "start": 22401,
          "end": 22403,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 26367,
          "end": 26374,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 26415,
          "end": 26417,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 27210,
          "end": 27217,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 27331,
          "end": 27333,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 27531,
          "end": 27538,
          "text": "Map Task",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 27555,
          "end": 27557,
          "text": "DJD",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 29738,
          "end": 29744,
          "text": "MapTask",
          "labels": ["Dataset"]
        },
        "id": 1298
      },
            {
        "value":         {
          "start": 29796,
          "end": 29804,
          "text": "SVM model",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 30192,
          "end": 30200,
          "text": "SVM model",
          "labels": ["Method"]
        },
        "id": 1523
      }
    ],
    "data": {"text": "Spectral Analysis of Information Density in Dialogue Predicts Collaborative Task Performance Abstract We propose a perspective on dialogue that focuses on relative information contributions of conversation partners as a key to successful communication. We predict the success of collaborative task in English and Danish corpora of task-oriented dialogue. Two features are extracted from the frequency domain representations of the lexical entropy series of each interlocutor, power spectrum overlap ( PSO ) and relative phase ( RP ). We find that PSO is a negative predictor of task success, while RP is a positive one. An SVM with these features significantly improved on previous task success prediction models . Our findings suggest that the strategic distribution of information density between interlocutors is relevant to task success. 1 Introduction What factors affect whether information is conveyed effectively and reliably in conversations? Several theoretical frameworks have emerged that model dialogical behavior at different granularity levels. Can we use them to measure communicative effectiveness? Grounding theory ( Clark and Brennan, 1991 ) models a successful communication as a process during which “common ground” ( i.e., mutual knowledge, beliefs etc. ) is jointly built among interlocutors. The interactive alignment model ( IAM ) ( Pickering and Garrod , 2004 ) proposes that the ultimate goal of dialogue is the alignment of interlocutors ’ situational model , which is helped by alignment at all other lower representation levels ( e.g . , lexical , syntactic etc . , driven by the psychologically well-documented priming effects . Recently , empirical studies have verified the explanatory powers of the above-mentioned theories , especially the IAM , utilizing dialogues recorded and transcribed from various collaborative tasks conducted in laboratory settings ( Reitter and Moore , 2007 ; Reitter and Moore , 2014 ; Fusaroli et al . , 2012 ; Fusaroli and Tyle ´ n , 2016 ) . In those studies, the quality of communication is directly reflected in the collaborative performance of interlocutors, i.e., how successful they are in accomplishing the task. Although they do not come to fully agree on which theoretical accounts of dialogue ( e.g., interactive alignment vs. interpersonal synergy ) provides better explanations ( see Section 2.1 for details ), the majority of these studies have confirmed that the alignment of certain linguistic markers, lexical items, or syntactic rules between interlocutors correlates with task success. What is missing from the picture, however, is the computational understanding of how strategies of interaction and the mix of information contributions to the conversation facilitate successful communication. This is understandable because those higher level concepts do not directly map onto the atomic linguistic elements and thus are much more difficult to define and operationalize. In the present study, we intend to explore this missing part of work by characterizing how the interaction between interlocutors in terms of their information contributions affects the quality of communication. 1.1 An information-based approach Recent work has already used information theory to study the dynamics of dialogue. Xu and Reitter ( 2016b ) observed that the amount of lexical information ( measured by entropy ) from interlocutors of different roles, converges within the span of topic episodes in natural spoken dialogue. Anon ( 2017 ) interpret this converging pattern as a reflection of the dynamic process in which the information contributed by two interlocutors fluctuates in a complementary way at the early stage, and gradually reaches an equilibrium status. Xu and Reitter ( 2016b ) also correlated this entropy converging pattern with the topic shift phenomenon that frequently occurs in natural conversation ( Ng and Bradac, 1993 ), and proposed that it reflects the process of interlocutors building the common ground that is necessary for the ongoing topics of conversation. Based on Xu and Reitter’s ( 2016 ) finding that entropy converging pattern repeatedly occurs within dialogue ( though not necessarily at strictly regular intervals ), it is reasonable to expect that after applying some spectral analysis techniques ( time space to frequency space conversion ) to the entropy series of dialogue, the frequency space representations should demonstrate some patterns that are distinct from white noise, because the periodicity properties in time space are captured. Furthermore, we expect that how the frequency representations of two interlocutors correlate provides some information about the higher level properties of dialogue, e.g., the task performance etc. The thought is intuitive: If we imagine the entropy series from two interlocutors as two ideal sinusoidal signals s1 and s2 ( supposedly of different frequencies, f1 and f2 ) ( Figure 1 ), then the observed converging pattern can be thought of as a segment from the full spans of the signals. Then the frequency space properties, such as how close f1 and f2 are, and the phase difference φ between them, will definitely affect the shape of the converging pattern ( solid lines in Figure 1 ). As Xu and Reitter ( 2016b ) argues that the converging segment reflects the grounding process between interlocutors, it is reasonable to expect that the shape and length of this segment are reflective of how well interlocutors understand each other, and the overall collaborative performance as well. Based on the above considerations, the goal of the present study is to explore how the frequency space representations of the entropy series of dialogue are correlated with the collaborative performance of task. We first demonstrate that entropy series satisfy the prerequisites of spectral analysis techniques in Section 4. Then we use two frequency space statistics, power spectrum overlap ( PSO ) and relative phase ( RP ), to predict task success. The reasons of using these two specific indices are discussed in Section 2.3, and their definitions are given in Section 3.3. The results are shown in Sections 5 to 7, and the implications are discussed. 2 Related Work 2.1 The success of dialogue The interactive-alignment model ( IAM ) ( Pickering and Garrod , 2004 ) stipulates that communication is successful to the extent that communicators “ understand relevant aspects of the world in the same way as each other ” ( Garrod and Pickering , 2009 ) . Qualitative and quantitative studies ( Garrod and A. Anderson, 1987; Pickering and Garrod, 2006; Reitter and Moore, 2014 ) have revealed that the alignment of linguistic elements at different representation levels between interlocutors facilitates the success of task-oriented dialogues. More recently , different theoretical accounts other than IAM , such as interpersonal synergy ( Fusaroli et al . , 2014 ) and complexity matching ( Abney et al . , 2014 ) have been proposed to explain the mechanism of successful dialogue from the perspective of dynamic systems . Fusaroli and Tyle´n ( 2016 ) compare the approaches of interactive alignment and interpersonal synergy in terms of how well they predict the collective performance in a joint task. They find that the synergy approach is a better predictor than the alignment approach. Abney et al. ( 2014 ) differentiate the concepts of behavior matching and complexity matching in dyadic interaction. They demonstrate the acoustic onset events in speech signals exhibit power law clustering across timescales, and the complexity matching in these power law functions is reflective of whether the conversation is affiliative or argumentative. The perspective taken by the present study has some common places with Fusaroli and Tyle´n ( 2016 ) and Abney et al.’s ( 2014 ) work: we view dialogue as an interaction of two dynamic systems. The joint decision-making task used by Fusaroli and Tyle´n ( 2016 ) resulted in a small corpus of dialogue in Danish, which we will use for the present study. 2.2 Information density in natural language Information Theory ( Shannon, 1948 ) predicts that the optimal way to communicate is to send information at a constant rate, a.k.a. the principle of entropy rate constancy ( ERC ). The way humans use natural language to communicate also follows this principle: by computing the local per-word entropy of the sentence ( which, under the prediction of ERC, will increase with sentence position ), ERC is confirmed in both written text ( Genzel and Charniak, 2002; Genzel and Charniak, 2003; Keller, 2004; Qian and Jaeger, 2011 ) and spoken dialogue ( Xu and Reitter, 2016b; Xu and Reitter, 2016a ). The theory of uniform information density ( UID ) extends ERC to syntactic representations ( Jaeger, 2010 ) and beyond. The information density in language, i.e., the distribution of entropy ( predictability ), reveal the discourse structure to some extent. For example, entropy drops at the boundaries between topics ( Genzel and Charniak, 2003; Qian and Jaeger, 2011 ), and increases within a topic episode in dialogue ( Xu and Reitter, 2016b ) ( see Section 1.1 ). The entropy of microblog text reflects changes in contextual information ( e.g., an unexpected event in a sports game ) ( Doyle and Frank, 2015 ). In sum, per-word entropy quantifies the amount of lexical information in natural language, and therefore fulfills the needs of modeling the information contribution from interlocutors. 2.3 Spectral analysis methodology Spectral analysis, also referred to as frequency domain analysis, is a pervasively used technique in physics, engineering, economics and social sciences. The key idea of it is to decompose a complex signal in time space into simpler components in frequency space, using mathematical operations such as Fourier transform ( Bracewell, 1986 ). The application of spectral analysis in human language technology mainly focuses on processing the acoustic signals of human voice, and capturing the para-linguistics features relevant to certain tasks ( Schuller et al., 2013 ). For example, Bitouk et al. ( 2010 ) find that utterance-level spectral features are useful for emotion recognition. Gregory Jr and Gallagher ( 2002 ) demonstrate that spectral information beneath 0.5 kHz can predict US president election outcomes. However, we are not aware of the usage of spectral analysis in studying linguistic phenomena at higher representation levels than the acoustic level. For our study, we are looking for some techniques that can capture the coupling between two signals at frequency space. The nature of the signal ( whether it is language-related or not ) should not be the first concern from the perspective of methodology. Therefore, studies outside the field of speech communication and linguistics could also be enlightening to our work. After searching the literature, we find that the spectral analysis techniques that Oullier et al. ( 2002 ) and Oullier et al. ( 2008 ) use to study the physical and social functions of human body movement are useful to our research goal. In Oullier et al.’s ( 2002 ) work, subjects stood in a moving room and were to track a target attached to the wall. A frequency space statistics, power spectrum overlap ( PSO ), was used to demonstrate the coupling between motion of the room and motion of the subject’s head. Stronger coupling effect ( higher PSO ) was found in the tracking task than a no-tracking baseline. PSO in nature quantifies how much the frequency space representations of two signals ( power spectrum density ) overlap. It allows us to explore the frequency space coupling of two interlocutors’ entropy series in dialogue. Similarly, Oullier et al. ( 2008 ) used the metrics of peak-to-peak relative phase ( RP ) and PSO to study the spontaneous synchrony in behavior that emerges between interactants as a result of information exchange. The signals to be analyzed were the flexion-extension movement of index fingers of two subjects sitting in front of each other. Both metrics showed different patterns when the participants see each other or not. RP, in their work, measures the magnitude of delay between two signals, and it corresponds to the notion of φ in Section 1.1. 3 Methods 3.1 Corpus data Two corpora are examined in this study : the HCRC Map Task Corpus ( A . H . Anderson et al . , 1991 ) and a smaller corpus in Danish from a joint decision-making study ( Fusaroli et al . , 2012 ) , henceforth DJD . Map Task contains a set of 128 dialogues between two subjects , who accomplished a cooperative task together . They were given two slightly different maps of imaginary landmarks. One of them plays as the instruction giver, who has routes marked on her map, and the other plays as the instruction follower, who does not have routes. The task for them is to reproduce the giver’s route on the follower’s map. The participants are free to speak, but they cannot see each other’s map. The whole conversations were recorded, transcribed and properly annotated. The collaborative performance in the task is measured by the PATHDEV variable, which quantifies the deviation between the paths drawn by interlocutors. Larger values indicate poorer task performance. DJD contains a set of 16 dialogues from native speakers of Danish ( 11,100 utterances and 56,600 words ) . In Fusaroli et al.’s ( 2012 ) original study the participants were to accomplish a series of visual perception task trials, by discussing the stimuli they saw and reaching a joint decision for each trial. The collaborative performance is measured by the CollectivePerformance variable, which is based on a psychometric function that measures the sensitivity of the dyad’s joint decision to the actual contrast difference of the trial ( Fusaroli et al., 2012 ). Higher value of this variable indicates better task performance. The Switchboard Corpus ( Godfrey et al . , 1992 ) is used to train the language model for estimating the sentence entropy in Map Task . The Copenhagen Dependency Treebanks Corpus1 is used for the same purpose for DJD . 3.2 Estimating information density in dialogue The information density of language is estimated at the sentence level , by computing the per-word entropy of each sentence using a trigram language model trained from a different corpus . We consider a sentence to be a sequence of words , S = { w1 , w2 , . . . , wn } , and the per-word entropy is estimated by : whereP ( wi | w1 . . . wi − 1 ) is estimated by a trigram model that is trained from an outside corpus . The SRILM software ( Stolcke , 2002 ) is used to train the language model and to compute sentence entropy . Dialogue is a sequence of utterances contributed by two interlocutors. For the k th dialogue whose total utterance number is Nk, we mark it as Dk = {uki | i = 1, 2, . . . , Nk}, in which uki is the i th utterance. Map Task contains annotations of sentence structure in utterances , and one utterance could consist of several sentences that are syntactically independent . Thus we further split Dk into a sequence of sentence, Dk = {ski | i = 1, 2, . . . , N ′k}, in whichN ′k is number of sentences in Dk. Since DJD lacks the sentence annotations , we do not further split the utterance sequence , and simply treat an utterance as a complete sentence . Given a sequence {ski } ( Map Task ), or {uki } ( DJD ), we calculate the per-word entropy for each item in the sequence: where H( ski  ) or H( u k i  ) is computed according to Equation 1. Then we split the entropy series Hk into two sub-series by the source of utterances ( i.e., who speaks them ), resulting in HAk for interlocutor A, and HBk for interlocutor B. For Map Task , the two interlocutors have distinct roles , instruction giver and follower . Thus the resulting two entropy series are Hgk and H f k . These per-interlocutor entropy series will be the input of our next-step spectral analysis. 3.3 Computing power spectrum overlap and relative phase The time intervals between utterances ( or sentences ) vary, but since we care about the average information contribution within a complete semantic unit, we treat entropy series as regular time series. The time scale is not measured in seconds but in turns ( or sentences ). For a given dialogue Dk , we apply the fast Fourier transform ( FFT ) on its two entropy series HAk and H B k , and obtain the power spectra ( or , power spectral density plots ) of them , PAk and PBk . The power spectra are estimated with the periodogram method provided by the open source R software . The Y axis of a power spectrum is the squared amplitude of signal ( or power ), and X axis ranges from 0 to pi/2 ( we do not have sampling frequency, thus the X axis is in angular frequency but not in Hz ). The power spectrum overlap, PSOk, is calculated by computing the common area under the curves of PAk and P B k is calculated, and normalizing by the total area of the two curves ( see Figure 2 ). PSOk ranges from 0 to 1, and a larger value indicates higher similarity between PAk and P B k . The relative phase ( RP ) between HAk and H B k is directly returned by the spectrum function in R. It is a vector of real numbers that range from 0 to pi, and each element represent the phase difference between two signals at a particular frequency position of the spectrum. 4 Prerequisites of Spectral Analysis Before proceeding to the actual analysis, we first examine whether the data we use satisfy some of the prerequisites of spectral analysis techniques. One common assumption of Fourier transforms is that the signals ( time series ) are stationary ( Dwivedi and Subba Rao, 2011 ). Stationarity means that the mean, variance and other distributional properties do not change over time ( Natrella, 2010 ). Another presumption we hold is that the entropy series contain some periodic patterns ( see Section 1.1 ), which means their power spectrum should differ from that of white noise. 4.1 Examine stationarity We use three pervasively used statistical tests to test the stationarity of our entropy series data : the augmented Dickey-Fuller ( ADF ) test ( Dickey and Fuller , 1979 ) , the Kwiatkowski-Phillips-Schmidt-Shin ( KPSS ) test ( Kwiatkowski et al . , 1992 ) , and the Phillips-Perron ( PP ) test ( Phillips and Perron , 1988 ) . The percentage of entropy series that pass the stationarity tests are shown in Table 1. We can see that the majority of our data satisfy the assumption of stationarity , and thus it is valid to conduct Fourier transform on the entropy series . The stationarity property seems contradictory to the previous findings about entropy increase in written text and spoken dialogue ( Genzel and Charniak, 2002; Genzel and Charniak, 2003; Xu and Reitter, 2016b ), because stationarity predicts that the mean entropy stays constant over time. We examine this in our data by fitting a simple linear model with entropy as the dependent, and sentence position as the independent variable, which yields significant ( marginal ) effects of the latter: For Map Task, β = 2.3× 10−3, p < .05, Adj-R2 = 1.7× 10−4; For DJD, β = 7.2× 10−5, p = .06, Adj-R2 = 2.2× 10−4. It indicates that the stationarity of entropy series does not conflict with the entropy increasing trend predicted by the principle of ERC ( Shannon, 1948 ). We conjecture that stationarity satisfies because the effect size ( Adj-R2 ) of entropy increase is very small. 4.2 Comparison with white noise Power spectra for all entropy series are obtained with an FFT . We compare them with those of white noise. The white noise data are simulated with i.i.d. random data points that are generated from normal distributions ( same means and standard deviations as the actual data ). Figure 3 shows the smoothed average spectrums of the actual entropy data and the simulated white noise data. White noise signals should demonstrate a constant power spectral density ( Narasimhan and Veena, 2005 ), and if the entropy series is not completely random, then their average spectrum should be flat. Linear models show that the average spectrums of the entropy data have slopes that are significantly larger than zero ( For Map Task, β = 2.3× 10−2, SE = 9.4× 10−3, p < .05; for DJD, β = 314.1, SE = 19.8, p < .001 ), while the slopes of the white noise data are not significantly different from zero. This confirms our presumption that the entropy series of dialogue contains some periodic patterns that are identifiable in frequency space. We also conduct Ljung-Box test ( Ljung and Box , 1978 ) to examine how the entropy series is different from white noise . The null hypothesis is that the time series being tested is independent of the lagged sequence of itself. The test on a white noise series will give big p-values, for any lags greater than 0, because of its randomness nature. We try several lags on each entropy series, and pick the smallest p-value. Consequently , we obtain a mean p-value of .23 on MapTask , and a mean p-value of .27 on DJD . Therefore, we cannot reject the null hypothesis for all the entropy series data, but the Type-I error of considering them as different form white noise is pretty low. 5 PSO Predicts Task Success 5.1 Results of linear models We compute PSO for all the dialogues in Map Task and DJD and fit two linear models using PSO as predictor , with PATHDEV and CollectivePerformance as dependent variables respectively . PSO is a reliable predictor in both models ( p < .05 ). The coefficients are shown in Table 2. Since PATHDEV is a measure of failure, but collaborative task performance is a measure of success, the negative correlation between PSO and collaborative task performance is consistent. Regression lines with residuals are plotted in Figure 4. Figure 4 ( a ) suggests a heteroscedasticity problem, because the right half of data points seem to stretch up along the y axis. This was confirmed by a Breush-Pagan test ( Breusch and Pagan , 1979 ) ( BP = 5.62 , p < .05 ) . To rectify this issue , we adopt a Box-Cox transformation ( Box and Cox , 1964 ) on the dependent variable , PATHDEV , which is a typical way of handling heteroscedasticity . The new model that uses PSO to predict the Box-Cox transformed PATHDEV also yields significant coefficients : β = 3.85 , SE = 1.67 , F ( 1 , 113 ) = 5.32 , p < .05 . Therefore, the correlation between PSO and PATHDEV is reliable. As for DJD , due to the lack of data ( we only have 16 dialogues ) , we do not run further diagnostics analysis on the regression model . 5.2 Discussion The coupling of entropy series in frequency space is negatively correlated with task success. In other words, synchrony between interlocutors in terms of their information distribution hinders the success of collaboration. By “synchrony”, we mean an overlap in the frequencies at which they choose to inject novel information into the conversation. This conclusion seems contradictory to the perspective of interactive alignment at the first glance. However, here we are starting with a very high-level model of dialogue that has does not refer to linguistic devices. Instead, we utilize the concept of “information density” and the entropy metric of natural language, to paint the picture of a system in which communicators inject novelty into the dialogue, and that each communicator does so regularly and with a set of overlapping frequencies. We assume that the rapid change of sentence entropy, i.e., the high frequency components in the spectrum, correspond to the moments in conversation where one interlocutor brings relatively novel content to the table, such as a detailed instruction, a strange question, an unexpected response etc. This assumption is reasonable because previous work has shown that sudden change in entropy predicts topic change in dialogue ( Genzel and Charniak, 2003; Qian and Jaeger, 2011; Xu and Reitter, 2016b ). We argue that higher synchrony ( larger overlap in frequency space ) in terms of how much novelty each interlocutor contributes, does not necessarily leads to better outcomes of communication. Rather, we would expect the correlation to be opposite ( and our empirical results confirm this ), because dialogue is a joint activity, in which a taking on different roles as interlocutors ( e.g., the one who gives orders versus the one who follows ) is often required to push the activity along ( Clark, 1996 ). A dialogue with maximal synchrony or frequency overlap would be one where partners take turns at regular intervals. Perhaps because such regularity in turn-taking assigns no special roles to interlocutors, and because they engage in turntaking with no regard for content, it is not strange that such synchrony is disadvantageous. Let’s look at several scenarios of different synchrony levels between interlocutors: First, high synchrony due to both interlocutors contributing large amount of new information, which means there is more overlap near the high frequency band of spectrums. In this case, they are more likely to have difficulty in comprehending each other due to the potential information overload. Situations such as arguing, or both speakers asking a lot of questions are good examples. Second, high synchrony due to both interlocutors providing ineffective information, which indicates overlap in spectrums near the low frequency band. Obviously this type of ineffective communication is not helpful to the collaborative task. Third, low synchrony due to one interlocutor providing more information and the other one providing less, which means the overlap in spectrums is minimum. An example of this case is that one interlocutor is saying something important, while the other one is producing short utterances such “uh-huh”, “yes”, or short questions to make sure that they are on the same page, which is known as the back-channel mechanism in conversation ( Orestro¨m, 1983 ). This complementary style of communication allows them to build mutual understand of each other’s intention, and thus reaches better collaborative performance. 6 RP Predicts Task Success 6.1 Results of linear models We obtain the relative phase ( RP ) vector ( absolute values ) of all frequency components, and fit linear models using the mean of RP as predictor, and task performance as the dependent variable. We get non-significant coefficients for both models : For Map Task , F ( 1 , 113 ) = .004 , p > .05 ; for DJD , F ( 1 , 14 ) = .772 , p > .05 . This suggests that the phase information of all frequency components in spectrum is not very indicative of task success. The power spectra describe the distribution of energy across the span of frequency components that compose the signal. The frequency components with higher energy ( peaks in spectrum ) are more dominant than those with lower energy ( troughs ) in determining the nature of the signal. Therefore it makes sense to only include the peak frequencies into the model, because they are more “representative” of the signal, and so the “noise” from the low energy frequencies are filtered out. Thus we obtain RP from the local peak frequency components, and use the mean, median, and maximum values of them as predictors. It turns out that for Map Task , the maximum of RP is a significant predictor ( the mean and median are left out via stepwise analysis ) . For DJD , the mean of RP is a significant predictor of task success ( when median and maximum are included in the model ) . ( see Table 3 ) . ( see Table 3 ). From the significant effect of maximum RP in Map Task and mean RP in DJD , it is safe to state that RP is positively correlated with task performance . However, this relationship is not as straight-forward as PSO, because of the marginal effect at the opposite direction. A more finegrained analysis is required, but it is outside the scope of this study. 6.2 Discussion The relative phase in frequency space can be understood as the “lag” between signals in time space. Imagine that we align the two entropy series from one dialogue onto the same time scale ( just like Figure 1 ), the distance between the entropy “peaks” is proportionate to the relative phase in frequency space. Then, the positive correlation between relative phase and task performance suggests that relatively large delays between entropy “surges” seen in each interlocutor are beneficial to collaborative performance. The delay of entropy surges can be understood as a strategy for an interlocutor to distribute information in his or her own utterance accordingly with the information received. For example, after interlocutor A contributes a big piece of information, the other one, B, does not rush to make new substantial contributions, but instead keeps her utterances at low entropy until it is the proper time to take a turn to contribute. This does not have to coincide with dialogic turn-taking. This delay gives B more time to “digest” the information provided by A, which could be an instruction that needs to be comprehended, or a question that needs to be thought about and so on. A relatively long delay guarantees enough time for interlocutors to reach mutual understanding. On the contrary, if B rushes to speak a lot shortly after the A’s input, then it will probably cause information overload and be harmful to communication. Therefore, we believe that the RP statistic captures the extent to which interlocutors manage the proper “timing” of information contribution to maintain effective communication. 7 Prediction Task Here we explore whether the frequency domain features , PSO and RP , can help with an existing framework that utilizes alignment features , such as the repetition of lexical and syntactic elements , to predict the success of dialogue in MapTask ( Reitter and Moore , 2007 ) . R & M described an SVM model that takes into the repetition count of lexicons ( LEXREP ) and syntax structures ( SYNREP ) , and the length of dialogues ( LENGTH ) as features . The full model achieves an R2 score of .17, which means that it can account for 17% of the variance of task success. We add the new PSO and RP ( mean , median and maximum RP features per dialogue are included ) covariates to the original SVM model . An RBF kernel ( γ = 5 ) was used. The cost parameter C was ( coarsely ) tuned on different cross-validation folds to reduce overfitting on this relatively small dataset, and the R&M’s original full model was recalculated ( shown in Table 4 as R&M ). Two models with PSO and RP interactions ( once without the alignment/repetition features ) are shown for comparison. ( See Table 4 ). Significant improvement in the model’s explanatory power, i.e., R2, is gained after the PSO and RP features are added. The best model we have is by adding PSO and RP as predictors without the interaction term ( bold number in Table 4 ), which gives about 60% increase of R2 compared to R&M’s full model. Note that even if we exclude the alignment features, and include only ( LENGTH ) and the frequency features ( last row in Table 4 ), the performance also exceeds R&M’s full model. The results indicate that the frequency domain features ( PSO and RP ) of the sentence information density can capture some hidden factors of task success that are unexplained by the alignment approach. It is not surprising that how people coordinate their information contribution matters a lot to the success of the collaboration. What we show here is that regular, repeated patterns of information-dense and information-sparse turns seem to make speakers more or less compatible with each other. Whether individuals have typical patterns ( frequency distributions ) of information density, or whether this is a result of dynamic interaction in each particular dialogue, remains to be seen. 8 Conclusions The empirical results of the present study suggest that examining how the information contribution from interlocutors co-develops can provide a way to understand dialogue from a higher-level perspective, which has been missing in existing work. Our work adds a brick to the series of endeavors on studying the linguistic and behavioral factors of successful dialogue, and for the first time ( as far as we know ) demonstrates quantitatively that the dynamics of not just “what” and “how” we say, but also “how much” we say and the “timing” of distributing what we say in dialogue, are relevant to the quality of communication. Although the way we model information in language is simply the entropy at lexical level, we believe the findings still reveal the nature of information production and processing in dialogue. We hope that by comparing and combining our methodology with other approaches of studying dialogue, we can reach a more comprehensive and holistic understanding of this common yet mysterious human practice. "}
  },
    {
    "id": "P18-1003",
    "result":     [
            {
        "value":         {
          "start": 96,
          "end": 100,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 596,
          "end": 600,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 670,
          "end": 672,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 3841,
          "end": 3845,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 3911,
          "end": 3922,
          "text": "PMI-weighted",
          "labels": ["Method"]
        },
        "id": 1301
      },
            {
        "value":         {
          "start": 3924,
          "end": 3935,
          "text": "bag-of-words",
          "labels": ["Method"]
        },
        "id": 1302
      },
            {
        "value":         {
          "start": 4013,
          "end": 4024,
          "text": "bag-of-words",
          "labels": ["Method"]
        },
        "id": 1302
      },
            {
        "value":         {
          "start": 4069,
          "end": 4071,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 6271,
          "end": 6294,
          "text": "bootstrapping strategies",
          "labels": ["Method"]
        },
        "id": 1302
      },
            {
        "value":         {
          "start": 7142,
          "end": 7163,
          "text": "convolutional networks",
          "labels": ["Method"]
        },
        "id": 1303
      },
            {
        "value":         {
          "start": 7412,
          "end": 7445,
          "text": "recursive neural networks ( RNNs )",
          "labels": ["Method"]
        },
        "id": 1304
      },
            {
        "value":         {
          "start": 7579,
          "end": 7583,
          "text": "LSTMs",
          "labels": ["Method"]
        },
        "id": 1414
      },
            {
        "value":         {
          "start": 8388,
          "end": 8409,
          "text": "ParagraphVector method",
          "labels": ["Method"]
        },
        "id": 1305
      },
            {
        "value":         {
          "start": 9260,
          "end": 9292,
          "text": "Knowledge Graph Embedding ( KGE )",
          "labels": ["Method"]
        },
        "id": 1306
      },
            {
        "value":         {
          "start": 9403,
          "end": 9412,
          "text": "KGE models",
          "labels": ["Method"]
        },
        "id": 1308
      },
            {
        "value":         {
          "start": 9511,
          "end": 9520,
          "text": "KGE models",
          "labels": ["Method"]
        },
        "id": 1308
      },
            {
        "value":         {
          "start": 9859,
          "end": 9863,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 9964,
          "end": 9974,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 10135,
          "end": 10170,
          "text": "Pointwise Mutual Information ( PMI )",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 10263,
          "end": 10273,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 10946,
          "end": 10956,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 11163,
          "end": 11173,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 11211,
          "end": 11246,
          "text": "pointwise mutual information ( PMI )",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 11292,
          "end": 11294,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 11538,
          "end": 11540,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 11810,
          "end": 11820,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 12003,
          "end": 12013,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 12154,
          "end": 12156,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 12382,
          "end": 12384,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 12712,
          "end": 12720,
          "text": "Skip-gram",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 13279,
          "end": 13281,
          "text": "SGD",
          "labels": ["Method"]
        },
        "id": 1312
      },
            {
        "value":         {
          "start": 13381,
          "end": 13385,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 14248,
          "end": 14250,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 15213,
          "end": 15223,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 15416,
          "end": 15418,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 15735,
          "end": 15745,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 16007,
          "end": 16009,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 16818,
          "end": 16820,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 17116,
          "end": 17118,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 17195,
          "end": 17197,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 17258,
          "end": 17260,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 17930,
          "end": 17934,
          "text": "GloVe",
          "labels": ["Method"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 19111,
          "end": 19113,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 20612,
          "end": 20625,
          "text": "Wikipedia dump",
          "labels": ["Dataset"]
        },
        "id": 1310
      },
            {
        "value":         {
          "start": 20900,
          "end": 20932,
          "text": "Apache sentence segmentation tool",
          "labels": ["Tool"]
        },
        "id": 1311
      },
            {
        "value":         {
          "start": 21166,
          "end": 21168,
          "text": "SGD",
          "labels": ["Method"]
        },
        "id": 1312
      },
            {
        "value":         {
          "start": 21493,
          "end": 21517,
          "text": "Zettair3 retrieval engine",
          "labels": ["Tool"]
        },
        "id": 1312
      },
            {
        "value":         {
          "start": 23263,
          "end": 23285,
          "text": "Google Analogy Test Set",
          "labels": ["Dataset"]
        },
        "id": 1313
      },
            {
        "value":         {
          "start": 23387,
          "end": 23401,
          "text": "DiffVec dataset",
          "labels": ["Dataset"]
        },
        "id": 1314
      },
            {
        "value":         {
          "start": 23636,
          "end": 23661,
          "text": "10 - fold cross-validation",
          "labels": ["Method"]
        },
        "id": 1315
      },
            {
        "value":         {
          "start": 24587,
          "end": 24607,
          "text": "linear SVM classifier",
          "labels": ["Method"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 24640,
          "end": 24642,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 24722,
          "end": 24724,
          "text": "SVM",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 24832,
          "end": 24839,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24864,
          "end": 24872,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24876,
          "end": 24881,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 24887,
          "end": 24894,
          "text": "F1 score",
          "labels": ["Metric"]
        },
        "id": 1317
      },
            {
        "value":         {
          "start": 25221,
          "end": 25231,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 25235,
          "end": 25242,
          "text": "SkipGram",
          "labels": ["Method"]
        },
        "id": 1317
      },
            {
        "value":         {
          "start": 25252,
          "end": 25289,
          "text": "Continuous Bag of Words ( CBOW ) model",
          "labels": ["Method"]
        },
        "id": 1318
      },
            {
        "value":         {
          "start": 25368,
          "end": 25378,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 25453,
          "end": 25460,
          "text": "Diff-Vec",
          "labels": ["Dataset"]
        },
        "id": 1321
      },
            {
        "value":         {
          "start": 25660,
          "end": 25662,
          "text": "PMI",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 25728,
          "end": 25738,
          "text": "GloVe model",
          "labels": ["Method"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 26066,
          "end": 26073,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 26087,
          "end": 26093,
          "text": "DiffVec",
          "labels": ["Dataset"]
        },
        "id": 1320
      },
            {
        "value":         {
          "start": 26377,
          "end": 26384,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 26397,
          "end": 26404,
          "text": "Diff-Vec",
          "labels": ["Dataset"]
        },
        "id": 1321
      },
            {
        "value":         {
          "start": 27372,
          "end": 27390,
          "text": "SemEval 2012 Task 2",
          "labels": ["Dataset"]
        },
        "id": 1321
      },
            {
        "value":         {
          "start": 27427,
          "end": 27453,
          "text": "“ Phase2AnswerScaled ” data",
          "labels": ["Dataset"]
        },
        "id": 1322
      },
            {
        "value":         {
          "start": 27464,
          "end": 27488,
          "text": "platinum rankings dataset",
          "labels": ["Dataset"]
        },
        "id": 1323
      },
            {
        "value":         {
          "start": 27911,
          "end": 27937,
          "text": "linear SVM regression model",
          "labels": ["Method"]
        },
        "id": 1324
      },
            {
        "value":         {
          "start": 28077,
          "end": 28091,
          "text": "SVM based model",
          "labels": ["Method"]
        },
        "id": 1325
      },
            {
        "value":         {
          "start": 28162,
          "end": 28175,
          "text": "Spearman ’ s ρ",
          "labels": ["Metric"]
        },
        "id": 1326
      },
            {
        "value":         {
          "start": 29116,
          "end": 29144,
          "text": "New York Times ( NYT ) corpus",
          "labels": ["Dataset"]
        },
        "id": 1327
      },
            {
        "value":         {
          "start": 29255,
          "end": 29262,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 29563,
          "end": 29573,
          "text": "NYT corpus6",
          "labels": ["Dataset"]
        },
        "id": 1328
      },
            {
        "value":         {
          "start": 29589,
          "end": 29597,
          "text": "Wikipedia",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 29893,
          "end": 29900,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 29993,
          "end": 30013,
          "text": "linear SVM classifier",
          "labels": ["Method"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 30028,
          "end": 30035,
          "text": "Freebase",
          "labels": ["Dataset"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 30196,
          "end": 30211,
          "text": "linear SVM model",
          "labels": ["Method"]
        },
        "id": 1329
      },
            {
        "value":         {
          "start": 30655,
          "end": 30664,
          "text": "SVM models",
          "labels": ["Method"]
        },
        "id": 1330
      },
            {
        "value":         {
          "start": 30772,
          "end": 30775,
          "text": "SVMs",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 30784,
          "end": 30799,
          "text": "quadratic kernel",
          "labels": ["Method"]
        },
        "id": 1333
      },
            {
        "value":         {
          "start": 30884,
          "end": 30898,
          "text": "precisionrecall",
          "labels": ["Metric"]
        },
        "id": 1332
      },
            {
        "value":         {
          "start": 31007,
          "end": 31012,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31045,
          "end": 31060,
          "text": "quadratic kernel",
          "labels": ["Method"]
        },
        "id": 1333
      },
            {
        "value":         {
          "start": 31102,
          "end": 31118,
          "text": "linear SVM models",
          "labels": ["Method"]
        },
        "id": 1333
      },
            {
        "value":         {
          "start": 31406,
          "end": 31440,
          "text": "convolutional neural network models",
          "labels": ["Method"]
        },
        "id": 1334
      },
            {
        "value":         {
          "start": 31447,
          "end": 31466,
          "text": "attention mechanisms",
          "labels": ["Method"]
        },
        "id": 1335
      },
            {
        "value":         {
          "start": 31628,
          "end": 31643,
          "text": "PCNN + ATT model",
          "labels": ["Method"]
        },
        "id": 1336
      },
            {
        "value":         {
          "start": 31698,
          "end": 31703,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31892,
          "end": 31910,
          "text": "attention mechanism",
          "labels": ["Method"]
        },
        "id": 1547
      },
            {
        "value":         {
          "start": 31921,
          "end": 31936,
          "text": "PCNN + ATT model",
          "labels": ["Method"]
        },
        "id": 1336
      }
    ],
    "data": {"text": "Unsupervised Learning of Distributional Relation Vectors Abstract Word embedding models such as GloVe rely on co-occurrence statistics to learn vector representations of word meaning . While we may similarly expect that cooccurrence statistics can be used to capture rich information about the relationships between different words, existing approaches for modeling such relationships are based on manipulating pre-trained word vectors. In this paper, we introduce a novel method which directly learns relation vectors from co-occurrence statistics. To this end , we first introduce a variant of GloVe , in which there is an explicit connection between word vectors and PMI weighted co-occurrence vectors . We then show how relation vectors can be naturally embedded into the resulting vector space. 1 Introduction Word embeddings are vector space representations of word meaning ( Mikolov et al., 2013b; Pennington et al., 2014 ). A remarkable property of these models is that they capture various lexical relationships, beyond mere similarity. For example, ( Mikolov et al., 2013b ) found that analogy questions of the form “a is to b what c is to ?” can often be answered by finding the word d that maximizes cos( wb−wa+wc, wd ), where we write wx for the vector representation of a word x. Intuitively, the word vector wa represents a in terms of its most salient features. For example, wparis implicitly encodes that Paris is located in France and that it is a capital city, which is intuitively why the ‘capital of’ relation can be modeled in terms of a vector difference. Other relationships, however, such as the fact that Macron succeeded Hollande as president of France, are unlikely to be captured by word embeddings. Relation extraction methods can discover such information by analyzing sentences that contain both of the words or entities involved ( Mintz et al., 2009; Riedel et al., 2010; dos Santos et al., 2015 ), but they typically need a large number of training examples to be effective. A third alternative, which we consider in this paper, is to characterize the relatedness between two words s and t by learning a relation vector rst in an unsupervised way from corpus statistics. Among others, such vectors can be used to find word pairs that are similar to a given word pair ( i.e. finding analogies ), or to find the most prototypical examples among a given set of relation instances. They can also be used as an alternative to the aforementioned relation extraction methods, by subsequently training a classifier that uses the relation vectors as input, which might be particularly effective in cases where only limited amounts of training data are available ( with the case of analogy finding from a single instance being an extreme example ). The most common unsupervised approach for learning relation vectors consists of averaging the embeddings of the words that occur in between s and t, in sentences that contain both ( Weston et al., 2013; Fan et al., 2015; Hashimoto et al., 2015 ). While this strategy is often surprisingly effective ( Hill et al., 2016 ), it is sub-optimal for two reasons. First, many of the words co-occurring with s and t will be semantically related to s or to t, but will not actually be descriptive for the relationship between s and t; e.g. the vector describing the relation between Paris and France should not be affected by words such as eiffel ( which only relates to Paris ). Second, it gives too much weight to stopwords, which cannot be addressed in a straightforward way as some stop-words are actually crucial for modeling relationships ( e.g. prepositions such as ‘in’ or ‘of’ or Hearst patterns ( Indurkhya and Damerau, 2010 ) ). In this paper, we propose a method for learning relation vectors directly from co-occurrence statistics. We first introduce a variant of GloVe , in which word vectors can be directly interpreted as smoothed PMI-weighted bag-of-words representations . We then represent relationships between words as weighted bag-of-words representations , using generalizations of PMI to three arguments , and learn vectors that correspond to smoothed versions of these representations . As far as the possible applications of our methodology is concerned, we imagine that relation vectors can be used in various ways to enrich the input to neural network models. As a simple example, in a question answering system, we could “annotate” mentions of entities with relation vectors encoding their relationship to the different words from the question. As another example, we could consider a recommendation system which takes advantage of vectors expressing the relationship between items that have been bought ( or viewed ) by a customer and other items from the catalogue. Finally, relation vectors should also be useful for knowledge completion, especially in cases where few training examples per relation type are given ( meaning that neural network models could not be used ) and where relations cannot be predicted from the already available knowledge ( meaning that knowledge graph embedding methods could not be used, or are at least not sufficient ). 2 Related Work The problem of characterizing the relationship between two words has been studied in various settings. From a learning point of view, the most straightforward setting is where we are given labeled training sentences, with each label explicitly indicating what relationship is expressed in the sentence. This fully supervised setting has been the focus of several evaluation campaigns, including as part of ACE ( Doddington et al., 2004 ) and at SemEval 2010 ( Hendrickx et al., 2010 ). A key problem with this setting, however, is that labeled training data is hard to obtain. A popular alternative is to use known instances of the relations of interest as a form of distant supervision ( Mintz et al., 2009; Riedel et al., 2010 ). Some authors have also considered unsupervised relation extraction methods ( Shinyama and Sekine, 2006; Banko et al., 2007 ), in which case the aim is essentially to find clusters of patterns that express similar relationships, although these relationships may not correspond to the ones that are needed for the considered application. Finally , several systems have also used bootstrapping strategies ( Brin , 1998 ; Agichtein and Gravano , 2000 ; Carlson et al . , 2010 ) , where a small set of instances are used to find extraction patterns , which are used to find more instances , which can in turn be used to find better extraction patterns , etc . Traditionally, relation extraction systems have relied on a variety of linguistic features, such as lexical patterns, part-of-speech tags and dependency parsers. More recently, several neural network architectures have been proposed for the relation extraction problem. These architectures rely on word embeddings to represent the words in the input sentence, and manipulate these word vectors to construct a relation vector. Some approaches simply represent the sentence ( or the phrase connecting the entities whose relationship we want to determine ) as a sequence of words , and use e.g . convolutional networks to aggregate the vectors of the words in this sequence ( Zeng et al . , 2014 ; dos Santos et al . , 2015 ) . Another possibility , explored in ( Socher et al . , 2012 ) , is to use parse trees to capture the structure of the sentence , and to use recursive neural networks ( RNNs ) to aggregate the word vectors in a way which respects this structure . A similar approach is taken in ( Xu et al . , 2015 ) , where LSTMs are applied to the shortest path between the two target words in a dependency parser . A straightforward baseline method is to simply take the average of the word vectors ( Mitchell and Lapata, 2010 ). While conceptually much simpler, variants of this approach have obtained state-of-the-art performance for relation classification ( Hashimoto et al., 2015 ) and a variety of tasks that require sentences to be represented as a vector ( Hill et al., 2016 ). Given the effectiveness of word vector averaging, in ( Kenter et al., 2016 ) a model was proposed that explicitly tries to learn word vectors that generalize well when being averaged. Similarly, the model proposed in ( Hashimoto et al., 2015 ) aims to produce word vectors that perform well for the specific task of relation classification. The ParagraphVector method from ( Le and Mikolov , 2014 ) is related to the aformentioned approaches , but it explicitly learns a vector representation for each paragraph along with the word embeddings . However, this method is computationally expensive, and often fails to outperform simpler approaches ( Hill et al., 2016 ). To the best of our knowledge, existing methods for learning relation vectors are all based on manipulating pre-trained word vectors. In contrast, we will directly learn relation vectors from corpus statistics, which will have the important advantage that we can focus on words that describe the interaction between the two words s and t, i.e. words that commonly occur in sentences that contain both s and t, but are comparatively rare in sentences that only contain s or only contain t. Finally , note that our work is fundamentally different from Knowledge Graph Embedding ( KGE ) ( Wang et al . , 2014b ) , ( Wang et al . , 2014a ) , ( Bordes et al . , 2011 ) in at least two ways : ( i ) KGE models start from a structured knowledge graph whereas we only take a text corpus as input , and ( ii ) KGE models represent relations as geometric objects in the “ entity embedding ” itself ( e.g . as translations , linear maps , combinations of projections and translations , etc ) , whereas we represent words and relations in different vector spaces . 3 Word Vectors as PMI Encodings Our approach to relation embedding is based on a variant of the GloVe word embedding model ( Pennington et al . , 2014 ) . In this section , we first briefly recall the GloVe model itself , after which we discuss our proposed variant . A key advantage of this variant is that it allows us to directly interpret word vectors in terms of the Pointwise Mutual Information ( PMI ) , which will be central to the way in which we learn relation vectors . 3.1 Background The GloVe model ( Pennington et al . , 2014 ) learns a vector wi for each word i in the vocabulary , based on a matrix of co-occurrence counts , encoding how often two words appear within a given window . Let us write xij for the number of times word j appears in the context of word i in some text corpus. More precisely, assume that there are m sentences in the corpus, and letP li ⊆ {1, ..., nl} be the set of positions from the lth sentence where the word i can be found ( with nl the length of the sentence ). Then xij is defined as follows: where weight( p, q ) = 1|p−q| if 0 < |p − q| ≤ W , and weight( p, q ) = 0 otherwise, where the window size W is usually set to 5 or 10. The GloVe model learns for each word i two vectors wi and w ˜ i by optimizing the following objective : where f is a weighting function , aimed at reducing the impact of rare terms , and bi and b ˜ j are bias terms . The GloVe model is closely related to the notion of pointwise mutual information ( PMI ) , which is defined for two words i and j as PMI ( i , j ) = log ( P ( i , j ) P ( i ) P ( j ) ) , where P ( i , j ) is the probability of seeing the words i and j if we randomly pick a word position from the corpus and a second word position within distance W from the first position . The PMI between i and j is usually estimated as follows : where xi ∗ = ∑ j xij , x ∗ j = ∑ i xij and x ∗ ∗ = ∑ i ∑ j xij . In particular , it is straightforward to see that after the reparameterization given by bi 7 → bi + log xi ∗ − log x ∗ ∗ and bj 7 → bj + log x ∗ j , the GloVe model is equivalent to . 3.2 A Variant of GloVe In this paper , we will use the following variant of the formulation in ( 1 ) : Despite its similarity , this formulation differs from the GloVe model in a number of important ways . First, we use smoothed frequency counts instead of the observed frequency counts xij . In particular , the PMI between words i and j is given as : where the probabilities are estimated as follows : where α ≥ 0 is a parameter controlling the amount of smoothing and n is the size of the vocabulary . This ensures that the estimation of PMI ( i , j ) is well-defined even in cases where xij = 0 , meaning that we no longer have to restrict the inner summation to those j for which xij > 0 . For efficiency reasons , in practice , we only consider a small subset of all context words j for which xij = 0 , which is similar in spirit to the use of negative sampling in Skip-gram ( Mikolov et al . , 2013b ) . In particular, the set Ji contains each j such that xij > 0 as well as M uniformly1 sampled context words j for which xij = 0, where we choose M = 2 · |{j : xij > 0}|. Second, following ( Jameel and Schockaert, 2016 ), the weighting function f( xij ) has been replaced by 1 σ2j , where σ2j is the residual variance of the regression problem for context word j, estimated follows: with J−1j = {i : j ∈ Ji}. Since we need the word vectors to estimate this residual variance , we reestimate σ2j after every five iterations of the SGD optimization . For the first 5 iterations , where no estimation for σ2j is available , we use the GloVe weighting function . The use of smoothed frequency counts and residual variance based weighting make the word embedding model more robust for rare words. For instance, if w only co-occurs with a handful of other terms, it is important to prioritize the most informative context words, which is exactly what the use of the residual variance achieves, i.e. σ2j is small for informative terms and large for stop words; see ( Jameel and Schockaert, 2016 ). This will be important for modeling relations, as the relation vectors will often have to be estimated from very sparse co-occurrence counts. Finally, the bias term bi has been omitted from the model in ( 2 ). We have empirically found that omitting this bias term does not affect the performance of the model , while it allows us to have a more direct connection between the vector wi and the corresponding PMI scores . 3.3 Word Vectors and PMI Let us define PMIW as follows: Clearly, when the word vectors are trained according to ( 2 ), it holds that PMIW ( i, j ) ≈ PMIS( i, j ). In other words, we can think of the word vector wi as a low-dimensional encoding of the vector ( PMIS( i, 1 ), ...,PMIS( i, n ) ), with n the number of words in the vocabulary. This view allows us to assign a natural interpretation to some word vector operations. In particular, the vector difference wi−wk is commonly used as a model for the relationship between words i and k. For a given context word j, we have. The latter is an estimation of log (  P ( i,j ) P ( i )P ( j )  ) − log (  P ( k,j ) P ( k )P ( j )  ) = log (  P ( j|i ) P ( j|k )  ) . In other words , the vector translation wi − wk encodes for each context word j the ( log ) ratio of the probability of seeing j in the context of i and in the context of k , which is in line with the original motivation underlying the GloVe model ( Pennington et al . , 2014 ) . In the following section , we will propose a number of alternative vector representations for the relationship between two words , based on generalizations of PMI to three arguments . 4 Learning Global Relation Vectors We now turn to the problem of learning a vector rik that encodes how the source word i and target word k are related. The main underlying idea is that rik will capture which context words j are most closely associated with the word pair ( i, k ). Whereas the GloVe model is based on statistics about ( main word , context word ) pairs , here we will need statistics on ( source word , context word , target word ) triples . First , we discuss how cooccurrence statistics among three words can be expressed using generalizations of PMI to three arguments . Then we explain how this can be used to learn relation vectors in natural way. 4.1 Co-occurrence Statistics for Triples Let P li ⊆ {1, ..., nl} again be the set of positions from the lth sentence corresponding to word i. We define: where weight( p, q, r ) = max(  1q−p , 1 r−q  ) if p < q < r and r−p ≤W , and weight( p, q, r ) = 0 otherwise. In other words, yijk reflects the ( weighted ) number of times word j appears between words i and k in a sentence in which i and k occur sufficiently close to each other, in that order. Note that by taking word order into account in this way, we will be able to model asymmetric relationships. To model how strongly a context word j is associated with the word pair ( i , k ) , we will consider the following two well-known generalizations of PMI to three arguments ( Van de Cruys , 2011 ) : where P ( i , j , k ) is the probability of seeing the word triple ( i , j , k ) when randomly choosing a sentence and three ( ordered ) word positions in that sentence within a window size of W . In addition we will also consider two ways in which PMI can be used more directly : Note that SI3 ( i , j , k ) corresponds to the PMI between ( i , k ) and j , whereas SI4 ( i , j , k ) is the PMI between i and k conditioned on the fact that j occurs . The measures SI3 and SI4 are closely related to SI1 and SI2 respectively2. In particular, the following identities are easy to show: Using smoothed versions of the counts yijk, we can use the following probability estimates for SI1( i, j, k )–SI4( i, j, k ): where yij∗ = ∑ k yijk, and similar for the other counts. For efficiency reasons , the counts of the form yij ∗ , yi ∗ k and y ∗ jk are pre-computed for all word pairs , which can be done efficiently due to the sparsity of co-occurrence counts ( i.e . these counts will be 0 for most pairs of words ) , similarly to how to the counts xij are computed in GloVe . From these counts, we can also efficiently pre-compute the counts yi∗∗, y∗j∗, y∗∗k and y∗∗∗. On the other hand, the counts yijk cannot be precomputed, since the total number of triples for which yijk 6= 0 is prohibitively high in a typical corpus. However, using an inverted index, we can efficiently retrieve the sentences that contain the words i and k, and since this number of sentences is typically small, we can efficiently obtain the counts yijk corresponding to a given pair ( i, k ) whenever they are needed. 4.2 Relation Vectors Our aim is to learn a vector rik that models the relationship between i and k. Computing such a vector for each pair of words ( which co-occur at least once ) is not feasible, given the number of triples ( i, j, k ) that would need to be considered. Instead, we first learn a word embedding, by optimizing ( 2 ). Then, fixing the context vectors w˜j and bias terms bj , we learn a vector representation for a given pair ( i, k ) of interest by solving the following objective: where SI refers to one of SI1S , SI 2 S , SI 3 S , SI 4 S . Note that ( 3 ) is essentially the counterpart of ( 1 ) , where we have replaced the role of the PMI measure by SI . In this way, we can exploit the representations of the context words from the word embedding model for learning relation vectors. Note that the factor 1 σ2j has been omitted. This is because words j that are normally relatively uninformative ( e.g. stop words ), for which σ2j would be high, can actually be very important for characterizing the relationship between i and k. For instance, the phrase “X such as Y ” clearly suggests a hyponomy relationship between X and Y , but both ‘such’ and ‘as’ would be associated with a high residual variance σ2j . The set Ji,k contains every j for which yijk > 0 as well as a random sample of m words for which yijk = 0, where m = 2 · |{j : yijk > 0|. Note that because w˜j is now fixed, ( 3 ) is a linear least squares regression problem, which can be solved exactly and efficiently. The vector rik is based on words that appear between i and k. In the same way, we can learn a vector sik based on the words that appear before i and a vector tik based on the words that appear after k, in sentences where i occurs before k. Furthermore, we also learn vectors rki, ski and tki from the sentences where k occurs before i. As the final representation Rik of the relationship between i and k, we concatenate the vectors rik, rki, sik, ski, tik, tki as well as the word vectors wi and wk. We write Rlik to denote the vector that results from using measure SIl ( l ∈ {1, 2, 3, 4} ). 5 Experimental Results In our experiments , we have used the Wikipedia dump from November 2nd , 2015 , which consists of 1,335,766,618 tokens . We have removed punctuations and HTML/XML tags, and we have low-ercased all tokens. Words with fewer than 10 occurrences have been removed from the corpus. To detect sentence boundaries , we have used the Apache sentence segmentation tool . In all our experiments, we have set the number of dimensions to 300, which was found to be a good choice in previous work, e.g. ( Pennington et al., 2014 ). We use a context window size W of 10 words. The number of iterations for SGD was set to 50 . For our model, we have tuned the smoothing parameter α based on held-out tuning data, considering values from {0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001}. We have noticed that in most of the cases the value of α was automatically selected as 0.00001. To efficiently compute the triples , we have used the Zettair3 retrieval engine . As our main baselines, we use three popular unsupervised methods for constructing relation vectors. First, Diff uses the vector difference wk−wi, following the common strategy of modeling relations as vector differences, as e.g. in ( Vylomova et al., 2016 ). Second, Conc uses the concatenation ofwi andwk. This model is more general than Diff but it uses twice as many dimensions, which may make it harder to learn a good classifier from few examples. The use of concatenations is popular e.g. in the context of hypernym detection ( Baroni et al., 2012 ). Finally, Avg averages the vector representations of the words occurring in sentences that Diff, contain i and k. In particular, let ravgik be obtained by averaging the word vectors of the context words appearing between i and k for each sentence containing i and k ( in that order ), and then averaging the vectors obtained from each of these sentences. Let savgik and t avg ik be similarly obtained from the words occurring before i and the words occurring after k respectively. The considered relation vector is then defined as the concatenation of ravgik , r avg ki , s avg ik , s avg ki , t avg ik , t avg ki , wi and wk. The Avg will allow us to directly compare how much we can improve relation vectors by deviating from the common strategy of averaging word vectors. 5.1 Relation Induction In the relation induction task, we are given word pairs ( s1, t1 ), ..., ( sk, tk ) that are related in some way, and the task is to decide for a number of test examples ( s, t ) whether they also have this relationship. Among others, this task was considered in ( Vylomova et al., 2016 ), and a ranking version of this task was studied in ( Drozd et al., 2016 ). As test sets we use the Google Analogy Test Set ( Mikolov et al . , 2013a ) , which contains instances of 14 different types of relations , and the DiffVec dataset , which was introduced in ( Vylomova et al . , 2016 ) . This dataset contains instances of 36 different types of relations4. Note that both datasets contain a mix of semantic and syntactic relations. In our evaluation , we have used 10 - fold cross-validation ( or leave-one-out for relations with fewer than 10 instances ) . In the experiments, we consider for each relation in the test set a separate binary classification task, which was found to be considerably more challenging than a multi-class classification setting in ( Vylomova et al., 2016 ). To generate negative examples in the training data ( resp. test data ), we have used three strategies, following ( Vylomova et al., 2016 ). First, for a given positive example ( s, t ) of the considered relation, we add ( t, s ) as a negative example. Second, for each positive example ( s, t ), we generate two negative examples ( s, t1 ) and ( s, t2 ) by randomly selecting two tail words t1, t2 from the other training ( resp. test ) examples of the same relation. Finally, for each positive example, we also generate a negative example by randomly selecting two words from the vocabulary. For each relation , we then train a linear SVM classifier . To set the parameters of the SVM , we initially use 25% of the training data for tuning , and then retrain the SVM with the optimal parameters on the full training data . The results are summarized in Table 1 in terms of accuracy and ( macro-averaged ) precision , recall and F1 score . As can be observed, our model outperforms the baselines on both datasets, with the R2ik variant outperforming the others. To analyze the benefit of our proposed word embedding variant, Table 2 shows the results that were obtained when we use standard word embedding models. In particular , we show results for the standard GloVe model , SkipGram and the Continuous Bag of Words ( CBOW ) model . As can be observed , our variant leads to better results than the original GloVe model , even for the baselines . The difference is particularly noticeable for Diff-Vec . The difference is also larger for our relation vectors than for the baselines , which is expected as our method is based on the assumption that context word vectors can be interpreted in terms of PMI scores , which is only true for our variant . Similar as in the GloVe model , the context words in our model are weighted based on their distance to the nearest target word . Table 3 shows the results of our model without this weighting, for the relation induction task. Comparing these results with those in Table 1 shows that the weighting scheme indeed leads to a small improvement ( except for the accuracy of R1ik for DiffVec ) . Similarly, in Table 3, we show what happens if the relation vectors sik, ski, tik and tki are omitted. In other words, for the results in Table 3, we only use context words that appear between the two target words. Again , the results are worse than those in Table 1 ( with the accuracy ofR1ik for Diff-Vec again being an exception ) , although the differences are very small in this case . While including the vectors sik, ski, tik, tki should be helpful, it also significantly increases the dimensionality of the vectors Rlik. Given that the number of instances per relation is typically quite small for this task, this can also make it harder to learn a suitable classifier. 5.2 Measuring Degrees of Prototypicality Instances of relations can often have different degrees of prototypicality. For example, for the relation “X characteristically makes the sound Y ”, the pair ( dog,bark ) should be considered more prototypical than the pair ( floor,squeak ), even though both pairs might be considered to be instances of the relation ( Jurgens et al., 2012 ). A suitable relation vector should allow us to rank word pairs according to how prototypical they are as instances of that relation. We evaluate this ability using a dataset that was produced in the aftermath of SemEval 2012 Task 2 . In particular , we have used the “ Phase2AnswerScaled ” data from the platinum rankings dataset , which is available from the SemEval 2012 Task 2 website5 . In this dataset, 79 ranked list of word pairs are provided, each of which corresponds to a particular relation. For each relation, we first split the associated ranking into 60% training, 20% tuning, and 20% testing ( i.e. we randomly select 60% of the word pairs and use their ranking as training data, and similar for tuning and test data ). We then train a linear SVM regression model on the ranked word pairs . Note that this task slightly differs from the task that was considered at SemEval 2012 , to allow us to use an SVM based model for consistency with the rest of the paper . We report results using Spearman ’ s ρ in Table 4 . Our model again outperforms the baselines, with R2ik again being the best variant. Interestingly, in this case, the Avg baseline is considerably stronger than Diff and Conc. Intuitively, we might indeed expect that this ranking problem requires a more fine-grained representation than the relation induction setting. Note that the Diff representations were found to achieve near state-of-the-art performance on a closely related task in ( Zhila et al., 2013 ). The only model that was found to perform ( slightly ) better was a hybrid model, combining Diff representations with linguistic patterns ( inspired by ( Rink and Harabagiu, 2012 ) ) and lexical databases, among others. 5.3 Relation Extraction Finally, we consider the problem of relation extraction from a text corpus. Specifically , we consider the task proposed in ( Riedel et al . , 2010 ) , which is to extract ( subject , predicate , object ) triples from the New York Times ( NYT ) corpus . Rather than having labelled sentences as training data , the task requires using the existing triples from Freebase as a form of distant supervision , i.e . for some pairs of entities we know some of the relations that hold between them , but not which sentences assert these relationships ( if any ) . To be consistent with published results for this task , we have used a word embedding that was trained from the NYT corpus6 , rather than Wikipedia ( using the same preprocessing and set-up ) . We have used the training and test data that was shared publicly for this task7, which consist of sentences from articles published in 2005-2006 and in 2007, respectively. Each of these sentences contains two entities , which are already linked to Freebase . We learn relation vectors from the sentences in the training and test sets , and learn a linear SVM classifier based on the Freebase triples that are available in the training set . Initially , we split the training data into 75% training and 25% tuning to find the optimal parameters of the linear SVM model . We tuned the parameters for each test fold separately. For each test fold, we used 25% of the 9 training folds as tuning data. After the optimal parameters have been determined, we retrain the model on the full training data, and apply it on the test fold. We used this approach ( rather than e.g. fixing a train/tune/test split ) because the total number of examples for some of the relations is very small. After tuning , we re-train the SVM models on the full training data . As the number of training examples is larger for this task , we also consider SVMs with a quadratic kernel . Following earlier work on this task , we report our results on the test set as a precisionrecall graph in Figure 1 . This shows that the best performance is again achieved by R2ik , especially for larger recall values . Furthermore , using a quadratic kernel ( only shown for R2ik ) outperforms the linear SVM models . Note that the differences between the baselines are more pronounced in this task, with Avg being clearly better than Diff, which is in turn better than Conc. For this relation extraction task , a large number of methods have already been proposed in the literature , with variants of convolutional neural network models with attention mechanisms achieving state-of-the-art performance8 . A comparison with these models9 is shown in Figure 2. The performance of R2ik is comparable with the state-of-the-art PCNN + ATT model ( Lin et al . , 2016 ) , outperforming it for larger recall values . This is remarkable, as our model is conceptually much simpler, and has not been specifically tuned for this task. For instance , it could easily be improved by incorporating the attention mechanism from the PCNN + ATT model to focus the relation vectors on the considered task . Similarly, we could consider a supervised variant of ( 3 ), in which a learned relation-specific weight is added to each term. 6 Conclusions We have proposed an unsupervised method which uses co-occurrences statistics to represent the relationship between a given pair of words as a vector. In contrast to neural network models for relation extraction, our model learns relation vectors in an unsupervised way, which means that it can be used for measuring relational similarities and related tasks. Moreover, even in ( distantly ) supervised tasks ( where we need to learn a classifier on top of the unsupervised relation vectors ), our model has proven competitive with state-of-the-art neural network models. Compared to approaches that rely on averaging word vectors, our method is able to learn more faithful representations by focusing on the words that are most strongly related to the considered relationship. "}
  },
    {
    "id": "P18-1008",
    "result":     [
            {
        "value":         {
          "start": 136,
          "end": 167,
          "text": "sequence-to-sequence ( seq2seq )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 223,
          "end": 242,
          "text": "RNN-based approaches",
          "labels": ["Method"]
        },
        "id": 1337
      },
            {
        "value":         {
          "start": 282,
          "end": 308,
          "text": "convolutional seq2seq model",
          "labels": ["Method"]
        },
        "id": 1338
      },
            {
        "value":         {
          "start": 359,
          "end": 375,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 546,
          "end": 566,
          "text": "seq2seq architectures",
          "labels": ["Method"]
        },
        "id": 1340
      },
            {
        "value":         {
          "start": 758,
          "end": 773,
          "text": "RNN architecture",
          "labels": ["Method"]
        },
        "id": 1341
      },
            {
        "value":         {
          "start": 792,
          "end": 803,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 882,
          "end": 889,
          "text": "WMT ’ 14",
          "labels": ["Dataset"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 1151,
          "end": 1162,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 1243,
          "end": 1256,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 1638,
          "end": 1671,
          "text": "Recurrent Neural Networks ( RNNs )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 1752,
          "end": 1773,
          "text": "RNN-based NMT approach",
          "labels": ["Method"]
        },
        "id": 1345
      },
            {
        "value":         {
          "start": 1780,
          "end": 1783,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 2029,
          "end": 2032,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 2036,
          "end": 2080,
          "text": "convolutional neural network based approaches",
          "labels": ["Method"]
        },
        "id": 1347
      },
            {
        "value":         {
          "start": 2359,
          "end": 2365,
          "text": "ByteNet",
          "labels": ["Method"]
        },
        "id": 1348
      },
            {
        "value":         {
          "start": 2403,
          "end": 2409,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 2444,
          "end": 2456,
          "text": "ConvS2S model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 2495,
          "end": 2498,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 2601,
          "end": 2617,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 3960,
          "end": 3966,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 3972,
          "end": 3982,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 4056,
          "end": 4066,
          "text": "RNMT models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 4123,
          "end": 4126,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 4145,
          "end": 4150,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 4314,
          "end": 4319,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 4323,
          "end": 4329,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 4335,
          "end": 4345,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 5012,
          "end": 5021,
          "text": "RNMT model",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 5044,
          "end": 5055,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 5140,
          "end": 5147,
          "text": "WMT ’ 14",
          "labels": ["Dataset"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 5245,
          "end": 5250,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 5254,
          "end": 5260,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 5266,
          "end": 5276,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 5533,
          "end": 5538,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 5548,
          "end": 5564,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 5728,
          "end": 5744,
          "text": "NMT architectures",
          "labels": ["Method"]
        },
        "id": 1354
      },
            {
        "value":         {
          "start": 5761,
          "end": 5764,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 6266,
          "end": 6276,
          "text": "RNMT models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 6305,
          "end": 6307,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 6323,
          "end": 6325,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 6345,
          "end": 6361,
          "text": "attention network",
          "labels": ["Method"]
        },
        "id": 1355
      },
            {
        "value":         {
          "start": 6595,
          "end": 6605,
          "text": "RNMT models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 6656,
          "end": 6673,
          "text": "bidirectional RNNs",
          "labels": ["Method"]
        },
        "id": 1356
      },
            {
        "value":         {
          "start": 6767,
          "end": 6785,
          "text": "unidirectional RNNs",
          "labels": ["Method"]
        },
        "id": 1357
      },
            {
        "value":         {
          "start": 6814,
          "end": 6817,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 6837,
          "end": 6840,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 6905,
          "end": 6907,
          "text": "GRU",
          "labels": ["Method"]
        },
        "id": 1358
      },
            {
        "value":         {
          "start": 7055,
          "end": 7073,
          "text": "Google-NMT ( GNMT )",
          "labels": ["Method"]
        },
        "id": 1359
      },
            {
        "value":         {
          "start": 7119,
          "end": 7128,
          "text": "RNMT model",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 7211,
          "end": 7214,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7254,
          "end": 7257,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7346,
          "end": 7349,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7476,
          "end": 7479,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 7520,
          "end": 7538,
          "text": "RNMT + architecture",
          "labels": ["Method"]
        },
        "id": 1361
      },
            {
        "value":         {
          "start": 7604,
          "end": 7643,
          "text": "convolutional sequence-to-sequence model",
          "labels": ["Method"]
        },
        "id": 1362
      },
            {
        "value":         {
          "start": 8407,
          "end": 8423,
          "text": "ConvS2S codebase1",
          "labels": ["Dataset"]
        },
        "id": 1363
      },
            {
        "value":         {
          "start": 8512,
          "end": 8528,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 8679,
          "end": 8682,
          "text": "RNMT",
          "labels": ["Method"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 8705,
          "end": 8711,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 8719,
          "end": 8735,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 8933,
          "end": 8939,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 8947,
          "end": 8963,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 9159,
          "end": 9175,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 9986,
          "end": 10002,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 10011,
          "end": 10033,
          "text": "Tensor2Tensor2 codebase",
          "labels": ["Dataset"]
        },
        "id": 1364
      },
            {
        "value":         {
          "start": 10458,
          "end": 10461,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 10960,
          "end": 10972,
          "text": "ConvS2S model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 11429,
          "end": 11438,
          "text": "RNN models",
          "labels": ["Method"]
        },
        "id": 1365
      },
            {
        "value":         {
          "start": 11790,
          "end": 11797,
          "text": "WMT ’ 14",
          "labels": ["Dataset"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 12564,
          "end": 12567,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 12773,
          "end": 12776,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 12832,
          "end": 12846,
          "text": "mean test score",
          "labels": ["Metric"]
        },
        "id": 1366
      },
            {
        "value":         {
          "start": 12852,
          "end": 12869,
          "text": "standard deviation",
          "labels": ["Metric"]
        },
        "id": 1375
      },
            {
        "value":         {
          "start": 13526,
          "end": 13537,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 13654,
          "end": 13665,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 13675,
          "end": 13684,
          "text": "GNMT model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 13714,
          "end": 13717,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 13768,
          "end": 13771,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 13821,
          "end": 13824,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 14018,
          "end": 14021,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14045,
          "end": 14054,
          "text": "GNMT model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 14168,
          "end": 14184,
          "text": "Transformer model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 14261,
          "end": 14264,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14389,
          "end": 14392,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 14542,
          "end": 14551,
          "text": "GNMT model",
          "labels": ["Method"]
        },
        "id": 1369
      },
            {
        "value":         {
          "start": 14566,
          "end": 14569,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 14765,
          "end": 14768,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 15004,
          "end": 15009,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 15045,
          "end": 15048,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 15271,
          "end": 15282,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 15315,
          "end": 15318,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 15449,
          "end": 15452,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 15709,
          "end": 15719,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 15725,
          "end": 15737,
          "text": "RNMT + models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 15767,
          "end": 15772,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 15779,
          "end": 15798,
          "text": "multi-head attention",
          "labels": ["Method"]
        },
        "id": 1370
      },
            {
        "value":         {
          "start": 16021,
          "end": 16041,
          "text": "WMT ’ 14 En → De task",
          "labels": ["Dataset"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 16230,
          "end": 16243,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 16924,
          "end": 16940,
          "text": "Resnet - 50 model",
          "labels": ["Method"]
        },
        "id": 1371
      },
            {
        "value":         {
          "start": 17048,
          "end": 17051,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 17088,
          "end": 17100,
          "text": "RNMT + models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 17858,
          "end": 17863,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 17870,
          "end": 17876,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 17882,
          "end": 17892,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 17947,
          "end": 17952,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 17958,
          "end": 17964,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 18014,
          "end": 18024,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 18079,
          "end": 18084,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 18238,
          "end": 18244,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 18250,
          "end": 18267,
          "text": "Transformer models",
          "labels": ["Method"]
        },
        "id": 1372
      },
            {
        "value":         {
          "start": 18394,
          "end": 18397,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 18445,
          "end": 18448,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18556,
          "end": 18576,
          "text": "WMT ’ 14 En → Fr task",
          "labels": ["Dataset"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18589,
          "end": 18609,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18615,
          "end": 18620,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 18633,
          "end": 18636,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 18642,
          "end": 18648,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 18661,
          "end": 18664,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18675,
          "end": 18680,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 18710,
          "end": 18730,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18753,
          "end": 18756,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 18766,
          "end": 18771,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 18798,
          "end": 18815,
          "text": "standard deviation",
          "labels": ["Metric"]
        },
        "id": 1375
      },
            {
        "value":         {
          "start": 18925,
          "end": 18946,
          "text": "Transformer Base model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 18973,
          "end": 18978,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 18988,
          "end": 19008,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19107,
          "end": 19121,
          "text": "Transformer Big",
          "labels": ["Method"]
        },
        "id": 1376
      },
            {
        "value":         {
          "start": 19131,
          "end": 19142,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 19260,
          "end": 19280,
          "text": "WMT ’ 14 En → De task",
          "labels": ["Dataset"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 19288,
          "end": 19309,
          "text": "Transformer Base model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 19325,
          "end": 19328,
          "text": "GNMT",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 19334,
          "end": 19340,
          "text": "ConvS2S",
          "labels": ["Method"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 19357,
          "end": 19360,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19408,
          "end": 19411,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19422,
          "end": 19427,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 19453,
          "end": 19473,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19563,
          "end": 19568,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 19605,
          "end": 19625,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 19772,
          "end": 19781,
          "text": "En-Fr task",
          "labels": ["Dataset"]
        },
        "id": 1377
      },
            {
        "value":         {
          "start": 19851,
          "end": 19872,
          "text": "Transformer Base model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 19924,
          "end": 19929,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 19959,
          "end": 19979,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20022,
          "end": 20033,
          "text": "RNMT + model",
          "labels": ["Method"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 20274,
          "end": 20308,
          "text": "floating point operations ( FLOPs )",
          "labels": ["Metric"]
        },
        "id": 1378
      },
            {
        "value":         {
          "start": 20423,
          "end": 20428,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 20445,
          "end": 20449,
          "text": "FLOPs",
          "labels": ["Metric"]
        },
        "id": 1379
      },
            {
        "value":         {
          "start": 20460,
          "end": 20480,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20654,
          "end": 20659,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 20669,
          "end": 20690,
          "text": "Transformer Big models",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 20882,
          "end": 20887,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 20893,
          "end": 20914,
          "text": "Transformer Big models",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21363,
          "end": 21366,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21372,
          "end": 21377,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 21387,
          "end": 21390,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21396,
          "end": 21417,
          "text": "Transformer Big models",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21540,
          "end": 21543,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21549,
          "end": 21554,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 21564,
          "end": 21567,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 21573,
          "end": 21594,
          "text": "Transformer Big models",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22219,
          "end": 22224,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 22230,
          "end": 22240,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 22248,
          "end": 22253,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 22314,
          "end": 22334,
          "text": "Transformer Big model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 22550,
          "end": 22555,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 22572,
          "end": 22582,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 22592,
          "end": 22597,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 23869,
          "end": 23881,
          "text": "ConvS2S model",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 24043,
          "end": 24048,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 24062,
          "end": 24067,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 24140,
          "end": 24150,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 24213,
          "end": 24218,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 24238,
          "end": 24243,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 24634,
          "end": 24639,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 24740,
          "end": 24745,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 25011,
          "end": 25014,
          "text": "RNNs",
          "labels": ["Method"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25020,
          "end": 25033,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 25327,
          "end": 25332,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 25551,
          "end": 25554,
          "text": "BLEU",
          "labels": ["Metric"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25570,
          "end": 25590,
          "text": "WMT ’ 14 En → Fr task",
          "labels": ["Dataset"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 25617,
          "end": 25627,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 25989,
          "end": 25994,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 26499,
          "end": 26504,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 26547,
          "end": 26557,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 26567,
          "end": 26576,
          "text": "RNMT model",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 26586,
          "end": 26609,
          "text": "WMT ’ 14 benchmark tasks",
          "labels": ["Dataset"]
        },
        "id": 1381
      },
            {
        "value":         {
          "start": 26743,
          "end": 26756,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 26903,
          "end": 26913,
          "text": "RNMT models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 26922,
          "end": 26927,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 26943,
          "end": 26952,
          "text": "RNMT model",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 27024,
          "end": 27031,
          "text": "WMT ’ 14",
          "labels": ["Dataset"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 27158,
          "end": 27168,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 27174,
          "end": 27186,
          "text": "RNMT + models",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 27242,
          "end": 27252,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 27270,
          "end": 27275,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 27522,
          "end": 27527,
          "text": "RNMT +",
          "labels": ["Method"]
        },
        "id": 1382
      }
    ],
    "data": {"text": "The Best of Both Worlds: Combining Recent Advances in Neural Machine Translation Abstract The past year has witnessed rapid advances in sequence-to-sequence ( seq2seq ) modeling for Machine Translation ( MT ) . The classic RNN-based approaches to MT were first out-performed by the convolutional seq2seq model , which was then outperformed by the more recent Transformer model . Each of these new approaches consists of a fundamental architecture accompanied by a set of modeling and training techniques that are in principle applicable to other seq2seq architectures . In this paper, we tease apart the new architectures and their accompanying techniques in two ways. First , we identify several key modeling and training techniques , and apply them to the RNN architecture , yielding a new RNMT + model that outperforms all of the three fundamental architectures on the benchmark WMT ’ 14 English → French and English → German tasks . Second, we analyze the properties of each fundamental seq2seq architecture and devise new hybrid architectures intended to combine their strengths. Our hybrid models obtain further improvements , outperforming the RNMT + model on both benchmark datasets . 1 Introduction In recent years , the emergence of seq2seq models ( Kalchbrenner and Blunsom , 2013 ; Sutskever et al . , 2014 ; Cho et al . , 2014 ) has revolutionized the field of MT by replacing traditional phrase-based approaches with neural machine translation ( NMT ) systems based on the encoder-decoder paradigm . In the first architectures that surpassed the quality of phrase-based MT , both the encoder and decoder were implemented as Recurrent Neural Networks ( RNNs ) , interacting via a soft-attention mechanism ( Bahdanau et al . , 2015 ) . The RNN-based NMT approach , or RNMT , was quickly established as the de-facto standard for NMT , and gained rapid adoption into large-scale systems in industry , e.g . Baidu ( Zhou et al . , 2016 ) , Google ( Wu et al . , 2016 ) , and Systran ( Crego et al . , 2016 ) . Following RNMT , convolutional neural network based approaches ( LeCun and Bengio , 1998 ) to NMT have recently drawn research attention due to their ability to fully parallelize training to take advantage of modern fast computing devices . such as GPUs and Tensor Processing Units ( TPUs ) ( Jouppi et al., 2017 ). Well known examples are ByteNet ( Kalchbrenner et al . , 2016 ) and ConvS2S ( Gehring et al . , 2017 ) . The ConvS2S model was shown to outperform the original RNMT architecture in terms of quality , while also providing greater training speed . Most recently , the Transformer model ( Vaswani et al . , 2017 ) , which is based solely on a selfattention mechanism ( Parikh et al . , 2016 ) and feed-forward connections , has further advanced the field of NMT , both in terms of translation quality and speed of convergence . In many instances, new architectures are accompanied by a novel set of techniques for performing training and inference that have been carefully optimized to work in concert. This ‘bag of tricks’ can be crucial to the performance of a proposed architecture, yet it is typically under-documented and left for the enterprising researcher to discover in publicly released code ( if any ) or through anecdotal evidence. This is not simply a problem for reproducibility; it obscures the central scientific question of how much of the observed gains come from the new architecture and how much can be attributed to the associated training and inference techniques. In some cases, these new techniques may be broadly applicable to other architectures and thus constitute a major, though implicit, contribution of an architecture paper. Clearly, they need to be considered in order to ensure a fair comparison across different model architectures. In this paper , we therefore take a step back and look at which techniques and methods contribute significantly to the success of recent architectures , namely ConvS2S and Transformer , and explore applying these methods to other architectures , including RNMT models . In doing so , we come up with an enhanced version of RNMT , referred to as RNMT + , that significantly outperforms all individual architectures in our setup . We further introduce new architectures built with different components borrowed from RNMT + , ConvS2S and Transformer . In order to ensure a fair setting for comparison, all architectures were implemented in the same framework, use the same pre-processed data and apply no further post-processing as this may confound bare model performance. Our contributions are three-fold: 1. In ablation studies, we quantify the effect of several modeling improvements ( including multi-head attention and layer normalization ) as well as optimization techniques ( such as synchronous replica training and labelsmoothing ), which are used in recent architectures. We demonstrate that these techniques are applicable across different model architectures. 2 . Combining these improvements with the RNMT model , we propose the new RNMT + model , which significantly outperforms all fundamental architectures on the widely-used WMT ’ 14 En → Fr and En → De benchmark datasets . We provide a detailed model analysis and comparison of RNMT + , ConvS2S and Transformer in terms of model quality , model size , and training and inference speed . 3 . Inspired by our understanding of the relative strengths and weaknesses of individual model architectures , we propose new model architectures that combine components from the RNMT + and the Transformer model , and achieve better results than both individual architectures . We quickly note two prior works that provided empirical solutions to the difficulty of training NMT architectures ( specifically RNMT ) . In ( Britz et al., 2017 ) the authors systematically explore which elements of NMT architectures have a significant impact on translation quality. In ( Denkowski and Neubig, 2017 ) the authors recommend three specific techniques for strengthening NMT systems and empirically demonstrated how incorporating those techniques improves the reliability of the experimental results. 2 Background In this section, we briefly discuss the commmonly used NMT architectures. 2.1 RNN-based NMT Models - RNMT RNMT models are composed of an encoder RNN and a decoder RNN , coupled with an attention network . The encoder summarizes the input sequence into a set of vectors while the decoder conditions on the encoded input sequence through an attention mechanism, and generates the output sequence one token at a time. The most successful RNMT models consist of stacked RNN encoders with one or more bidirectional RNNs ( Schuster and Paliwal , 1997 ; Graves and Schmidhuber , 2005 ) , and stacked decoders with unidirectional RNNs . Both encoder and decoder RNNs consist of either LSTM ( Hochreiter and Schmidhuber , 1997 ; Gers et al . , 2000 ) or GRU units ( Cho et al . , 2014 ) , and make extensive use of residual ( He et al . , 2015 ) or highway ( Srivastava et al . , 2015 ) connections . In Google-NMT ( GNMT ) ( Wu et al . , 2016 ) , the best performing RNMT model on the datasets we consider , the encoder network consists of one bi-directional LSTM layer , followed by 7 uni-directional LSTM layers . The decoder is equipped with a single attention network and 8 uni-directional LSTM layers . Both the encoder and the decoder use residual skip connections between consecutive layers. In this paper , we adopt GNMT as the starting point for our proposed RNMT + architecture . 2.2 Convolutional NMT Models - ConvS2S In the most successful convolutional sequence-to-sequence model ( Gehring et al . , 2017 ) , both the encoder and decoder are constructed by stacking multiple convolutional layers , where each layer contains 1 - dimensional convolutions followed by a gated linear units ( GLU ) ( Dauphin et al . , 2016 ) . Each decoder layer computes a separate dotproduct attention by using the current decoder layer output and the final encoder layer outputs. Positional embeddings are used to provide explicit positional information to the model. Following the practice in ( Gehring et al., 2017 ), we scale the gradients of the encoder layers to stabilize training. We also use residual connections across each convolutional layer and apply weight normalization ( Salimans and Kingma, 2016 ) to speed up convergence. We follow the public ConvS2S codebase1 in our experiments . 2.3 Conditional Transformation-based NMT Models - Transformer The Transformer model ( Vaswani et al . , 2017 ) is motivated by two major design choices that aim to address deficiencies in the former two model families : ( 1 ) Unlike RNMT , but similar to the ConvS2S , the Transformer model avoids any sequential dependencies in both the encoder and decoder networks to maximally parallelize training . ( 2 ) To address the limited context problem ( limited receptive field ) present in ConvS2S , the Transformer model makes pervasive use of selfattention networks ( Parikh et al . , 2016 ) so that each position in the current layer has access to information from all other positions in the previous layer . The Transformer model still follows the encoder-decoder paradigm . Encoder transformer layers are built with two sub-modules: ( 1 ) a selfattention network and ( 2 ) a feed-forward network. Decoder transformer layers have an additional cross-attention layer sandwiched between the selfattention and feed-forward layers to attend to the encoder outputs. There are two details which we found very important to the model’s performance: ( 1 ) Each sublayer in the transformer ( i.e. self-attention, cross-attention, and the feed-forward sub-layer ) follows a strict computation sequence: normalize→ transform→ dropout→ residual-add. ( 2 ) In addition to per-layer normalization, the final encoder output is again normalized to prevent a blow up after consecutive residual additions. In this paper , we follow the latest version of the Transformer model in the Tensor2Tensor2 codebase . 2.4 A Theory-Based Characterization of NMT Architectures From a theoretical point of view, RNNs belong to the most expressive members of the neural network family ( Siegelmann and Sontag, 1995 )3. Possessing an infinite Markovian structure ( and thus an infinite receptive fields ) equips them to model sequential data ( Elman, 1990 ), especially natural language ( Grefenstette et al., 2015 ) effectively. In practice , RNNs are notoriously hard to train ( Hochreiter , 1991 ; Bengio et al . , 1994 ; Hochreiter et al . , 2001 ) , confirming the well known dilemma of trainability versus expressivity . Convolutional layers are adept at capturing local context and local correlations by design. A fixed and narrow receptive field for each convolutional layer limits their capacity when the architecture is shallow. In practice , this weakness is mitigated by stacking more convolutional layers ( e.g . 15 layers as in the ConvS2S model ) , which makes the model harder to train and demands meticulous initialization schemes and carefully designed regularization techniques . The transformer network is capable of approximating arbitrary squashing functions ( Hornik et al., 1989 ), and can be considered a strong feature extractor with extended receptive fields capable of linking salient features from the entire sequence. On the other hand , lacking a memory component ( as present in the RNN models ) prevents the network from modeling a state space , reducing its theoretical strength as a sequence model , thus it requires additional positional information ( e.g . sinusoidal positional encodings ) . Above theoretical characterizations will drive our explorations in the following sections. 3 Experiment Setup We train our models on the standard WMT ’ 14 En → Fr and En → De datasets that comprise 36.3M and 4.5M sentence pairs , respectively . Each sentence was encoded into a sequence of sub-word units obtained by first tokenizing the sentence with the Moses tokenizer, then splitting tokens into subword units ( also known as “wordpieces” ) using the approach described in ( Schuster and Nakajima, 2012 ). We use a shared vocabulary of 32K sub-word units for each source-target language pair. No further manual or rule-based post processing of the output was performed beyond combining the subword units to generate the targets. We report all our results on newstest 2014, which serves as the test set. A combination of newstest 2012 and newstest 2013 is used for validation. To evaluate the models , we compute the BLEU metric on tokenized , true-case output . For each training run, we evaluate the model every 30 minutes on the dev set. Once the model converges , we determine the best window based on the average dev-set BLEU score over 21 consecutive evaluations . We report the mean test score and standard deviation over the selected window . This allows us to compare model architectures based on their mean performance after convergence rather than individual checkpoint evaluations, as the latter can be quite noisy for some models. To enable a fair comparison of architectures, we use the same pre-processing and evaluation methodology for all our experiments. We refrain from using checkpoint averaging ( exponential moving averages of parameters ) ( JunczysDowmunt et al., 2016 ) or checkpoint ensembles ( Jean et al., 2015; Chen et al., 2017 ) to focus on evaluating the performance of individual models. 4 RNMT+ 4.1 Model Architecture of RNMT+ The newly proposed RNMT + model architecture is shown in Figure 1 . Here we highlight the key architectural choices that are different between the RNMT + model and the GNMT model . There are 6 bidirectional LSTM layers in the encoder instead of 1 bidirectional LSTM layer followed by 7 unidirectional layers as in GNMT . For each bidirectional layer, the outputs of the forward layer and the backward layer are concatenated before being fed into the next layer. The decoder network consists of 8 unidirectional LSTM layers similar to the GNMT model . Residual connections are added to the third layer and above for both the encoder and decoder. Inspired by the Transformer model , pergate layer normalization ( Ba et al . , 2016 ) is applied within each LSTM cell . Our empirical results show that layer normalization greatly stabilizes training. No non-linearity is applied to the LSTM output . A projection layer is added to the encoder final output. Multi-head additive attention is used instead of the single-head attention in the GNMT model . Similar to GNMT , we use the bottom decoder layer and the final encoder layer output after projection for obtaining the recurrent attention context . In addition to feeding the attention context to all decoder LSTM layers , we also feed it to the softmax by concatenating it with the layer input . This is important for both the quality of the models with multi-head attention and the stability of the training process. Since the encoder network in RNMT + consists solely of bi-directional LSTM layers , model parallelism is not used during training . We compensate for the resulting longer per-step time with increased data parallelism ( more model replicas ) , so that the overall time to reach convergence of the RNMT + model is still comparable to that of GNMT . We apply the following regularization techniques during training. Dropout : We apply dropout to both embedding layers and each LSTM layer output before it is added to the next layer ’ s input . Attention dropout is also applied. Label Smoothing: We use uniform label smoothing with an uncertainty=0.1 ( Szegedy et al., 2015 ). Label smoothing was shown to have a positive impact on both Transformer and RNMT + models , especially in the case of RNMT + with multi-head attention . Similar to the observations in ( Chorowski and Jaitly, 2016 ), we found it beneficial to use a larger beam size ( e.g. 16, 20, etc. ) during decoding when models are trained with label smoothing. Weight Decay : For the WMT ’ 14 En → De task , we apply L2 regularization to the weights with λ = 10 − 5 . Weight decay is only applied to the En→De task as the corpus is smaller and thus more regularization is required. We use the Adam optimizer ( Kingma and Ba , 2014 ) with β1 = 0.9 , β2 = 0.999 , \u000f = 10 − 6 and vary the learning rate according to this schedule : Here, t is the current step, n is the number of concurrent model replicas used in training, p is the number of warmup steps, s is the start step of the exponential decay, and e is the end step of the decay. Specifically, we first increase the learning rate linearly during the number of warmup steps, keep it a constant until the decay start step s, then exponentially decay until the decay end step e, and keep it at 5 · 10−5 after the decay ends. This learning rate schedule is motivated by a similar schedule that was successfully applied in training the Resnet - 50 model with a very large batch size ( Goyal et al . , 2017 ) . In contrast to the asynchronous training used for GNMT ( Dean et al . , 2012 ) , we train RNMT + models with synchronous training ( Chen et al . , 2016 ) . Our empirical results suggest that when hyper-parameters are tuned properly, synchronous training often leads to improved convergence speed and superior model quality. To further stabilize training, we also use adaptive gradient clipping. We discard a training step completely if an anomaly in the gradient norm value is detected, which is usually an indication of an imminent gradient explosion. More specifically, we keep track of a moving average and a moving standard deviation of the log of the gradient norm values, and we abort a step if the norm of the gradient exceeds four standard deviations of the moving average. 4.2 Model Analysis and Comparison In this section , we compare the results of RNMT + with ConvS2S and Transformer . All models were trained with synchronous training. RNMT + and ConvS2S were trained with 32 NVIDIA P100 GPUs while the Transformer Base and Big models were trained using 16 GPUs . For RNMT + , we use sentence-level cross-entropy loss . Each training batch contained 4096 sentence pairs ( 4096 source sequences and 4096 target sequences ). For ConvS2S and Transformer models , we use token-level cross-entropy loss . Each training batch contained 65536 source tokens and 65536 target tokens. For the GNMT baselines on both tasks , we cite the largest BLEU score reported in ( Wu et al . , 2016 ) without reinforcement learning . Table 1 shows our results on the WMT ’ 14 En → Fr task . Both the Transformer Big model and RNMT + outperform GNMT and ConvS2S by about 2 BLEU points . RNMT + is slightly better than the Transformer Big model in terms of its mean BLEU score . RNMT + also yields a much lower standard deviation , and hence we observed much less fluctuation in the training curve . It takes approximately 3 days for the Transformer Base model to converge , while both RNMT + and the Transformer Big model require about 5 days to converge . Although the batching schemes are quite different between the Transformer Big and the RNMT + model , they have processed about the same amount of training samples upon convergence . Table 2 shows our results on the WMT ’ 14 En → De task . The Transformer Base model improves over GNMT and ConvS2S by more than 2 BLEU points while the Big model improves by over 3 BLEU points . RNMT + further outperforms the Transformer Big model and establishes a new state of the art with an averaged value of 28.49 . In this case , RNMT + converged slightly faster than the Transformer Big model and maintained much more stable performance after convergence with a very small standard deviation , which is similar to what we observed on the En-Fr task . Table 3 summarizes training performance and model statistics. The Transformer Base model is the fastest model in terms of training speed . RNMT + is slower to train than the Transformer Big model on a per-GPU basis . However , since the RNMT + model is quite stable , we were able to offset the lower per-GPU throughput with higher concurrency by increasing the number of model replicas , and hence the overall time to convergence was not slowed down much . We also computed the number of floating point operations ( FLOPs ) in the model ’ s forward path as well as the number of total parameters for all architectures ( cf . Table 3 ) . RNMT + requires fewer FLOPs than the Transformer Big model , even though both models have a comparable number of parameters . 5 Ablation Experiments In this section , we evaluate the importance of four main techniques for both the RNMT + and the Transformer Big models . We believe that these techniques are universally applicable across different model architectures, and should always be employed by NMT practitioners for best performance. We take our best RNMT + and Transformer Big models and remove each one of these techniques independently . By doing this we hope to learn two things about each technique: ( 1 ) How much does it affect the model performance? ( 2 ) How useful is it for stable training of other techniques and hence the final model? From Table 4 we draw the following conclusions about the four techniques: Label Smoothing We observed that label smoothing improves both models , leading to an average increase of 0.7 BLEU for RNMT + and 0.2 BLEU for Transformer Big models . Multi-head attention contributes significantly to the quality of both models , resulting in an average increase of 0.6 BLEU for RNMT + and 0.9 BLEU for Transformer Big models . Layer Normalization Layer normalization is most critical to stabilize the training process of either model, especially when multi-head attention is used. Removing layer normalization results in unstable training runs for both models. Since by design, we remove one technique at a time in our ablation experiments, we were unable to quantify how much layer normalization helped in either case. To be able to successfully train a model without layer normalization, we would have to adjust other parts of the model and retune its hyper-parameters. Synchronous training Removing synchronous training has different effects on RNMT + and Transformer . For RNMT + , it results in a significant quality drop , while for the Transformer Big model , it causes the model to become unstable . We also notice that synchronous training is only successful when coupled with a tailored learning rate schedule that has a warmup stage at the beginning ( cf . Eq . 1 for RNMT + and Eq . 2 for Transformer ) . For RNMT + , removing this warmup stage during synchronous training causes the model to become unstable . 6 Hybrid NMT Models In this section, we explore hybrid architectures that shed some light on the salient behavior of each model family. These hybrid models outperform the individual architectures on both benchmark datasets and provide a better understanding of the capabilities and limitations of each model family. 6.1 Assessing Individual Encoders and Decoders In an encoder-decoder architecture, a natural assumption is that the role of an encoder is to build feature representations that can best encode the meaning of the source sequence, while a decoder should be able to process and interpret the representations from the encoder and, at the same time, track the current target history. Decoding is inherently auto-regressive, and keeping track of the state information should therefore be intuitively beneficial for conditional generation. We set out to study which family of encoders is more suitable to extract rich representations from a given input sequence, and which family of decoders can make the best of such rich representations. We start by combining the encoder and decoder from different model families. Since it takes a significant amount of time for a ConvS2S model to converge , and because the final translation quality was not on par with the other models , we focus on two types of hybrids only : Transformer encoder with RNMT + decoder and RNMT + encoder with Transformer decoder . From Table 5 , it is clear that the Transformer encoder is better at encoding or feature extraction than the RNMT + encoder , whereas RNMT + is better at decoding or conditional language modeling , confirming our intuition that a stateful decoder is beneficial for conditional language generation . 6.2 Assessing Encoder Combinations Next, we explore how the features extracted by an encoder can be further enhanced by incorporating additional information. Specifically , we investigate the combination of transformer layers with RNMT + layers in the same encoder block to build even richer feature representations . We exclusively use RNMT + decoders in the following architectures since stateful decoders show better performance according to Table 5 . We study two mixing schemes in the encoder ( see Fig. 2 ): ( 1 ) Cascaded Encoder : The cascaded encoder aims at combining the representational power of RNNs and self-attention . The idea is to enrich a set of stateful representations by cascading a feature extractor with a focus on vertical mapping, similar to ( Pascanu et al., 2013; Devlin, 2017 ). Our best performing cascaded encoder involves fine tuning transformer layers stacked on top of a pre-trained frozen RNMT + encoder . Using a pre-trained encoder avoids optimization difficulties while significantly enhancing encoder capacity. As shown in Table 6 , the cascaded encoder improves over the Transformer encoder by more than 0.5 BLEU points on the WMT ’ 14 En → Fr task . This suggests that the Transformer encoder is able to extract richer representations if the input is augmented with sequential context . ( 2 ) Multi-Column Encoder: As illustrated in Fig. 2b, a multi-column encoder merges the outputs of several independent encoders into a single combined representation. Unlike a cascaded encoder , the multi-column encoder enables us to investigate whether an RNMT + decoder can distinguish information received from two different channels and benefit from its combination . A crucial operation in a multi-column encoder is therefore how different sources of information are merged into a unified representation. Our best multi-column encoder performs a simple concatenation of individual column outputs. The model details and hyperparameters of the above two encoders are described in Appendix A.5 and A.6. As shown in Table 6 , the multi-column encoder followed by an RNMT + decoder achieves better results than the Transformer and the RNMT model on both WMT ’ 14 benchmark tasks . 7 Conclusion In this work we explored the efficacy of several architectural and training techniques proposed in recent studies on seq2seq models for NMT . We demonstrated that many of these techniques are broadly applicable to multiple model architectures. Applying these new techniques to RNMT models yields RNMT + , an enhanced RNMT model that significantly outperforms the three fundamental architectures on WMT ’ 14 En → Fr and En → De tasks . We further presented several hybrid models developed by combining encoders and decoders from the Transformer and RNMT + models , and empirically demonstrated the superiority of the Transformer encoder and the RNMT + decoder in comparison with their counterparts . We then enhanced the encoder architecture by horizontally and vertically mixing components borrowed from these architectures , leading to hybrid architectures that obtain further improvements over RNMT + . We hope that our work will motivate NMT researchers to further investigate generally applicable training and optimization techniques, and that our exploration of hybrid architectures will open paths for new architecture search efforts for NMT. Our focus on a standard single-language-pair translation task leaves important open questions to be answered: How do our new architectures compare in multilingual settings, i.e., modeling an interlingua? Which architecture is more efficient and powerful in processing finer grained inputs and outputs, e.g., characters or bytes? How transferable are the representations learned by the different architectures to other tasks? And what are the characteristic errors that each architecture makes, e.g., linguistic plausibility? "}
  },
    {
    "id": "P18-1015",
    "result":     [
            {
        "value":         {
          "start": 94,
          "end": 100,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 359,
          "end": 371,
          "text": "seq2seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 491,
          "end": 497,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 1380,
          "end": 1411,
          "text": "sequence-to-sequence ( seq2seq )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 1602,
          "end": 1615,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 1764,
          "end": 1776,
          "text": "seq2seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 1878,
          "end": 1891,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 2165,
          "end": 2178,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 2365,
          "end": 2377,
          "text": "seq2seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 2381,
          "end": 2408,
          "text": "Template based summarization",
          "labels": ["Method"]
        },
        "id": 1382
      },
            {
        "value":         {
          "start": 3123,
          "end": 3157,
          "text": "retrieve-based conversation systems",
          "labels": ["Method"]
        },
        "id": 1383
      },
            {
        "value":         {
          "start": 3479,
          "end": 3485,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 3565,
          "end": 3571,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 3577,
          "end": 3615,
          "text": "template based summarization approaches",
          "labels": ["Method"]
        },
        "id": 1384
      },
            {
        "value":         {
          "start": 3652,
          "end": 3657,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 3874,
          "end": 3886,
          "text": "seq2seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 4006,
          "end": 4037,
          "text": "Recurrent Neural Network ( RNN )",
          "labels": ["Method"]
        },
        "id": 1386
      },
            {
        "value":         {
          "start": 4140,
          "end": 4145,
          "text": "Rerank",
          "labels": ["Method"]
        },
        "id": 1387
      },
            {
        "value":         {
          "start": 4526,
          "end": 4541,
          "text": "Gigaword dataset",
          "labels": ["Dataset"]
        },
        "id": 1415
      },
            {
        "value":         {
          "start": 4624,
          "end": 4629,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 4678,
          "end": 4691,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 5048,
          "end": 5054,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 5167,
          "end": 5173,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 5303,
          "end": 5337,
          "text": "seq2seq-based summarization systems",
          "labels": ["Method"]
        },
        "id": 1389
      },
            {
        "value":         {
          "start": 6118,
          "end": 6120,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 6255,
          "end": 6257,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 6808,
          "end": 6814,
          "text": "Lucene1",
          "labels": ["Tool"]
        },
        "id": 1390
      },
            {
        "value":         {
          "start": 6882,
          "end": 6888,
          "text": "Lucene2",
          "labels": ["Tool"]
        },
        "id": 1391
      },
            {
        "value":         {
          "start": 7056,
          "end": 7062,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 7484,
          "end": 7531,
          "text": "bidirectional Recurrent Neural Network ( BiRNN )",
          "labels": ["Method"]
        },
        "id": 1392
      },
            {
        "value":         {
          "start": 7649,
          "end": 7651,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 7696,
          "end": 7700,
          "text": "BiRNN",
          "labels": ["Method"]
        },
        "id": 1394
      },
            {
        "value":         {
          "start": 7724,
          "end": 7726,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 7743,
          "end": 7745,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 7992,
          "end": 7994,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 8222,
          "end": 8226,
          "text": "BiRNN",
          "labels": ["Method"]
        },
        "id": 1394
      },
            {
        "value":         {
          "start": 8639,
          "end": 8643,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 8855,
          "end": 8859,
          "text": "BiRNN",
          "labels": ["Method"]
        },
        "id": 1394
      },
            {
        "value":         {
          "start": 8927,
          "end": 8942,
          "text": "Bilinear network",
          "labels": ["Method"]
        },
        "id": 1395
      },
            {
        "value":         {
          "start": 9047,
          "end": 9062,
          "text": "Bilinear network",
          "labels": ["Method"]
        },
        "id": 1395
      },
            {
        "value":         {
          "start": 9211,
          "end": 9218,
          "text": "Bilinear",
          "labels": ["Method"]
        },
        "id": 1395
      },
            {
        "value":         {
          "start": 9232,
          "end": 9266,
          "text": "multi-layer forward neural networks",
          "labels": ["Method"]
        },
        "id": 1396
      },
            {
        "value":         {
          "start": 9385,
          "end": 9401,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      },
            {
        "value":         {
          "start": 9535,
          "end": 9539,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 9830,
          "end": 9842,
          "text": "seq2seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 10142,
          "end": 10144,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 10973,
          "end": 11007,
          "text": "Stochastic Gradient Descent ( SGD )",
          "labels": ["Method"]
        },
        "id": 1398
      },
            {
        "value":         {
          "start": 11170,
          "end": 11172,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 11379,
          "end": 11393,
          "text": "Gigaword corpus",
          "labels": ["Dataset"]
        },
        "id": 1400
      },
            {
        "value":         {
          "start": 11705,
          "end": 11719,
          "text": "Gigaword corpus",
          "labels": ["Dataset"]
        },
        "id": 1400
      },
            {
        "value":         {
          "start": 11779,
          "end": 11783,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 11827,
          "end": 11831,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 11877,
          "end": 11892,
          "text": "DUC shared tasks",
          "labels": ["Dataset"]
        },
        "id": 1400
      },
            {
        "value":         {
          "start": 12046,
          "end": 12052,
          "text": "unigram",
          "labels": ["Method"]
        },
        "id": 1401
      },
            {
        "value":         {
          "start": 12056,
          "end": 12062,
          "text": "bi-gram",
          "labels": ["Method"]
        },
        "id": 1405
      },
            {
        "value":         {
          "start": 12068,
          "end": 12101,
          "text": "longest common subsequence ( LCS )",
          "labels": ["Method"]
        },
        "id": 1401
      },
            {
        "value":         {
          "start": 12147,
          "end": 12155,
          "text": "ROUGE - 1",
          "labels": ["Metric"]
        },
        "id": 1402
      },
            {
        "value":         {
          "start": 12159,
          "end": 12166,
          "text": "uni-gram",
          "labels": ["Method"]
        },
        "id": 1403
      },
            {
        "value":         {
          "start": 12172,
          "end": 12180,
          "text": "ROUGE - 2",
          "labels": ["Metric"]
        },
        "id": 1424
      },
            {
        "value":         {
          "start": 12184,
          "end": 12190,
          "text": "bi-gram",
          "labels": ["Method"]
        },
        "id": 1405
      },
            {
        "value":         {
          "start": 12198,
          "end": 12204,
          "text": "ROUGE-L",
          "labels": ["Metric"]
        },
        "id": 1405
      },
            {
        "value":         {
          "start": 12208,
          "end": 12210,
          "text": "LCS",
          "labels": ["Method"]
        },
        "id": 1405
      },
            {
        "value":         {
          "start": 12214,
          "end": 12223,
          "text": "F1 scores4",
          "labels": ["Metric"]
        },
        "id": 1406
      },
            {
        "value":         {
          "start": 12336,
          "end": 12340,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 12404,
          "end": 12408,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 12422,
          "end": 12426,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 13444,
          "end": 13459,
          "text": "Stanford CoreNLP",
          "labels": ["Tool"]
        },
        "id": 1407
      },
            {
        "value":         {
          "start": 13564,
          "end": 13570,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 13582,
          "end": 13590,
          "text": "Open-NMT5",
          "labels": ["Tool"]
        },
        "id": 1407
      },
            {
        "value":         {
          "start": 13683,
          "end": 13689,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 13780,
          "end": 13782,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 13866,
          "end": 13906,
          "text": "Long Short Term Memory Networks ( LSTMs )",
          "labels": ["Method"]
        },
        "id": 1409
      },
            {
        "value":         {
          "start": 14230,
          "end": 14240,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 14754,
          "end": 14756,
          "text": "CNN",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 14772,
          "end": 14775,
          "text": "NNLM",
          "labels": ["Method"]
        },
        "id": 1410
      },
            {
        "value":         {
          "start": 14860,
          "end": 14868,
          "text": "ABS model",
          "labels": ["Method"]
        },
        "id": 1412
      },
            {
        "value":         {
          "start": 14991,
          "end": 14999,
          "text": "ABS model",
          "labels": ["Method"]
        },
        "id": 1412
      },
            {
        "value":         {
          "start": 15013,
          "end": 15049,
          "text": "convolutional attention-based encoder",
          "labels": ["Method"]
        },
        "id": 1412
      },
            {
        "value":         {
          "start": 15057,
          "end": 15059,
          "text": "RNN",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 15140,
          "end": 15156,
          "text": "seq2seq RNN model",
          "labels": ["Method"]
        },
        "id": 1413
      },
            {
        "value":         {
          "start": 15418,
          "end": 15422,
          "text": "LSTMs",
          "labels": ["Method"]
        },
        "id": 1414
      },
            {
        "value":         {
          "start": 15503,
          "end": 15527,
          "text": "attentional seq2seq model",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 15534,
          "end": 15540,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 15606,
          "end": 15612,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 15638,
          "end": 15653,
          "text": "Gigaword dataset",
          "labels": ["Dataset"]
        },
        "id": 1415
      },
            {
        "value":         {
          "start": 16027,
          "end": 16034,
          "text": "PIPELINE",
          "labels": ["Method"]
        },
        "id": 1416
      },
            {
        "value":         {
          "start": 16073,
          "end": 16078,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 16400,
          "end": 16407,
          "text": "PIPELINE",
          "labels": ["Method"]
        },
        "id": 1416
      },
            {
        "value":         {
          "start": 16430,
          "end": 16435,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 16467,
          "end": 16472,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 16543,
          "end": 16557,
          "text": "ROUGE F1 scores",
          "labels": ["Metric"]
        },
        "id": 1416
      },
            {
        "value":         {
          "start": 16698,
          "end": 16702,
          "text": "ABS +",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 16708,
          "end": 16718,
          "text": "Featseq2seq",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 16846,
          "end": 16856,
          "text": "Featseq2seq",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 16869,
          "end": 16873,
          "text": "ABS +",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 16885,
          "end": 16893,
          "text": "ROUGE - 2",
          "labels": ["Metric"]
        },
        "id": 1424
      },
            {
        "value":         {
          "start": 16971,
          "end": 16995,
          "text": "attentional seq2seq model",
          "labels": ["Method"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 16997,
          "end": 17004,
          "text": "OpenNMTI",
          "labels": ["Tool"]
        },
        "id": 1419
      },
            {
        "value":         {
          "start": 17445,
          "end": 17449,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 17569,
          "end": 17573,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 17624,
          "end": 17628,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 18025,
          "end": 18030,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 18318,
          "end": 18331,
          "text": "seq2seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 18524,
          "end": 18530,
          "text": "LEN DIF",
          "labels": ["Metric"]
        },
        "id": 1420
      },
            {
        "value":         {
          "start": 18540,
          "end": 18545,
          "text": "LESS 3",
          "labels": ["Metric"]
        },
        "id": 1421
      },
            {
        "value":         {
          "start": 18570,
          "end": 18575,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 18699,
          "end": 18704,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 18734,
          "end": 18739,
          "text": "LEN DF",
          "labels": ["Metric"]
        },
        "id": 1422
      },
            {
        "value":         {
          "start": 18764,
          "end": 18770,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 18790,
          "end": 18797,
          "text": "Open-NMT",
          "labels": ["Tool"]
        },
        "id": 1423
      },
            {
        "value":         {
          "start": 18833,
          "end": 18839,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19031,
          "end": 19037,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19358,
          "end": 19363,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19381,
          "end": 19387,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19438,
          "end": 19454,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      },
            {
        "value":         {
          "start": 19662,
          "end": 19667,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 19757,
          "end": 19761,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 19827,
          "end": 19835,
          "text": "ROUGE - 2",
          "labels": ["Metric"]
        },
        "id": 1424
      },
            {
        "value":         {
          "start": 19961,
          "end": 19966,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 20122,
          "end": 20133,
          "text": "Rerank model",
          "labels": ["Method"]
        },
        "id": 1424
      },
            {
        "value":         {
          "start": 20256,
          "end": 20261,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 20318,
          "end": 20324,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 20443,
          "end": 20449,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 20567,
          "end": 20572,
          "text": "Re3Sum",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 20649,
          "end": 20655,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 21225,
          "end": 21231,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 21238,
          "end": 21248,
          "text": "beam search",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 21392,
          "end": 21398,
          "text": "OpenNMT",
          "labels": ["Tool"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 22102,
          "end": 22130,
          "text": "attentional seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1425
      },
            {
        "value":         {
          "start": 22350,
          "end": 22366,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      },
            {
        "value":         {
          "start": 22799,
          "end": 22805,
          "text": "CopyNet",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 22828,
          "end": 22844,
          "text": "copying mechanism",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 23190,
          "end": 23219,
          "text": "Minimum Risk Training strategy",
          "labels": ["Method"]
        },
        "id": 1426
      },
            {
        "value":         {
          "start": 23237,
          "end": 23241,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 23308,
          "end": 23339,
          "text": "reinforcement learning algorithm",
          "labels": ["Method"]
        },
        "id": 1427
      },
            {
        "value":         {
          "start": 23398,
          "end": 23402,
          "text": "ROUGE",
          "labels": ["Metric"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 23795,
          "end": 23811,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      },
            {
        "value":         {
          "start": 23833,
          "end": 23849,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      },
            {
        "value":         {
          "start": 24046,
          "end": 24052,
          "text": "seq2seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 24101,
          "end": 24106,
          "text": "Lucene",
          "labels": ["Tool"]
        },
        "id": 1428
      },
            {
        "value":         {
          "start": 24195,
          "end": 24211,
          "text": "seq2seq framework",
          "labels": ["Method"]
        },
        "id": 1429
      }
    ],
    "data": {"text": "Retrieve, Rerank and Rewrite: Soft Template Based Neural Summarization Abstract Most previous seq2seq summarization systems purely depend on the source text to generate summaries , which tends to work unstably . Inspired by the traditional template-based summarization approaches , this paper proposes to use existing summaries as soft templates to guide the seq2seq model . To this end, we use a popular IR platform to Retrieve proper summaries as candidate templates. Then , we extend the seq2seq framework to jointly conduct template Reranking and templateaware summary generation ( Rewriting ) . Experiments show that, in terms of informativeness, our model significantly outperforms the state-of-the-art methods, and even soft templates themselves demonstrate high competitiveness. In addition, the import of high-quality external summaries improves the stability and readability of generated summaries. 1 Introduction The exponentially growing online information has necessitated the development of effective automatic summarization systems. In this paper, we focus on an increasingly intriguing task, i.e., abstractive sentence summarization ( Rush et al., 2015a ), which generates a shorter version of a given sentence while attempting to preserve its original meaning. It can be used to design or refine appealing headlines. Recently , the application of the attentional sequence-to-sequence ( seq2seq ) framework has attracted growing attention and achieved state-of-the-art performance on this task ( Rush et al . , 2015a ; Chopra et al . , 2016 ; Nallapati et al . , 2016 ) . Most previous seq2seq models purely depend on the source text to generate summaries . However , as reported in many studies ( Koehn and Knowles , 2017 ) , the performance of a seq2seq model deteriorates quickly with the increase of the length of generation . Our experiments also show that seq2seq models tend to “ lose control ” sometimes . For example, 3% of summaries contain less than 3 words, while there are 4 summaries repeating a word for even 99 times. These results largely reduce the informativeness and readability of the generated summaries. In addition , we find seq2seq models usually focus on copying source words in order , without any actual “ summarization ” . Therefore , we argue that , the free generation based on the source sentence is not enough for a seq2seq model . Template based summarization ( e.g . , Zhou and Hovy ( 2004 ) ) is a traditional approach to abstractive summarization . In general, a template is an incomplete sentence which can be filled with the input text using the manually defined rules. For instance, a concise template to conclude the stock market quotation is: [REGION] shares [open/close] [NUMBER] percent [lower/higher], e.g., “hong kong shares close #.# percent lower”. Since the templates are written by humans, the produced summaries are usually fluent and informative. However, the construction of templates is extremely time-consuming and requires a plenty of domain knowledge. Moreover, it is impossible to develop all templates for summaries in various domains. Inspired by retrieve-based conversation systems ( Ji et al . , 2014 ) , we assume the golden summaries of the similar sentences can provide a reference point to guide the input sentence summarization process . We call these existing summaries soft templates since no actual rules are needed to build new summaries from them. Due to the strong rewriting ability of the seq2seq framework ( Cao et al . , 2017a ) , in this paper , we propose to combine the seq2seq and template based summarization approaches . We call our summarization system Re3Sum , which consists of three modules : Retrieve , Rerank and Rewrite . We utilize a widely-used Information Retrieval ( IR ) platform to find out candidate soft templates from the training corpus. Then , we extend the seq2seq model to jointly learn template saliency measurement ( Rerank ) and final summary generation ( Rewrite ) . Specifically , a Recurrent Neural Network ( RNN ) encoder is applied to convert the input sentence and each candidate template into hidden states . In Rerank , we measure the informativeness of a candidate template according to its hidden state relevance to the input sentence . The candidate template with the highest predicted informativeness is regarded as the actual soft template. In Rewrite, the summary is generated according to the hidden states of both the sentence and template. We conduct extensive experiments on the popular Gigaword dataset ( Rush et al . , 2015b ) . Experiments show that , in terms of informativeness , Re3Sum significantly outperforms the state-of-the-art seq2seq models , and even soft templates themselves demonstrate high competitiveness . In addition, the import of high-quality external summaries improves the stability and readability of generated summaries. The contributions of this work are summarized as follows: We propose to introduce soft templates as additional input to improve the readability and stability of seq2seq summarization systems . Code and results can be found at http://www4.comp.polyu.edu.hk/˜cszqcao/ We extend the seq2seq framework to conduct template reranking and template-aware summary generation simultaneously . We fuse the popular IR-based and seq2seq-based summarization systems , which fully utilize the supervisions from both sides . 2 Method As shown in Fig. 1, our summarization system consists of three modules, i.e., Retrieve, Rerank and Rewrite. Given the input sentence x, the Retrieve module filters candidate soft templates C = {ri} from the training corpus. For validation and test, we regard the candidate template with the highest predicted saliency ( a.k.a informativeness ) score as the actual soft template r. For training, we choose the one with the maximal actual saliency score in C, which speeds up convergence and shows no obvious side effect in the experiments. Then, we jointly conduct reranking and rewriting through a shared encoder. Specifically , both the sentence x and the soft template r are converted into hidden states with a RNN encoder . In the Rerank module, we measure the saliency of r according to its hidden state relevance to x. In the Rewrite module , a RNN decoder combines the hidden states of x and r to generate a summary y . More details will be described in the rest of this section 2.1 Retrieve The purpose of this module is to find out candidate templates from the training corpus. We assume that similar sentences should hold similar summary patterns. Therefore, given a sentence x, we find out its analogies in the corpus and pick their summaries as the candidate templates. Since the size of our dataset is quite large ( over 3M ) , we leverage the widely-used Information Retrieve ( IR ) system Lucene1 to index and search efficiently . We keep the default settings of Lucene2 to build the IR system . For each input sentence, we select top 30 searching results as candidate templates. 2.2 Jointly Rerank and Rewrite To conduct template-aware seq2seq generation ( rewriting ) , it is a necessary step to encode both the source sentence x and soft template r into hidden states . Considering that the matching networks based on hidden states have demonstrated the strong ability to measure the relevance of two pieces of texts ( e.g., Chen et al. ( 2016 ) ), we propose to jointly conduct reranking and rewriting through a shared encoding step. Specifically , we employ a bidirectional Recurrent Neural Network ( BiRNN ) encoder ( Cho et al . , 2014 ) to read x and r . Take the sentence x as an example. Its hidden state of the forward RNN at timestamp i can be represented by : The BiRNN consists of a forward RNN and a backward RNN . Suppose the corresponding outputs are [ −→ h x1 ; · · · ; −→ h x−1] and [ ←− h x1 ; · · · ; ←− h x−1], respectively, where the index “−1” stands for the last element. Then , the composite hidden state of a word is the concatenation of the two RNN representations , i.e . , hxi = [ − → h xi ; ← − h xi ] . The entire representation for the source sentence is [hx1 ; · · · ;hx−1]. Since a soft template r can also be regarded as a readable concise sentence , we use the same BiRNN encoder to convert it into hidden states [ hr1 ; · · · ; hr − 1 ] . 2.2.1 Rerank In Retrieve, the template candidates are ranked according to the text similarity between the corresponding indexed sentences and the input sentence. However, for the summarization task, we expect the soft template r resembles the actual summary y∗ as much as possible. Here we use the widely-used summarization evaluation metrics ROUGE ( Lin , 2004 ) to measure the actual saliency s ∗ ( r , y ∗ ) ( see Section 3.2 ) . We utilize the hidden states of x and r to predict the saliency s of the template. Specifically , we regard the output of the BiRNN as the representation of the sentence or template : Next , we use Bilinear network to predict the saliency of the template for the input sentence . where Ws and bs are parameters of the Bilinear network , and we add the sigmoid activation function to make the range of s consistent with the actual saliency s ∗ . According to Chen et al . ( 2016 ) , Bilinear outperforms multi-layer forward neural networks in relevance measurement . As shown later , the difference of s and s ∗ will provide additional supervisions for the seq2seq framework . 2.2.2 Rewrite The soft template r selected by the Rerank module has already competed with the state-of-the-art method in terms of ROUGE evaluation ( see Table 4 ) . However, r usually contains a lot of named entities that does not appear in the source ( see Table 5 ). Consequently, it is hard to ensure that the soft templates are faithful to the input sentences. Therefore , we leverage the strong rewriting ability of the seq2seq model to generate more faithful and informative summaries . Specifically, since the input of our system consists of both the sentence and soft template, we use the concatenation function3 to combine the hidden states of the sentence and The combined hidden states are fed into the prevailing attentional RNN decoder ( Bahdanau et al . , 2014 ) to generate the decoding hidden state at the position t : where yt − 1 is the previous output summary word . Finally, a softmax layer is introduced to predict the current summary word: where Wo is a parameter matrix. 2.3 Learning There are two types of costs in our system. For Rerank, we expect the predicted saliency s( r,x ) close to the actual saliency s∗( r,y∗ ). Therefore, we use the cross entropy ( CE ) between s and s∗ as the loss function: where θ stands for the model parameters. For Rewrite, the learning goal is to maximize the estimated probability of the actual summary y∗. We adopt the common negative log-likelihood ( NLL ) as the loss function: To make full use of supervisions from both sides, we combine the above two costs as the final loss function: We use mini-batch Stochastic Gradient Descent ( SGD ) to tune model parameters . The batch size is 64. To enhance generalization , we introduce dropout ( Srivastava et al . , 2014 ) with probability p = 0.3 for the RNN layers . The initial learning rate is 1, and it will decay by 50% if the generation loss does not decrease on the validation set. 3 Experiments 3.1 Datasets We conduct experiments on the Annotated English Gigaword corpus , as with ( Rush et al . , 2015b ) . This parallel corpus is produced by pairing the first sentence in the news article and its headline as the summary with heuristic rules. All the training, development and test datasets can be downloaded at https://github. com/harvardnlp/sent-summary. The statistics of the Gigaword corpus is presented in Table 1 . 3.2 Evaluation Metrics We adopt ROUGE ( Lin , 2004 ) for automatic evaluation . ROUGE has been the standard evaluation metric for DUC shared tasks since 2004 . It measures the quality of summary by computing the overlapping lexical units between the candidate summary and actual summaries , such as unigram , bi-gram and longest common subsequence ( LCS ) . Following the common practice , we report ROUGE - 1 ( uni-gram ) , ROUGE - 2 ( bi-gram ) and ROUGE-L ( LCS ) F1 scores4 in the following experiments . We also measure the actual saliency of a candidate template r with its combined ROUGE scores given the actual summary y ∗ : where “ RG ” stands for ROUGE for short . ROUGE mainly evaluates informativeness . We also introduce a series of metrics to measure the summary quality from the following aspects: LEN DIF. The absolute value of the length difference between the generated summaries and the actual summaries. We use mean value ± standard deviation to illustrate this item. The average value partially reflects the readability and informativeness, while the standard deviation links to stability. LESS 3 .The number of the generated summaries, which contains less than three tokens. These extremely short summaries are usually unreadable. COPY. The proportion of the summary words ( without stopwords ) copied from the source sentence. A seriously large copy ratio indicates that the summarization system pays more attention to compression rather than required abstraction. NEW NE .The number of the named entities that do not appear in the source sentence or actual summary. Intuitively, the appearance of new named entities in the summary is likely to bring unfaithfulness. We use Stanford CoreNLP ( Manning et al . , 2014 ) to recognize named entities . 3.3 Implementation Details We use the popular seq2seq framework Open-NMT5 as the starting point . To make our model more general , we retain the default settings of OpenNMT to build the network architecture . Specifically , the dimensions of word embeddings and RNN are both 500 , and the encoder and decoder structures are two-layer bidirectional Long Short Term Memory Networks ( LSTMs ) . The only difference is that we add the argument “share embeddings” to share the word embeddings between the encoder and decoder. This practice largely reduces model parameters for the monolingual task. On our computer ( GPU: GTX 1080, Memory: 16G, CPU: i7-7700K ), the training spends about 2 days. During test , we use beam search of size 5 to generate summaries . We add the argument “replace unk” to replace the generated unknown words with the source word that holds the highest attention weight. Since the generated summaries are often shorter than the actual ones, we introduce an additional length penalty argument “alpha 1” to encourage longer generation, like Wu et al. ( 2016 ). 3.4 Baselines We compare our proposed model with the following state-of-the-art neural summarization systems: ABS Rush et al . ( 2015a ) used an attentive CNN encoder and a NNLM decoder to summarize the sentence . ABS+. Rush et al . ( 2015a ) further tuned the ABS model with additional hand-crafted features to balance between abstraction and extraction . RAS-Elman. As the extension of the ABS model , it used a convolutional attention-based encoder and a RNN decoder ( Chopra et al . , 2016 ) . Nallapati et al . ( 2016 ) used a complete seq2seq RNN model and added the hand-crafted features such as POS tag and NER , to enhance the encoder representation . Luong-NMT .Chopra et al. ( 2016 ) implemented the neural machine translation model of Luong et al. ( 2015 ) for summarization. This model contained two-layer LSTMs with 500 hidden units in each layer . OpenNMT . We also implement the standard attentional seq2seq model with OpenNMT . All the settings are the same as our system. It is noted that OpenNMT officially examined the Gigaword dataset . We distinguish the official result6 and our experimental result with suffixes “O” and “I” respectively. FTSum. Cao et al. ( 2017b ) encoded the facts extracted from the source sentence to improve both the faithfulness and informativeness of generated summaries. In addition , to evaluate the effectiveness of our joint learning framework , we develop a baseline named “ PIPELINE ” . Its architecture is identical to Re3Sum . However, it trains the Rerank module and Rewrite module in pipeline. 3.5 Informativeness Evaluation . Let’s first look at the final cost values ( Eq. 9 ) on the development set. From Table 2, we can see that our model achieves much lower perplexity compared against the state-of-the-art systems. It is also noted that PIPELINE slightly outperforms Re3Sum . One possible reason is that Re3Sum additionally considers the cost derived from the Rerank module . The ROUGE F1 scores of different methods are then reported in Table 3 . As can be seen, our model significantly outperforms most other approaches. Note that , ABS + and Featseq2seq have utilized a series of hand-crafted features , but our model is completely data-driven . Even though , our model surpasses Featseq2seq by 22% and ABS + by 60% on ROUGE - 2 . When soft templates are ignored , our model is equivalent to the standard attentional seq2seq model OpenNMTI . Therefore, it is safe to conclude that soft templates have great contribute to guide the generation of summaries. We also examine the performance of directly regarding soft templates as output summaries. We introduce five types of different soft templates: Random. An existing summary randomly selected from the training corpus. First. The top-ranked candidate template given by the Retrieve module. The template with the maximal actual ROUGE scores among the 30 candidate templates . Optimal. An existing summary in the training corpus which holds the maximal ROUGE scores . The template with the maximal predicted ROUGE scores among the 30 candidate templates . It is the actual soft template we adopt. As shown in Table 4, the performance of Random is terrible, indicating it is impossible to use one summary template to fit various actual summaries. Rerank largely outperforms First, which verifies the effectiveness of the Rerank module. However , according to Max and Rerank , we find the Rerank performance of Re3Sum is far from perfect . Likewise, comparing Max and First, we observe that the improving capacity of the Retrieve module is high. Notice that Optimal greatly exceeds all the state-of-the-art approaches. This finding strongly supports our practice of using existing summaries to guide the seq2seq models . 3.6 Linguistic Quality Evaluation We also measure the linguistic quality of generated summaries from various aspects, and the results are present in Table 5. As can be seen from the rows “ LEN DIF ” and “ LESS 3 ” , the performance of Re3Sum is almost the same as that of soft templates . The soft templates indeed well guide the summary generation. Compared with Re3Sum , the standard deviation of LEN DF is 0.7 times larger in OpenNMT , indicating that Open-NMT works quite unstably . Moreover , OpenNMT generates 53 extreme short summaries , which seriously reduces readability . Meanwhile, the copy ratio of actual summaries is 36%. Therefore , the copy mechanism is severely overweighted in OpenNMT . Our model is encouraged to generate according to human-written soft templates, which relatively diminishes copying from the source sentences. Look at the last row “NEW NE”. A number of new named entities appear in the soft templates, which makes them quite unfaithful to source sentences. By contrast , this index in Re3Sum is close to the OpenNMT ’ s . It highlights the rewriting ability of our seq2seq framework . 3.7 Effect of Templates In this section, we investigate how soft templates affect our model. At the beginning , we feed different types of soft templates ( refer to Table 4 ) into the Rewriting module of Re3Sum . As illustrated in Table 6 , the more high-quality templates are provided , the higher ROUGE scores are achieved . It is interesting to see that , while the ROUGE - 2 score of Random templates is zero , our model can still generate acceptable summaries with Random templates . It seems that Re3Sum can automatically judge whether the soft templates are trustworthy and ignore the seriously irrelevant ones . We believe that the joint learning with the Rerank model plays a vital role here . Next, we manually inspect the summaries generated by different methods. We find the outputs of Re3Sum are usually longer and more fluent than the outputs of OpenNMT . Some illustrative examples are shown in Table 7. In Example 1, there is no predicate in the source sentence. Since OpenNMT prefers selecting source words around the predicate to form the summary , it fails on this sentence . By contract , Re3Sum rewrites the template and produces an informative summary . In Example 2 , OpenNMT deems the starting part of the sentences are more important , while our model , guided by the template , focuses on the second part to generate the summary . In the end, we test the ability of our model to generate diverse summaries. In practice, a system that can provide various candidate summaries is probably more welcome. Specifically, two candidate templates with large text dissimilarity are manually fed into the Rewriting module. The corresponding generated summaries are shown in Table 8. For the sake of comparison , we also present the 2 - best results of OpenNMT with beam search . As can be seen, with different templates given, our model is likely to generate dissimilar summaries. In contrast , the 2 - best results of OpenNMT is almost the same , and often a shorter summary is only a piece of the other one . To sum up, our model demonstrates promising prospect in generation diversity. 4 Related Work Abstractive sentence summarization aims to produce a shorter version of a given sentence while preserving its meaning ( Chopra et al., 2016 ). This task is similar to text simplification ( Saggion, 2017 ) and facilitates headline design and refine. Early studies on sentence summarization include template-based methods ( Zhou and Hovy, 2004 ), syntactic tree pruning ( Knight and Marcu, 2002; Clarke and Lapata, 2008 ) and statistical machine translation techniques ( Banko et al., 2000 ). Recently , the application of the attentional seq2seq framework has attracted growing attention and achieved state-of-the-art performance on this task ( Rush et al . , 2015a ; Chopra et al . , 2016 ; Nallapati et al . , 2016 ) . In addition to the direct application of the general seq2seq framework , researchers attempted to integrate various properties of summarization . For example, Nallapati et al. ( 2016 ) enriched the encoder with hand-crafted features such as named entities and POS tags. These features have played important roles in traditional feature based summarization systems. Gu et al. ( 2016 ) found that a large proportion of the words in the summary were copied from the source text. Therefore , they proposed CopyNet which considered the copying mechanism during generation . Recently, See et al. ( 2017 ) used the coverage mechanism to discourage repetition. Cao et al. ( 2017b ) encoded facts extracted from the source sentence to enhance the summary faithfulness. There were also studies to modify the loss function to fit the evaluation metrics. For instance , Ayana et al . ( 2016 ) applied the Minimum Risk Training strategy to maximize the ROUGE scores of generated summaries . Paulus et al . ( 2017 ) used the reinforcement learning algorithm to optimize a mixed objective function of likelihood and ROUGE scores . Guu et al. ( 2017 ) also proposed to encode human-written sentences to improvement the performance of neural text generation. However, they handled the task of Language Modeling and randomly picked an existing sentence in the training corpus. In comparison, we develop an IR system to find proper existing summaries as soft templates. Moreover , Guu et al . ( 2017 ) used a general seq2seq framework while we extend the seq2seq framework to conduct template reranking and template-aware summary generation simultaneously . 5 Conclusion and Future Work This paper proposes to introduce soft templates as additional input to guide the seq2seq summarization . We use the popular IR platform Lucene to retrieve proper existing summaries as candidate soft templates . Then we extend the seq2seq framework to jointly conduct template reranking and template-aware summary generation . Experiments show that our model can generate informative, readable and stable summaries. In addition, our model demonstrates promising prospect in generation diversity. We believe our work can be extended in various aspects. On the one hand, since the candidate templates are far inferior to the optimal ones, we intend to improve the Retrieve module, e.g., by indexing both the sentence and summary fields. On the other hand, we plan to test our system on the other tasks such as document-level summarization and short text conversation. "}
  },
    {
    "id": "P18-1070",
    "result":     [
            {
        "value":         {
          "start": 474,
          "end": 482,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 488,
          "end": 518,
          "text": "variational auto-encoding model",
          "labels": ["Method"]
        },
        "id": 1430
      },
            {
        "value":         {
          "start": 664,
          "end": 679,
          "text": "STRUCTVAE models",
          "labels": ["Method"]
        },
        "id": 1441
      },
            {
        "value":         {
          "start": 804,
          "end": 814,
          "text": "ATIS domain",
          "labels": ["Dataset"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 820,
          "end": 841,
          "text": "Python code generation",
          "labels": ["Dataset"]
        },
        "id": 1438
      },
            {
        "value":         {
          "start": 881,
          "end": 889,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 1513,
          "end": 1515,
          "text": "SQL",
          "labels": ["Tool"]
        },
        "id": 1434
      },
            {
        "value":         {
          "start": 1570,
          "end": 1575,
          "text": "Python",
          "labels": ["Tool"]
        },
        "id": 1453
      },
            {
        "value":         {
          "start": 2872,
          "end": 2884,
          "text": "NL-MR corpora",
          "labels": ["Dataset"]
        },
        "id": 1435
      },
            {
        "value":         {
          "start": 2992,
          "end": 3031,
          "text": "variational auto-encoding ( VAE ) models",
          "labels": ["Method"]
        },
        "id": 1436
      },
            {
        "value":         {
          "start": 3051,
          "end": 3070,
          "text": "sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 3150,
          "end": 3158,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 3281,
          "end": 3289,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 3423,
          "end": 3425,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4050,
          "end": 4058,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4146,
          "end": 4149,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4241,
          "end": 4243,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4469,
          "end": 4477,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4506,
          "end": 4516,
          "text": "ATIS domain",
          "labels": ["Dataset"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 4522,
          "end": 4543,
          "text": "Python code generation",
          "labels": ["Dataset"]
        },
        "id": 1438
      },
            {
        "value":         {
          "start": 4593,
          "end": 4624,
          "text": "transition-based semantic parser",
          "labels": ["Method"]
        },
        "id": 1438
      },
            {
        "value":         {
          "start": 4867,
          "end": 4875,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 4943,
          "end": 4951,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 5042,
          "end": 5061,
          "text": "sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 5278,
          "end": 5281,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 6941,
          "end": 6949,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 7269,
          "end": 7272,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 7411,
          "end": 7414,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 7914,
          "end": 7917,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 8271,
          "end": 8279,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 8302,
          "end": 8304,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 9169,
          "end": 9188,
          "text": "sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 9373,
          "end": 9418,
          "text": "Long Short-Term Memory ( LSTM ) language model",
          "labels": ["Method"]
        },
        "id": 1439
      },
            {
        "value":         {
          "start": 9461,
          "end": 9492,
          "text": "attentional sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1440
      },
            {
        "value":         {
          "start": 9830,
          "end": 9845,
          "text": "STRUCTVAE models",
          "labels": ["Method"]
        },
        "id": 1441
      },
            {
        "value":         {
          "start": 10200,
          "end": 10244,
          "text": "Abstract Syntax Description Language ( ASDL )",
          "labels": ["Method"]
        },
        "id": 1441
      },
            {
        "value":         {
          "start": 10582,
          "end": 10590,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 10738,
          "end": 10741,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 10967,
          "end": 10970,
          "text": "YN17",
          "labels": ["Method"]
        },
        "id": 1459
      },
            {
        "value":         {
          "start": 11098,
          "end": 11101,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 11192,
          "end": 11195,
          "text": "YN17",
          "labels": ["Method"]
        },
        "id": 1459
      },
            {
        "value":         {
          "start": 11231,
          "end": 11250,
          "text": "Context Free Grammar",
          "labels": ["Method"]
        },
        "id": 1444
      },
            {
        "value":         {
          "start": 11352,
          "end": 11355,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 11464,
          "end": 11467,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 11532,
          "end": 11535,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 11587,
          "end": 11590,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 14448,
          "end": 14475,
          "text": "sequence-to-sequence network",
          "labels": ["Method"]
        },
        "id": 1445
      },
            {
        "value":         {
          "start": 14544,
          "end": 14546,
          "text": "AST",
          "labels": ["Method"]
        },
        "id": 1446
      },
            {
        "value":         {
          "start": 14797,
          "end": 14805,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 15239,
          "end": 15242,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 16145,
          "end": 16153,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 16204,
          "end": 16222,
          "text": "LSTM language model",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 16935,
          "end": 16952,
          "text": "REINFORCE learning",
          "labels": ["Method"]
        },
        "id": 1448
      },
            {
        "value":         {
          "start": 18078,
          "end": 18086,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 18222,
          "end": 18233,
          "text": "ATIS dataset",
          "labels": ["Dataset"]
        },
        "id": 1449
      },
            {
        "value":         {
          "start": 18714,
          "end": 18717,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 18863,
          "end": 18876,
          "text": "DJANGO dataset",
          "labels": ["Dataset"]
        },
        "id": 1453
      },
            {
        "value":         {
          "start": 18926,
          "end": 18943,
          "text": "Python source code",
          "labels": ["Dataset"]
        },
        "id": 1451
      },
            {
        "value":         {
          "start": 18964,
          "end": 18983,
          "text": "Django web framework",
          "labels": ["Method"]
        },
        "id": 1452
      },
            {
        "value":         {
          "start": 19059,
          "end": 19072,
          "text": "DJANGO dataset",
          "labels": ["Dataset"]
        },
        "id": 1453
      },
            {
        "value":         {
          "start": 19125,
          "end": 19130,
          "text": "Python",
          "labels": ["Tool"]
        },
        "id": 1453
      },
            {
        "value":         {
          "start": 19331,
          "end": 19334,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 20913,
          "end": 20920,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20981,
          "end": 20984,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20990,
          "end": 20995,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 21184,
          "end": 21192,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 21199,
          "end": 21225,
          "text": "self-training ( SELFTRAIN )",
          "labels": ["Method"]
        },
        "id": 1454
      },
            {
        "value":         {
          "start": 21449,
          "end": 21457,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 21539,
          "end": 21556,
          "text": "REINFORCE training",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 21664,
          "end": 21667,
          "text": "ASDL",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 21814,
          "end": 21817,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 21942,
          "end": 21955,
          "text": "SEQ2TREE model",
          "labels": ["Method"]
        },
        "id": 1456
      },
            {
        "value":         {
          "start": 21979,
          "end": 22009,
          "text": "Abstract Syntax Network ( ASN )",
          "labels": ["Method"]
        },
        "id": 1457
      },
            {
        "value":         {
          "start": 22048,
          "end": 22053,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 22097,
          "end": 22107,
          "text": "YN17 system",
          "labels": ["Method"]
        },
        "id": 1458
      },
            {
        "value":         {
          "start": 22278,
          "end": 22283,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 22358,
          "end": 22361,
          "text": "YN17",
          "labels": ["Method"]
        },
        "id": 1459
      },
            {
        "value":         {
          "start": 22438,
          "end": 22446,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 22560,
          "end": 22568,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 22613,
          "end": 22621,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 22716,
          "end": 22719,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22746,
          "end": 22751,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 22787,
          "end": 22795,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 22853,
          "end": 22858,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 22943,
          "end": 22946,
          "text": "YN17",
          "labels": ["Method"]
        },
        "id": 1459
      },
            {
        "value":         {
          "start": 23024,
          "end": 23027,
          "text": "YN17",
          "labels": ["Method"]
        },
        "id": 1459
      },
            {
        "value":         {
          "start": 23056,
          "end": 23064,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 23310,
          "end": 23318,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 23325,
          "end": 23337,
          "text": "self-training",
          "labels": ["Method"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 23349,
          "end": 23357,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 23371,
          "end": 23379,
          "text": "SELFTRAIN",
          "labels": ["Method"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 23418,
          "end": 23426,
          "text": "SELFTRAIN",
          "labels": ["Method"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 23506,
          "end": 23518,
          "text": "self-training",
          "labels": ["Method"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 23566,
          "end": 23574,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 23597,
          "end": 23605,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 23866,
          "end": 23874,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 24025,
          "end": 24033,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 24162,
          "end": 24170,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 24410,
          "end": 24418,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 25116,
          "end": 25121,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 25127,
          "end": 25130,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25996,
          "end": 26001,
          "text": "DJANGO",
          "labels": ["Dataset"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 26007,
          "end": 26010,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 27189,
          "end": 27213,
          "text": "AST-based semantic parser",
          "labels": ["Method"]
        },
        "id": 1461
      },
            {
        "value":         {
          "start": 27245,
          "end": 27279,
          "text": "copy-augmented reconstruction model",
          "labels": ["Method"]
        },
        "id": 1462
      },
            {
        "value":         {
          "start": 27288,
          "end": 27306,
          "text": "LSTM language model",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 27498,
          "end": 27506,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 27592,
          "end": 27600,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 27675,
          "end": 27685,
          "text": "ATIS domain",
          "labels": ["Dataset"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 27705,
          "end": 27724,
          "text": "sequence-to-sequence",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 27973,
          "end": 28006,
          "text": "tri-gram Kneser-Ney language model",
          "labels": ["Method"]
        },
        "id": 1463
      },
            {
        "value":         {
          "start": 28058,
          "end": 28076,
          "text": "STRUCTVAE-SEQ model",
          "labels": ["Method"]
        },
        "id": 1464
      },
            {
        "value":         {
          "start": 28142,
          "end": 28150,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 28412,
          "end": 28424,
          "text": "STRUCTVAE-SEQ",
          "labels": ["Method"]
        },
        "id": 1465
      },
            {
        "value":         {
          "start": 28901,
          "end": 28918,
          "text": "REINFORCE training",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 28926,
          "end": 28955,
          "text": "multi-layer perceptron ( MLP )",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 28963,
          "end": 28965,
          "text": "MLP",
          "labels": ["Method"]
        },
        "id": 1521
      },
            {
        "value":         {
          "start": 29043,
          "end": 29046,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 29144,
          "end": 29152,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 29163,
          "end": 29165,
          "text": "MLP",
          "labels": ["Method"]
        },
        "id": 1521
      },
            {
        "value":         {
          "start": 29218,
          "end": 29221,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 29263,
          "end": 29264,
          "text": "LM",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 29534,
          "end": 29542,
          "text": "REINFORCE",
          "labels": ["Method"]
        },
        "id": 1466
      },
            {
        "value":         {
          "start": 29699,
          "end": 29707,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 29768,
          "end": 29776,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 30273,
          "end": 30281,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 30554,
          "end": 30572,
          "text": "graph-based methods",
          "labels": ["Method"]
        },
        "id": 1467
      },
            {
        "value":         {
          "start": 30918,
          "end": 30921,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 31027,
          "end": 31029,
          "text": "VAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 31496,
          "end": 31499,
          "text": "SVMs",
          "labels": ["Method"]
        },
        "id": 1523
      },
            {
        "value":         {
          "start": 31678,
          "end": 31681,
          "text": "VAEs",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 31725,
          "end": 31733,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 32427,
          "end": 32435,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 32549,
          "end": 32557,
          "text": "STRUCTVAE",
          "labels": ["Method"]
        },
        "id": 1468
      }
    ],
    "data": {"text": "STRUCTVAE: Tree-structured Latent Variable Models for Semi-supervised Semantic Parsing Abstract Semantic parsing is the task of transducing natural language ( NL ) utterances into formal meaning representations ( MRs ), commonly represented as tree structures. Annotating NL utterances with their corresponding MRs is expensive and timeconsuming, and thus the limited availability of labeled data often becomes the bottleneck of data-driven, supervised models. We introduce STRUCTVAE , a variational auto-encoding model for semisupervised semantic parsing , which learns both from limited amounts of parallel data , and readily-available unlabeled NL utterances . STRUCTVAE models latent MRs not observed in the unlabeled data as tree-structured latent variables . Experiments on semantic parsing on the ATIS domain and Python code generation show that with extra unlabeled data , STRUCTVAE outperforms strong supervised models .1 1 Introduction Semantic parsing tackles the task of mapping natural language ( NL ) utterances into structured formal meaning representations ( MRs ). This includes parsing to general-purpose logical forms such as λ-calculus ( Zettlemoyer and Collins , 2005 , 2007 ) and the abstract meaning representation ( AMR , Banarescu et al . ( 2013 ) ; Misra and Artzi ( 2016 ) ) , as well as parsing to computerexecutable programs to solve problems such as question answering ( Berant et al . , 2013 ; Yih et al . , 2015 ; Liang et al . , 2017 ) , or generation of domainspecific ( e.g . , SQL ) or general purpose programming languages ( e.g . , Python ) ( Quirk et al . , 2015 ; Yin and Neubig , 2017 ; Rabinovich et al . , 2017 ) . While these models have a long history ( Zelle and Mooney, 1996; Tang and Mooney, 2001 ), recent advances are largely attributed to the success of neural network models ( Xiao et al., 2016; Ling et al., 2016; Dong and Lapata, 2016; Iyer et al., 2017; Zhong et al., 2017 ). However, these models are also extremely data hungry: optimization of such models requires large amounts of training data of parallel NL utterances and manually annotated MRs, the creation of which can be expensive, cumbersome, and time-consuming. Therefore, the limited availability of parallel data has become the bottleneck of existing, purely supervised-based models. These data requirements can be alleviated with weakly-supervised learning, where the denotations ( e.g., answers in question answering ) of MRs ( e.g., logical form queries ) are used as indirect supervision ( Clarke et al. ( 2010 ); Liang et al. ( 2011 ); Berant et al. ( 2013 ), inter alia ), or dataaugmentation techniques that automatically generate pseudo-parallel corpora using hand-crafted or induced grammars ( Jia and Liang, 2016; Wang et al., 2015 ). In this work , we focus on semi-supervised learning , aiming to learn from both limited amounts of parallel NL-MR corpora , and unlabeled but readily-available NL utterances . We draw inspiration from recent success in applying variational auto-encoding ( VAE ) models in semisupervised sequence-to-sequence learning ( Miao and Blunsom , 2016 ; Kocisky ´ et al . , 2016 ) , and propose STRUCTVAE — a principled deep generative approach for semi-supervised learning with tree-structured latent variables ( Fig . 1 ) . STRUCTVAE is based on a generative story where the surface NL utterances are generated from tree-structured latent MRs following the standard VAE architecture : ( 1 ) an off-the-shelf semantic parser functions as the inference model, parsing an observed NL utterance into latent meaning representations ( § 3.2 ); ( 2 ) a reconstruction model decodes the latent MR into the original observed utterance ( § 3.1 ). This formulation enables our model to perform both standard supervised learning by optimizing the inference model ( i.e., the parser ) using parallel corpora, and unsupervised learning by maximizing the variational lower bound of the likelihood of the unlabeled utterances ( § 3.3 ). In addition to these contributions to semisupervised semantic parsing , STRUCTVAE contributes to generative model research as a whole , providing a recipe for training VAEs with structured latent variables . Such a structural latent space is contrast to existing VAE research using flat representations , such as continuous distributed representations ( Kingma and Welling , 2013 ) , discrete symbols ( Miao and Blunsom , 2016 ) , or hybrids of the two ( Zhou and Neubig , 2017 ) . We apply STRUCTVAE to semantic parsing on the ATIS domain and Python code generation . As an auxiliary contribution , we implement a transition-based semantic parser , which uses Abstract Syntax Trees ( ASTs , § 3.2 ) as intermediate MRs and achieves strong results on the two tasks . We then apply this parser as the inference model for semi-supervised learning , and show that with extra unlabeled data , STRUCTVAE outperforms its supervised counterpart . We also demonstrate that STRUCTVAE is compatible with different structured latent representations , applying it to a simple sequence-to-sequence parser which uses λ-calculus logical forms as MRs . 2 Semi-supervised Semantic Parsing In this section we introduce the objectives for semi-supervised semantic parsing , and present high-level intuition in applying VAEs for this task . 2.1 Supervised and Semi-supervised Training Formally, semantic parsing is the task of mapping utterance x to a meaning representation z. As noted above, there are many varieties of MRs that can be represented as either graph structures ( e.g., AMR ) or tree structures ( e.g., λ-calculus and ASTs for programming languages ). In this work we specifically focus on tree-structured MRs ( see Fig. 2 for a running example Python AST ), although application of a similar framework to graph-structured representations is also feasible. Traditionally, purely supervised semantic parsers train a probabilistic model pφ( z|x ) using parallel data L of NL utterances and annotated MRs ( i.e., L = {〈x, z〉} ). As noted in the introduction, one major bottleneck in this approach is the lack of such parallel data. Hence, we turn to semi-supervised learning, where the model additionally has access to a relatively large amount of unlabeled NL utterances U = {x}. Semi-supervised learning then aims to maximize the log-likelihood of examples in both L and U: The joint objective consists of two terms: ( 1 ) a supervised objective Js that maximizes the conditional likelihood of annotated MRs, as in standard supervised training of semantic parsers; and ( 2 ) a unsupervised objective Ju, which maximizes the marginal likelihood p( x ) of unlabeled NL utterances U, controlled by a tuning parameter α. Intuitively, if the modeling of pφ( z|x ) and p( x ) is coupled ( e.g., they share parameters ), then optimizing the marginal likelihood p( x ) using the unsupervised objective Ju would help the learning of the semantic parser pφ( z|x ) ( Zhu, 2005 ). STRUCTVAE uses the variational auto-encoding framework to jointly optimize pφ ( z | x ) and p ( x ) , as outlined in § 2.2 and detailed in § 3 . 2.2 VAEs for Semi-supervised Learning From Eq. ( 1 ), our semi-supervised model must be able to calculate the probability p( x ) of unlabeled NL utterances. To model p ( x ) , we use VAEs , which provide a principled framework for generative models using neural networks ( Kingma and Welling , 2013 ) . As shown in Fig . 1 , VAEs define a generative story ( bold arrows in Fig . 1 , explained in § 3.1 ) to model p ( x ) , where a latent MR z is sampled from a prior , and then passed to the reconstruction model to decode into the surface utterance x . There is also an inference model qφ( z|x ) that allows us to infer the most probable latent MR z given the input x ( dashed arrows in Fig. 1, explained in § 3.2 ). In our case, the inference process is equivalent to the task of semantic parsing if we set qφ( · ) , pφ( · ). VAEs also provide a framework to compute an approximation of p ( x ) using the inference and reconstruction models , allowing us to effectively optimize the unsupervised and supervised objectives in Eq . ( 1 ) in a joint fashion ( Kingma et al . ( 2014 ) , explained in § 3.3 ) . 3 STRUCTVAE: VAEs with Tree-structured Latent Variables 3.1 Generative Story STRUCTVAE follows the standard VAE architecture , and defines a generative story that explains how an NL utterance is generated : a latent meaning representation z is sampled from a prior distribution p ( z ) over MRs , which encodes the latent semantics of the utterance . A reconstruction model pθ( x|z ) then decodes the sampled MR z into the observed NL utterance x. Both the prior p( z ) and the reconstruction model p( x|z ) takes tree-structured MRs as inputs. To model such inputs with rich internal structures, we follow Konstas et al. ( 2017 ), and model the distribution over a sequential surface representation of z, zs instead. Specifically, we have p( z ) , p( zs ) and pθ( x|z ) , pθ( x|zs )2. For code generation, zs is simply the surface source code of the AST z. For semantic parsing, zs is the linearized s-expression of the logical form. Linearization allows us to use standard sequence-to-sequence networks to model p ( z ) and pθ ( x | z ) . As we will explain in § 4.3, we find these two components perform well with linearization. Specifically , the prior is parameterized by a Long Short-Term Memory ( LSTM ) language model over zs . The reconstruction model is an attentional sequence-to-sequence network ( Luong et al . , 2015 ) , augmented with a copying mechanism ( Gu et al . , 2016 ) , allowing an out-of-vocabulary ( OOV ) entity in zs to be copied to x ( e.g . , the variable name my list in Fig . 1 and its AST in Fig . 2 ) . We refer readers to Appendix B for details of the neural network architecture. 3.2 Inference Model STRUCTVAE models the semantic parser pφ ( z | x ) as the inference model qφ ( z | x ) in VAE ( § 2.2 ) , which maps NL utterances x into tree-structured meaning representations z . qφ ( z | x ) can be any trainable semantic parser , with the corresponding MRs forming the structured latent semantic space . In this work , we primarily use a semantic parser based on the Abstract Syntax Description Language ( ASDL ) framework ( Wang et al . , 1997 ) as the inference model . The parser encodes x into ASTs ( Fig. 2 ). ASTs are the native meaning representation scheme of source code in modern programming languages, and can also be adapted to represent other semantic structures, like λ-calculus logical forms ( see § 4.2 for details ). We remark that STRUCTVAE works with other semantic parsers with different meaning representations as well ( e.g . , using λ-calculus logical forms for semantic parsing on ATIS , explained in § 4.3 ) . Our inference model is a transition-based parser inspired by recent work in neural semantic parsing and code generation. The transition system is an adaptation of Yin and Neubig ( 2017 ) ( hereafter YN17 ) , which decomposes the generation process of an AST into sequential applications of tree-construction actions following the ASDL grammar , thus ensuring the syntactic well-formedness of generated ASTs . Different from YN17 , where ASTs are represented as a Context Free Grammar learned from a parsed corpus , we follow Rabinovich et al . ( 2017 ) and use ASTs defined under the ASDL formalism ( § 3.2.1 ) . 3.2.1 Generating ASTs with ASDL Grammar First , we present a brief introduction to ASDL . An AST can be generated by applying typed constructors in an ASDL grammar , such as those in Fig . 3 for the Python ASDL grammar . Each constructor specifies a language construct, and is assigned to a particular composite type. For example, the constructor Call has type expr ( expression ), and it denotes function calls. Constructors are associated with multiple fields. For instance, the Call constructor and has three fields: func, args and keywords. Like constructors, fields are also strongly typed. For example, the func field of Call has expr type. Fields with composite types are instantiated by constructors of the same type, while fields with primitive types store values ( e.g., identifier names or string literals ). Each field also has a cardinality ( single, optional ?, and sequential ∗ ), specifying the number of values the field has. Each node in an AST corresponds to a typed field in a constructor ( except for the root node ). Depending on the cardinality of the field, an AST node can be instantiated with one or multiple constructors. For instance, the func field in the example AST has single cardinality, and is instantiated with a Name constructor; while the args field with sequential cardinality could have multi-ple constructors ( only one shown in this example ). Our parser employs a transition system to generate an AST using three types of actions. Fig. 2 ( Right ) lists the sequence of actions used to generate the example AST. The generation process starts from an initial derivation with only a root node of type stmt ( statement ), and proceeds according to the top-down, left-to-right traversal of the AST. At each time step, the parser applies an action to the frontier field of the derivation: APPLYCONSTR[c] actions apply a constructor c to the frontier composite field, expanding the derivation using the fields of c. For fields with single or optional cardinality, an APPLYCONSTR action instantiates the empty frontier field using the constructor, while for fields with sequential cardinality, it appends the constructor to the frontier field. For example, at t2 the Call constructor is applied to the value field of Expr, and the derivation is expanded using its three child fields. REDUCE actions complete generation of a field with optional or multiple cardinalities. For instance, the args field is instantiated by Name at t5, and then closed by a REDUCE action at t7. GENTOKEN[v] actions populate an empty primitive frontier field with token v. A primitive field whose value is a single token ( e.g., identifier fields ) can be populated with a single GEN-TOKEN action. Fields of string type can be instantiated using multiple such actions, with a final GENTOKEN[<\/f>] action to terminate the generation of field values. 3.2.2 Modeling qφ( z|x ) The probability of generating an AST z is naturally decomposed into the probabilities of the actions {at} used to construct z: Following YN17 , we parameterize qφ ( z | x ) using a sequence-to-sequence network with auxiliary recurrent connections following the topology of the AST . Interested readers are referred to Appendix B and Yin and Neubig ( 2017 ) for details of the neural network architecture. 3.3 Semi-supervised Learning In this section we explain how to optimize the semi-supervised learning objective Eq . ( 1 ) in STRUCTVAE . Supervised Learning. For the supervised learning objective, we modify Js, and use the labeled data to optimize both the inference model ( the semantic parser ) and the reconstruction model: Unsupervised Learning To optimize the unsupervised learning objective Ju in Eq. ( 1 ), we maximize the variational lower-bound of log p( x ): where KL[qφ!p] is the Kullback-Leibler ( KL ) divergence. Following common practice in optimizing VAEs , we introduce λ as a tuning parameter of the KL divergence to control the impact of the prior ( Miao and Blunsom , 2016 ; Bowman et al . , 2016 ) . To optimize the parameters of our model in the face of non-differentiable discrete latent variables, we follow Miao and Blunsom ( 2016 ), and approximate ∂L∂φ using the score function estimator ( a.k.a. REINFORCE, Williams ( 1992 ) ): where we approximate the gradient using a set of samples S( x ) drawn from qφ( ·|x ). To ensure the quality of sampled latent MRs, we follow Guu et al. ( 2017 ) and use beam search. The term l′( x, z ) is defined as the learning signal ( Miao and Blunsom, 2016 ). The learning signal weights the gradient for each latent sample z. In REIN-FORCE, to cope with the high variance of the learning signal, it is common to use a baseline b( x ) to stabilize learning, and re-define the learning signal as Specifically , in STRUCTVAE , we define , where log p ( x ) is a pre-trained LSTM language model . This is motivated by the empirical observation that log p( x ) correlates well with the reconstruction score log pθ( x|z ), hence with l′( x, z ). Finally, for the reconstruction model, its gradient can be easily computed: Discussion .Perhaps the most intriguing question here is why semi-supervised learning could improve semantic parsing performance. While the underlying theoretical exposition still remains an active research problem ( Singh et al., 2008 ), in this paper we try to empirically test some likely hypotheses. In Eq. ( 4 ), the gradient received by the inference model from each latent sample z is weighed by the learning signal l( x, z ). l ( x , z ) can be viewed as the reward function in REINFORCE learning . It can also be viewed as weights associated with pseudo-training examples {〈x, z〉 : z ∈ S( x )} sampled from the inference model. Intuitively, a sample z with higher rewards should: ( 1 ) have z adequately encode the input, leading to high reconstruction score log pθ( x|z ); and ( 2 ) have z be succinct and natural, yielding high prior probability. Let z∗ denote the gold-standard MR of x. Consider the ideal case where z∗ ∈ S( x ) and l( x, z∗ ) is positive, while l( x, z′ ) is negative for other imperfect samples z′ ∈ S( x ), z′ 6= z∗. In this ideal case, 〈x, z∗〉would serve as a positive training example and other samples 〈x, z′〉 would be treated as negative examples. Therefore, the inference model would receive informative gradient updates, and learn to discriminate between gold and imperfect MRs. This intuition is similar in spirit to recent efforts in interpreting gradient update rules in reinforcement learning ( Guu et al., 2017 ). We will present more empirical statistics and observations in § 4.3. 4 Experiments 4.1 Datasets In our semi-supervised semantic parsing experiments , it is of interest how STRUCTVAE could further improve upon a supervised parser with extra unlabeled data . We evaluate on two datasets: Semantic Parsing . We use the ATIS dataset , a collection of 5,410 telephone inquiries of flight booking ( e.g . , “ Show me flights from ci0 to ci1 ” ) . The target MRs are defined using λ-calculus logical forms ( e.g., “lambda $0 e ( and ( flight $0 ) ( from $ci0 ) ( to $ci1 ) )” ). We use the pre-processed dataset released by Dong and Lapata ( 2016 ), where entities ( e.g., cities ) are canonicalized using typed slots ( e.g., ci0 ). To predict λcalculus logical forms using our transition-based parser , we use the ASDL grammar defined by Rabinovich et al . ( 2017 ) to convert between logical forms and ASTs ( see Appendix C for details ) . Code Generation . The DJANGO dataset ( Oda et al . , 2015 ) contains 18,805 lines of Python source code extracted from the Django web framework . Each line of code is annotated with an NL utterance. Source code in the DJANGO dataset exhibits a wide variety of real-world use cases of Python , including IO operation , data structure manipulation , class / function definition , etc . We use the pre-processed version released by Yin and Neubig ( 2017 ) and use the astor package to convert ASDL ASTs into Python source code . 4.2 Setup Labeled and Unlabeled Data .STRUCTVAE requires access to extra unlabeled NL utterances for semi-supervised learning. However, the datasets we use do not accompany with such data. We therefore simulate the semi-supervised learning scenario by randomly sub-sampling K examples from the training split of each dataset as the labeled set L. To make the most use of the NL utterances in the dataset, we construct the unlabeled set U using all NL utterances in the training set3,4. Training Procedure .Optimizing the unsupervised learning objective Eq. ( 3 ) requires sampling structured MRs from the inference model qφ( z|x ). Due to the complexity of the semantic parsing problem, we cannot expect any valid samples from randomly initialized qφ( z|x ). We therefore pre-train the inference and reconstruction models using the supervised objective Eq. ( 2 ) until convergence, and then optimize using the semisupervised learning objective Eq. ( 1 ). Throughout all experiments we set α ( Eq. ( 1 ) ) and λ ( Eq. ( 3 ) ) to 0.1. The sample size |S( x )| is 5. We observe that the variance of the learning signal could still be high when low-quality samples are drawn from the inference model qφ( z|x ). We therefore clip all learning signals lower than k = −20.0. Earlystopping is used to avoid over-fitting. We also pretrain the prior p( z ) ( § 3.3 ) and the baseline function Eq. ( 6 ). Readers are referred to Appendix D for more detail of the configurations. Metric. As standard in semantic parsing research , we evaluate by exact-match accuracy . 4.3 Main Results Tab . 1 and Tab . 2 list the results on ATIS and DJANGO , resp , with varying amounts of labeled data L . We also present results of training the transition-based parser using only the supervised objective ( SUP., Eq. ( 2 ) ). We also compare STRUCTVAE with self-training ( SELFTRAIN ) , a semi-supervised learning baseline which uses the supervised parser to predict MRs for unlabeled utterances in U − L , and adds the predicted examples to the training set to fine-tune the supervised model . Results for STRUCTVAE are averaged over four runs to account for the additional fluctuation caused by REINFORCE training . Supervised System Comparison. First , to high-light the effectiveness of our transition parser based on ASDL grammar ( hence the reliability of our supervised baseline ) , we compare the supervised version of our parser with existing parsing models . On ATIS , our supervised parser trained on the full data is competitive with existing neural network based models , surpassing the SEQ2TREE model , and on par with the Abstract Syntax Network ( ASN ) without using extra supervision . On DJANGO , our model significantly outperforms the YN17 system , probably because the transition system used by our parser is defined natively to construct ASDL ASTs , reducing the number of actions for generating each example . On DJANGO , the average number of actions is 14.3 , compared with 20.3 reported in YN17 . Semi-supervised Learning . Next , we discuss our main comparison between STRUCTVAE with the supervised version of the parser ( recall that the supervised parser is used as the inference model in STRUCTVAE , § 3.2 ) . First , comparing our proposed STRUCTVAE with the supervised parser when there are extra unlabeled data ( i.e . , | L | < 4 , 434 for ATIS and | L | < 16 , 000 for DJANGO ) , semi-supervised learning with STRUCTVAE consistently achieves better performance . Notably , on DJANGO , our model registers results as competitive as previous state-of-the-art method ( YN17 ) using only half the training data ( 71.5 when | L | = 8000 v.s . 71.6 for YN17 ) . This demonstrates that STRUCTVAE is capable of learning from unlabeled NL utterances by inferring high quality , structurally rich latent meaning representations , further improving the performance of its supervised counterpart that is already competitive . Second , comparing STRUCTVAE with self-training , we find STRUCTVAE outperforms SELFTRAIN in eight out of ten settings , while SELFTRAIN under-performs the supervised parser in four out of ten settings . This shows self-training does not necessarily yield stable gains while STRUCTVAE does . Intuitively , STRUCTVAE would perform better since it benefits from the additional signal of the quality of MRs from the reconstruction model ( § 3.3 ) , for which we present more analysis in our next set of experiments . For the sake of completeness , we also report the results of STRUCTVAE when L is the full training set . Note that in this scenario there is no extra unlabeled data disjoint with the labeled set , and not surprisingly , STRUCTVAE does not outperform the supervised parser . In addition to the supervised objective Eq . ( 2 ) used by the supervised parser , STRUCTVAE has the extra unsupervised objective Eq . ( 3 ) , which uses sampled ( probably incorrect ) MRs to update the model . When there is no extra unlabeled data , those sampled ( incorrect ) MRs add noise to the optimization process , causing STRUCTVAE to under-perform . Study of Learning Signals .As discussed in § 3.3, in semi-supervised learning, the gradient received by the inference model from each sampled latent MR is weighted by the learning signal. Empirically, we would expect that on average, the learning signals of gold-standard samples z∗, l( x, z∗ ), are positive, larger than those of other ( imperfect ) samples z′, l( x, z′ ). We therefore study the statistics of l( x, z∗ ) and l( x, z′ ) for all utterances x ∈ U − L, i.e., the set of utterances which are not included in the labeled set.5 The statistics are obtained by performing inference using trained models. Figures 4a and 4b depict the histograms of learning signals on DJANGO and ATIS , resp . We observe that the learning signals for gold samples concentrate on positive intervals. We also show the mean and variance of the learning signals. On average, we have l( x, z∗ ) being positive and l( x, z ) negative. Also note that the distribution of l( x, z∗ ) has smaller variance and is more concentrated. Therefore the inference model receives informative gradient updates to discriminate between gold and imperfect samples. Next, we plot the distribution of the rank of l( x, z∗ ), among the learning signals of all samples of x, {l( x, zi ) : zi ∈ S( x )}. Results are shown in Fig. 5. We observe that the gold samples z∗ have the largest learning signals in around 80% cases. We also find that when z ∗ has the largest learning signal , its average difference with the learning signal of the highest-scoring incorrect sample is 1.27 and 0.96 on DJANGO and ATIS , respectively . Finally, to study the relative contribution of the reconstruction score log p( x|z ) and the prior log p( z ) to the learning signal, we present examples of inferred latent MRs during training ( Tab. 3 ). Examples 1&2 show that the reconstruction score serves as an informative quality measure of the latent MR, assigning the correct samples zs1 with high log p( x|z ), leading to positive learning signals. This is in line with our assumption that a good latent MR should adequately encode the semantics of the utterance. Example 3 shows that the prior is also effective in identifying “unnatural” MRs ( e.g., it is rare to add a function and a string literal, as in zs2 ). These results also suggest that the prior and the reconstruction model perform well with linearization of MRs. Finally, note that in Examples 2&3 the learning signals for the correct samples zs1 are positive even if their inference scores q( z|x ) are lower than those of zs2. This result further demonstrates that learning signals provide informative gradient weights for optimizing the inference model. Generalizing to Other Latent MRs . Our main results are obtained using a strong AST-based semantic parser as the inference model , with copy-augmented reconstruction model and an LSTM language model as the prior . However , there are many other ways to represent and infer structure in semantic parsing ( Carpenter , 1998 ; Steedman , 2000 ) , and thus it is of interest whether our basic STRUCTVAE framework generalizes to other semantic representations . To examine this , we test STRUCTVAE using λ-calculus logical forms as latent MRs for semantic parsing on the ATIS domain . We use standard sequence-to-sequence networks with attention ( Luong et al . , 2015 ) as inference and reconstruction models . The inference model is trained to construct a tree-structured logical form using the transition actions defined in Cheng et al. ( 2017 ). We use a classical tri-gram Kneser-Ney language model as the prior . Tab . 4 lists the results for this STRUCTVAE-SEQ model . We can see that even with this very different model structure STRUCTVAE still provides significant gains , demonstrating its compatibility with different inference / reconstruction networks and priors . Interestingly , compared with the results in Tab . 1 , we found that the gains are especially larger with few labeled examples — STRUCTVAE-SEQ achieves improvements of 8 - 10 points when | L | < 1000 . These results suggest that semi-supervision is especially useful in improving a mediocre parser in low resource settings. Impact of Baseline Functions. In § 3.3 we discussed our design of the baseline function b( x ) incorporated in the learning signal ( Eq. ( 4 ) ) to stabilize learning, which is based on a language model ( LM ) over utterances ( Eq. ( 6 ) ). We compare this baseline with a commonly used one in REINFORCE training : the multi-layer perceptron ( MLP ) . The MLP takes as input the last hidden state of the utterance given by the encoding LSTM of the inference model . Tab. 5 lists the results over sampled settings. We found that although STRUCTVAE with the MLP baseline sometimes registers better performance on ATIS , in most settings it is worse than our LM baseline , and could be even worse than the supervised parser . On the other hand, our LM baseline correlates well with the learning signal, yielding stable improvements over the supervised parser. This suggests the importance of using carefully designed baselines in REINFORCE learning , especially when the reward signal has large range ( e.g . , log-likelihoods ) . Impact of the Prior p( z ) . Fig . 6 depicts the performance of STRUCTVAE as a function of the KL term weight λ in Eq . ( 3 ) . When STRUCTVAE degenerates to a vanilla auto-encoder without the prior distribution ( i.e . , λ = 0 ) , it under-performs the supervised baseline . This is in line with our observation in Tab. 3 showing that the prior helps identify unnatural samples. The performance of the model also drops when λ > 0.1, suggesting that empirically controlling the influence of the prior to the inference model is important. Impact of Unlabeled Data Size. Fig. 7 illustrates the accuracies w.r.t. the size of unlabeled data. STRUCTVAE yields consistent gains as the size of the unlabeled data increases . 5 Related Works Semi-supervised Learning for NLP. Semisupervised learning comes with a long history ( Zhu , 2005 ) , with applications in NLP from early work of self-training ( Yarowsky , 1995 ) , and graph-based methods ( Das and Smith , 2011 ) , to recent advances in auto-encoders ( Cheng et al . , 2016 ; Socher et al . , 2011 ; Zhang et al . , 2017 ) and deep generative methods ( Xu et al . , 2017 ) . Our work follows the line of neural variational inference for text processing ( Miao et al . , 2016 ) , and resembles Miao and Blunsom ( 2016 ) , which uses VAEs to model summaries as discrete latent variables for semi-supervised summarization , while we extend the VAE architecture for more complex , tree-structured latent variables . Semantic Parsing .Most existing works alleviate issues of limited parallel data through weaklysupervised learning, using the denotations of MRs as indirect supervision ( Reddy et al., 2014; Krishnamurthy et al., 2016; Neelakantan et al., 2016; Pasupat and Liang, 2015; Yin et al., 2016 ). For semi-supervised learning of semantic parsing , Kate and Mooney ( 2007 ) first explore using transductive SVMs to learn from a semantic parser ’ s predictions . Konstas et al. ( 2017 ) apply self-training to bootstrap an existing parser for AMR parsing. Kocisky ´ et al . ( 2016 ) employ VAEs for semantic parsing , but in contrast to STRUCTVAE ’ s structured representation of MRs , they model NL utterances as flat latent variables , and learn from unlabeled MR data . There have also been efforts in unsupervised semantic parsing, which exploits external linguistic analysis of utterances ( e.g., dependency trees ) and the schema of target knowledge bases to infer the latent MRs ( Poon and Domingos, 2009; Poon, 2013 ). Another line of research is domain adaptation, which seeks to transfer a semantic parser learned from a source domain to the target domain of interest, therefore alleviating the need of parallel data from the target domain ( Su and Yan, 2017; Fan et al., 2017; Herzig and Berant, 2018 ). 6 Conclusion We propose STRUCTVAE , a deep generative model with tree-structured latent variables for semi-supervised semantic parsing . We apply STRUCTVAE to semantic parsing and code generation tasks , and show it outperforms a strong supervised parser using extra unlabeled data . "}
  },
    {
    "id": "P19-1010",
    "result":     [
            {
        "value":         {
          "start": 200,
          "end": 240,
          "text": "Graph Neural Network ( GNN ) architecture",
          "labels": ["Method"]
        },
        "id": 1468
      },
            {
        "value":         {
          "start": 346,
          "end": 367,
          "text": "decoder copy mechanism",
          "labels": ["Method"]
        },
        "id": 1469
      },
            {
        "value":         {
          "start": 641,
          "end": 644,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 2572,
          "end": 2601,
          "text": "Graph Neural Networks ( GNNs )",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 2810,
          "end": 2825,
          "text": "GNN architecture",
          "labels": ["Method"]
        },
        "id": 1473
      },
            {
        "value":         {
          "start": 2850,
          "end": 2873,
          "text": "self-attention mechanism",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 2882,
          "end": 2892,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 3005,
          "end": 3020,
          "text": "GNN architecture",
          "labels": ["Method"]
        },
        "id": 1473
      },
            {
        "value":         {
          "start": 3518,
          "end": 3531,
          "text": "copy mechanism",
          "labels": ["Method"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 3850,
          "end": 3853,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 6713,
          "end": 6723,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 6763,
          "end": 6776,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 6879,
          "end": 6892,
          "text": "copy mechanism",
          "labels": ["Method"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 6928,
          "end": 6938,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 6944,
          "end": 6967,
          "text": "self-attention mechanism",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 6979,
          "end": 7006,
          "text": "Graph Neural Network ( GNN )",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 7997,
          "end": 8010,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 8041,
          "end": 8051,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 8299,
          "end": 8302,
          "text": "GNNs",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 8845,
          "end": 8848,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 9444,
          "end": 9454,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 9496,
          "end": 9509,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 9615,
          "end": 9617,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 9731,
          "end": 9750,
          "text": "feed-forward network",
          "labels": ["Method"]
        },
        "id": 1543
      },
            {
        "value":         {
          "start": 10094,
          "end": 10104,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 10144,
          "end": 10157,
          "text": "self-attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 10185,
          "end": 10187,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 10290,
          "end": 10314,
          "text": "encoder-decoder attention",
          "labels": ["Method"]
        },
        "id": 1477
      },
            {
        "value":         {
          "start": 10685,
          "end": 10699,
          "text": "Pointer Network",
          "labels": ["Method"]
        },
        "id": 1478
      },
            {
        "value":         {
          "start": 11735,
          "end": 11763,
          "text": "encoder-decoder architectures",
          "labels": ["Method"]
        },
        "id": 1478
      },
            {
        "value":         {
          "start": 11922,
          "end": 11924,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 11930,
          "end": 11933,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 12009,
          "end": 12036,
          "text": "encoder-decoder architecture",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 12121,
          "end": 12135,
          "text": "copy mechanisms",
          "labels": ["Method"]
        },
        "id": 1480
      },
            {
        "value":         {
          "start": 12313,
          "end": 12326,
          "text": "WEBQUESTIONSSP",
          "labels": ["Dataset"]
        },
        "id": 1481
      },
            {
        "value":         {
          "start": 12438,
          "end": 12443,
          "text": "S-MART",
          "labels": ["Method"]
        },
        "id": 1482
      },
            {
        "value":         {
          "start": 12787,
          "end": 12814,
          "text": "encoder-decoder architecture",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 13337,
          "end": 13366,
          "text": "Graph Neural Networks ( GNNs )",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 13933,
          "end": 13936,
          "text": "GNNs",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 14384,
          "end": 14386,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 14424,
          "end": 14434,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 14440,
          "end": 14463,
          "text": "self-attention mechanism",
          "labels": ["Method"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 14470,
          "end": 14472,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 14933,
          "end": 14948,
          "text": "GeoQuery dataset",
          "labels": ["Dataset"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 15284,
          "end": 15329,
          "text": "Air Travel Information System ( ATIS ) dataset",
          "labels": ["Dataset"]
        },
        "id": 1483
      },
            {
        "value":         {
          "start": 16516,
          "end": 16529,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 17032,
          "end": 17052,
          "text": "masked self-attention",
          "labels": ["Method"]
        },
        "id": 1484
      },
            {
        "value":         {
          "start": 17156,
          "end": 17168,
          "text": "greedy search",
          "labels": ["Method"]
        },
        "id": 1485
      },
            {
        "value":         {
          "start": 17419,
          "end": 17422,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17594,
          "end": 17597,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 17672,
          "end": 17683,
          "text": "BERT encoder",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 17840,
          "end": 17843,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 18438,
          "end": 18446,
          "text": "BERTLARGE",
          "labels": ["Method"]
        },
        "id": 1486
      },
            {
        "value":         {
          "start": 18531,
          "end": 18544,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 18600,
          "end": 18603,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 19043,
          "end": 19045,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19051,
          "end": 19054,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19132,
          "end": 19137,
          "text": "ngrams",
          "labels": ["Method"]
        },
        "id": 1488
      },
            {
        "value":         {
          "start": 19426,
          "end": 19431,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19627,
          "end": 19632,
          "text": "ngrams",
          "labels": ["Method"]
        },
        "id": 1488
      },
            {
        "value":         {
          "start": 19916,
          "end": 19918,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19922,
          "end": 19925,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 19933,
          "end": 19938,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20598,
          "end": 20605,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20628,
          "end": 20635,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20674,
          "end": 20676,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20719,
          "end": 20722,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 20861,
          "end": 20867,
          "text": "SPI-DER",
          "labels": ["Dataset"]
        },
        "id": 1488
      },
            {
        "value":         {
          "start": 21009,
          "end": 21018,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 21062,
          "end": 21067,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 21097,
          "end": 21106,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 21409,
          "end": 21422,
          "text": "copy mechanism",
          "labels": ["Method"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 21874,
          "end": 21876,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22148,
          "end": 22157,
          "text": "Accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 22162,
          "end": 22164,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22168,
          "end": 22171,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22179,
          "end": 22184,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22513,
          "end": 22516,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 22541,
          "end": 22550,
          "text": "accuracies",
          "labels": ["Metric"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 22585,
          "end": 22587,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22593,
          "end": 22596,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 22781,
          "end": 22783,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 23325,
          "end": 23328,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23410,
          "end": 23413,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23424,
          "end": 23435,
          "text": "GNN approach",
          "labels": ["Method"]
        },
        "id": 1489
      },
            {
        "value":         {
          "start": 23479,
          "end": 23486,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 23506,
          "end": 23517,
          "text": "BERT encoder",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 23544,
          "end": 23547,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 23796,
          "end": 23801,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 24134,
          "end": 24141,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24600,
          "end": 24603,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24732,
          "end": 24735,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 24860,
          "end": 24865,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25060,
          "end": 25063,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 25069,
          "end": 25074,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25259,
          "end": 25261,
          "text": "GEO",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25267,
          "end": 25270,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25329,
          "end": 25332,
          "text": "ATIS",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 25782,
          "end": 25787,
          "text": "SPIDER",
          "labels": ["Dataset"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 26677,
          "end": 26679,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 26875,
          "end": 26902,
          "text": "Graph Neural Network ( GNN )",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 27432,
          "end": 27434,
          "text": "GNN",
          "labels": ["Method"]
        },
        "id": 1490
      }
    ],
    "data": {"text": "Generating Logical Forms from Graph Representations of Text and Entities Abstract Structured information about entities is critical for many semantic parsing tasks. We present an approach that uses a Graph Neural Network ( GNN ) architecture to incorporate information about relevant entities and their relations during parsing . Combined with a decoder copy mechanism , this approach provides a conceptually simple mechanism to generate logical forms with entities . We demonstrate that this approach is competitive with the state-of-the-art across several tasks without pretraining , and outperforms existing approaches when combined with BERT pre-training . 1 Introduction Semantic parsing maps natural language utterances into structured meaning representations. The representation languages vary between tasks, but typically provide a precise, machine interpretable logical form suitable for applications such as question answering ( Zelle and Mooney, 1996; Zettlemoyer and Collins, 2007; Liang et al., 2013; Berant et al., 2013 ). The logical forms typically consist of two types of symbols: a vocabulary of operators and domain-specific predicates or functions, and entities grounded to some knowledge base or domain. Recent approaches to semantic parsing have cast it as a sequence-to-sequence task ( Dong and Lapata, 2016; Jia and Liang, 2016; Ling et al., 2016 ), employing methods similar to those developed for neural machine translation ( Bahdanau et al., 2014 ), with strong results. However, special consideration is typically given to handling of entities. This is important to improve generalization and computational efficiency, as most tasks require handling entities unseen during training, and the set of unique entities can be large. Some recent approaches have replaced surface forms of entities in the utterance with placeholders ( Dong and Lapata, 2016 ). This requires a preprocessing step to completely disambiguate entities and replace their spans in the utterance. Additionally, for some tasks it may be beneficial to leverage relations between entities, multiple entity candidates per span, or entity candidates without a corresponding span in the utterance, while generating logical forms. Other approaches identify only types and surface forms of entities while constructing the logical form ( Jia and Liang, 2016 ), using a separate post-processing step to generate the final logical form with grounded entities. This ignores potentially useful knowledge about relevant entities. Meanwhile , there has been considerable recent interest in Graph Neural Networks ( GNNs ) ( Scarselli et al . , 2009 ; Li et al . , 2016 ; Kipf and Welling , 2017 ; Gilmer et al . , 2017 ; Velicˇkovic ´ et al . , 2018 ) for effectively learning representations for graph structures . We propose a GNN architecture based on extending the self-attention mechanism of the Transformer ( Vaswani et al . , 2017 ) to make use of relations between input elements . We present an application of this GNN architecture to semantic parsing , conditioning on a graph representation of the given natural language utterance and potentially relevant entities . This approach is capable of handling ambiguous and potentially conflicting entity candidates jointly with a natural language utterance, relaxing the need for completely disambiguating a set of linked entities before parsing. This graph formulation also enables us to incorporate knowledge about the relations between entities where available. Combined with a copy mechanism while decoding , this approach also provides a conceptually simple method for generating logical forms with grounded entities . We demonstrate the capability of the proposed architecture by achieving competitive results across 3 semantic parsing tasks. Further improvements are possible by incorporating a pretrained BERT ( Devlin et al . , 2018 ) encoder within the architecture . 2 Task Formulation Our goal is to learn a model for semantic parsing from pairs of natural language utterances and structured meaning representations. Let the natural language utterance be represented as a sequence x = ( x1, . . . , x|x| ) of |x| tokens, and the meaning representation be represented as a sequence y = ( y1, . . . , y|y| ) of |y| elements. The goal is to estimate p( y | x ), the conditional probability of the meaning representation y given utterance x, which is augmented by a set of potentially relevant entities. Input Utterance Each token xi ∈ V in is from a vocabulary of input tokens. Entity Candidates Given the input utterance x, we retrieve a set, e = {e1, . . . , e|e|}, of potentially relevant entity candidates, with e ⊆ Ve, where Ve is in the set of all entities for a given domain. We assume the availability of an entity candidate generator for each task to generate e given x, with details given in § 5.2. For each entity candidate, e ∈ Ve, we require a set of task-specific attributes containing one or more elements from Va. These attributes can be NER types or other characteristics of the entity, such as “city” or “river” for some of the entities listed in Table 1. Whereas Ve can be quite large for open domains, or even infinite if it includes sets such as the natural numbers, Va is typically much smaller. Therefore, we can effectively learn representations for entities given their set of attributes, from our set of example pairs. Edge Labels In addition to x and e for a particular example, we also consider the ( |x|+|e| )2 pairwise relations between all tokens and entity candidates, represented as edge labels. The edge label between tokens xi and xj corresponds to the relative sequential position, j − i, of the tokens, clipped to within some range. The edge label between token xi and entity ej , and vice versa, corresponds to whether xi is within the span of the entity candidate ej , or not. The edge label between entities ei and ej captures the relationship between the entities. These edge labels can have domain-specific interpretations, such as relations in a knowledge base, or any other type of entity interaction features. For tasks where this information is not available or useful, a single generic label between entity candidates can be used. Output We consider the logical form, y, to be a linear sequence ( Vinyals et al., 2015b ). We tokenize based on the syntax of each domain. Our formulation allows each element of y to be either an element of the output vocabulary, Vout, or an entity copied from the set of entity candidates e. Therefore, yi ∈ Vout ∪ Ve. Some experiments in §5.2 also allow elements of y to be tokens ∈ V in from x that are copied from the input. 3 Model Architecture Our model architecture is based on the Transformer ( Vaswani et al . , 2017 ) , with the self-attention sub-layer extended to incorporate relations between input elements , and the decoder extended with a copy mechanism . 3.1 GNN Sub-layer We extend the Transformer ’ s self-attention mechanism to form a Graph Neural Network ( GNN ) sublayer that incorporates a fully connected , directed graph with edge labels . The sub-layer maps an ordered sequence of node representations, u = ( u1, . . . , u|u| ), to a new sequence of node representations, u′ = ( u′1, . . . , u′|u| ), where each node is represented ∈ Rd. We use rij to denote the edge label corresponding to ui and uj . We implement this sub-layer in terms of a function f( m, l ) over a node representation m ∈ Rd and an edge label l that computes a vector representation in Rd′ . We use nheads parallel attention heads, with d′ = d/nheads. For each head k, the new representation for the node ui is computed by , where each coefficient αij is a softmax over the scaled dot products sij , and Wq is a learned matrix. Finally, we concatenate representations from each head, where Wh is another learned matrix and [ · · · ] denotes concatenation. If we implement f as , where Wr ∈ Rd ′ × d is a learned matrix , then the sub-layer would be effectively identical to self-attention as initially proposed in the Transformer ( Vaswani et al . , 2017 ) . We focus on two alternative formulations of f that represent edge labels as learned matrices and learned vectors. The first formulation represents edge labels as linear transformations , a common parameterization for GNNs ( Li et al . , 2016 ) , where Wl ∈ Rd ′ × d is a learned embedding matrix per edge label . Edge Vectors The second formulation represents edge labels as additive vectors using the same formulation as Shaw et al. ( 2018 ), where Wr ∈ Rd′×d is a learned matrix shared by all edge labels, and wl ∈ Rd is a learned embedding vector per edge label l. 3.2 Encoder Input Representations Before the initial encoder layer , tokens are mapped to initial representations using either a learned embedding table for V in , or the output of a pre-trained BERT ( Devlin et al . , 2018 ) encoder . Entity candidates are mapped to initial representations using the mean of the embeddings for each of the entity’s attributes, based on a learned embedding table for Va. We also concatenate an embedding representing the node type, token or entity, to each input representation. We assume some arbitrary ordering for entity candidates, generating a combined sequence of initial node representations for tokens and entities. We have edge labels between every pair of nodes as described in § 2. Encoder Layers Our encoder layers are essentially identical to the Transformer , except with the proposed extension to self-attention to incorporate edge labels . Therefore, each encoder layer consists of two sub-layers. The first is the GNN sub-layer , which yields new sets of token and entity representations . The second sub-layer is an element-wise feed-forward network . Each sublayer is followed by a residual connection and layer normalization ( Ba et al., 2016 ). We stack Nenc encoder layers, yielding a final set of token representations, wx( Nenc ), and entity representations, we( Nenc ). 3.3 Decoder The decoder auto-regressively generates output symbols, y1, . . . , y|y|. It is similarly based on the Transformer ( Vaswani et al . , 2017 ) , with the self-attention sub-layer replaced by the GNN sublayer . Decoder edge labels are based only on the relative timesteps of the previous outputs. The encoder-decoder attention layer considers both encoder outputs wx ( Nenc ) and we ( Nenc ) , jointly normalizing attention weights over tokens and entity candidates . We stack Ndec decoder layers to produce an output vector representation at each output step, zj ∈ Rdz , for j ∈ {1, . . . , |y|}. We allow the decoder to copy tokens or entity candidates from the input , effectively combining a Pointer Network ( Vinyals et al . , 2015a ) with a standard softmax output layer for selecting symbols from an output vocabulary ( Gu et al . , 2016 ; Gulcehre et al . , 2016 ; Jia and Liang , 2016 ) . We define a latent action at each output step, aj for j ∈ {1, . . . , |y|}, using similar notation as Jia et al. ( 2016 ). We normalize action probabilities with a softmax over all possible actions. Generating Symbols We can generate a symbol, denoted Generate[i], where wouti is a learned embedding vector for the element ∈ Vout with index i. If aj = Generate[i], then yj will be the element ∈ Vout with index i. Copying Entities We can also copy an entity candidate, denoted CopyEntity[i], where We is a learned matrix, and i ∈ {1, . . . , |e|}. If aj = CopyEntity[i], then yj = ei. 4 Related Work Various approaches to learning semantic parsers from pairs of utterances and logical forms have been developed over the years ( Tang and Mooney, 2000; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2011; Andreas et al., 2013 ). More recently , encoder-decoder architectures have been applied with strong results ( Dong and Lapata , 2016 ; Jia and Liang , 2016 ) . Even for tasks with relatively small domains of entities , such as GEO and ATIS , it has been shown that some special consideration of entities within an encoder-decoder architecture is important to improve generalization . This has included extending decoders with copy mechanisms ( Jia and Liang , 2016 ) and / or identifying entities in the input as a pre-processing step ( Dong and Lapata , 2016 ) . Other work has considered open domain tasks , such as WEBQUESTIONSSP ( Yih et al . , 2016 ) . Recent approaches have typically relied on a separate entity linking model , such as S-MART ( Yang and Chang , 2015 ) , to provide a single disambiguated set of entities to consider . In principle, a learned entity linker could also serve as an entity candidate generator within our framework, although we do not explore such tasks in this work. Considerable recent work has focused on constrained decoding of various forms within an encoder-decoder architecture to leverage the known structure of the logical forms . This has led to approaches that leverage this structure during decoding, such as using tree decoders ( Dong and Lapata, 2016; Alvarez-Melis and Jaakkola, 2017 ) or other mechanisms ( Dong and Lapata, 2018; Goldman et al., 2017 ). Other approaches use grammar rules to constrain decoding ( Xiao et al., 2016; Yin and Neubig, 2017; Krishnamurthy et al., 2017; Yu et al., 2018b ). We leave investigation of such decoder constraints to future work. Many formulations of Graph Neural Networks ( GNNs ) that propagate information over local neighborhoods have recently been proposed ( Li et al . , 2016 ; Kipf and Welling , 2017 ; Gilmer et al . , 2017 ; Velicˇkovic ´ et al . , 2018 ) . Recent work has often focused on large graphs ( Hamilton et al., 2017 ) and effectively propagating information over multiple graph steps ( Xu et al., 2018 ). The graphs we consider are relatively small and are fullyconnected, avoiding some of the challenges posed by learning representations for large, sparsely connected graphs. Other recent work related to ours has considered GNNs for natural language tasks , such as combining structured and unstructured data for question answering ( Sun et al . , 2018 ) , or for representing dependencies in tasks such as AMR parsing and machine translation ( Beck et al . , 2018 ; Bastings et al . , 2017 ) . The approach of Krishnamurthy et al . ( 2017 ) similarly considers ambiguous entity mentions jointly with query tokens for semantic parsing , although does not directly consider a GNN . Previous work has interpreted the Transformer ’ s self-attention mechanism as a GNN ( Velicˇkovic ´ et al . , 2018 ; Battaglia et al . , 2018 ) , and extended it to consider relative positions as edge representations ( Shaw et al . , 2018 ) . Previous work has also similarly represented edge labels as vectors, as opposed to matrices, in order to avoid over-parameterizing the model ( Marcheggiani and Titov, 2017 ). 5 Experiments 5.1 Semantic Parsing Datasets We consider three semantic parsing datasets, with examples given in Table 1. The GeoQuery dataset consists of natural language questions about US geography along with corresponding logical forms ( Zelle and Mooney , 1996 ) . We follow the convention of Zettlemoyer and Collins ( 2005 ) and use 600 training examples and 280 test examples. We use logical forms based on Functional Query Language ( FunQL ) ( Kate et al., 2005 ). The Air Travel Information System ( ATIS ) dataset consists of natural language queries about travel planning ( Dahl et al . , 1994 ) . We follow Zettlemoyer and Collins ( 2007 ) and use 4473 training examples, 448 test examples, and represent the logical forms as lambda expressions. SPIDER This is a large-scale text-to-SQL dataset that consists of 10,181 questions and 5,693 unique complex SQL queries across 200 database tables spanning 138 domains ( Yu et al., 2018c ). We use the standard training set of 8,659 training example and development set of 1,034 examples, split across different tables. 5.2 Experimental Setup Model Configuration We configured hyperparameters based on performance on the validation set for each task, if provided, otherwise cross-validated on the training set. For the encoder and decoder, we selected the number of layers from {1, 2, 3, 4} and embedding and hidden dimensions from {64, 128, 256}, setting the feed forward layer hidden dimensions 4× higher. We employed dropout at training time with Pdropout selected from {0.1, 0.2, 0.3, 0.4, 0.5, 0.6}. We used 8 attention heads for each task. We used a clipping distance of 8 for relative position representations ( Shaw et al., 2018 ). We used the Adam optimizer ( Kingma and Ba , 2015 ) with β1 = 0.9 , β2 = 0.98 , and  = 10 − 9 , and tuned the learning rate for each task . We used the same warmup and decay strategy for learning rate as Vaswani et al. ( 2017 ), selecting a number of warmup steps up to a maximum of 3000. Early stopping was used to determine the total training steps for each task. We used the final checkpoint for evaluation. We batched training examples together, and selected batch size from {32, 64, 128, 256, 512}. During training we used masked self-attention ( Vaswani et al . , 2017 ) to enable parallel decoding of output sequences . For evaluation , we used greedy search . We used a simple strategy of splitting each input utterance on spaces to generate a sequence of tokens. We mapped any token that didn’t occur at least 2 times in the training dataset to a special out-of-vocabulary token. For experiments that used BERT , we instead used the same wordpiece ( Wu et al . , 2016 ) tokenization as used for pre-training . For some of our experiments , we evaluated incorporating a pre-trained BERT ( Devlin et al . , 2018 ) encoder by effectively using the output of the BERT encoder in place of a learned token embedding table . We then continue to use graph encoder and decoder layers with randomly initialized parameters in addition to BERT , so there are many parameters that are not pre-trained . The additional encoder layers are still necessary to condition on entities and relations. We achieved best results by freezing the pretrained parameters for an initial number of steps, and then jointly fine-tuning all parameters, similar to existing approaches for gradual unfreezing ( Howard and Ruder, 2018 ). When unfreezing the pre-trained parameters, we restart the learning rate schedule. We found this to perform better than keeping pre-trained parameters either entirely frozen or entirely unfrozen during fine-tuning. We used BERTLARGE ( Devlin et al . , 2018 ) , which has 24 layers . For fine tuning we used the same Adam optimizer with weight decay and learning rate decay as used for BERT pre-training . We reduced batch sizes to accommodate the significantly larger model size, and tuned learning rate, warm up steps, and number of frozen steps for pre-trained parameters. Entity Candidate Generator We use an entity candidate generator that, given x, can retrieve a set of potentially relevant entities, e, for the given domain. Although all generators share a common interface, their implementation varies across tasks. For GEO and ATIS we use a lexicon of entity aliases in the dataset and attempt to match with ngrams in the query . Each entity has a single attribute corresponding to the entity’s type. We used binary valued relations between entity candidates based on whether entity candidate spans overlap, but experiments did not show significant improvements from incorporating these relations. For SPIDER , we generalize our notion of entities to include tables and table columns . We include all relevant tables and columns as entity candidates , but make use of Levenshtein distance between query ngrams and table and column names to determine edges between tokens and entity candidates . We use attributes based on the types and names of tables and columns. Edges between entity candidates capture relations between columns and the table they belong to, and foreign key relations. For GEO , ATIS , and SPIDER , this leads to 19.5% , 32.7% , and 74.6% of examples containing at least one span associated with multiple entity candidates , respectively , indicating some entity ambiguity . Further details on how entity candidate generators were constructed are provided in § A.1. Output Sequences We pre-processed output sequences to identify entity argument values, and replaced those elements with references to entity candidates in the input. In cases where our entity candidate generator did not retrieve an entity that was used as an argument, we dropped the example from the training data set or considered it incorrect if in the test set. Evaluation To evaluate accuracy , we use exact match accuracy relative to gold logical forms . For GEO we directly compare output symbols . For ATIS , we compare normalized logical forms using canonical variable naming and sorting for unordered arguments ( Jia and Liang , 2016 ) . For SPI-DER we use the provided evaluation script , which decomposes each SQL query and conducts set comparison within each clause without values . All accuracies are reported on the test set , except for SPIDER where we report and compare accuracies on the development set . Copying Tokens To better understand the effect of conditioning on entities and their relations, we also conducted experiments that considered an alternative method for selecting and disambiguating entities similar to Jia et al. ( 2016 ). In this approach we use our model ’ s copy mechanism to copy tokens corresponding to the surface forms of entity arguments , rather than copying entities directly . where Wx is a learned matrix, and where i ∈ {1, . . . , |x|} refers to the index of token xi ∈ V in. If aj = CopyToken[i], then yj = xi. This allows us to ablate entity information in the input while still generating logical forms. When copying tokens, the decoder determines the type of the entity using an additional output symbol. For GEO , the actual entity can then be identified as a post-processing step , as a type and surface form is sufficient . For other tasks this could require a more complicated post-processing step to disambiguate entities given a surface form and type. 5.3 Results and Analysis Accuracies on GEO , ATIS , and SPIDER are shown in Table 2 . GEO and ATIS Without pre-training, and despite adding a bit of entity ambiguity, we achieve similar results to other recent approaches that disambiguate and replace entities in the utterance as a pre-processing step during both training and evaluating ( Dong and Lapata, 2016, 2018 ). When incorporating BERT , we increase absolute accuracies over Dong and Lapata ( 2018 ) on GEO and ATIS by 3.2% and 2.0% , respectively . Notably, they also present techniques and results that leverage constrained decoding, which our approach would also likely further benefit from. For GEO , we find that when ablating all entity information in our model and copying tokens instead of entities , we achieve similar results as Jia and Liang ( 2016 ) when also ablating their data augmentation method , as shown in Table 3 . This is expected, since when ablating entities completely, our architecture essentially reduces to the same sequence-to-sequence task setup. These results demonstrate the impact of conditioning on the entity candidates, as it improves performance even on the token copying setup. It appears that leveraging BERT can partly compensate for not conditioning on entity candidates , but combining BERT with our GNN approach and copying entities achieves 2.9% higher accuracy than using only a BERT encoder and copying tokens . For ATIS , our results are outperformed by Wang et al . ( 2014 ) by 1.6% . Their approach uses hand-engineered templates to build a CCG lexicon. Some of these templates attempt to handle the specific types of ungrammatical utterances in the ATIS task. For SPIDER , a relatively new dataset , there is less prior work . Competitive approaches have been specific to the text-to-SQL task ( Xu et al., 2017; Yu et al., 2018a,b ), incorporating taskspecific methods to condition on table and column information, and incorporating SQL-specific structure when decoding. Our approach improves absolute accuracy by + 7.3% relative to Yu et al . ( 2018b ) without using any pre-trained language representations , or constrained decoding . Our approach could also likely benefit from some of the other aspects of Yu et al. ( 2018b ) such as more structured decoding, data augmentation, and using pre-trained representations ( they use GloVe ( Pennington et al., 2014 ) ) for tokens, columns, and tables. Our results were surprisingly worse when attempting to incorporate BERT . Of course, successfully incorporating pre-trained representations is not always straightforward. In general , we found using BERT within our architecture to be sensitive to learning rates and learning rate schedules . Notably , the evaluation setup for SPIDER is very different than training , as examples are for tables unseen during training . Models may not generalize well to unseen tables and columns. It ’ s likely that successfully incorporating BERT for SPIDER would require careful tuning of hyperparameters specifically for the database split configuration . Entity Spans and Relations Ablating span relations between entities and tokens for GEO and ATIS is shown in Table 4 . The impact is more significant for ATIS , which contains many queries with multiple entities of the same type , such as nonstop flights seattle to boston where disambiguating the origin and destination entities requires knowledge of which tokens they are associated with , given that we represent entities based only on their types for these tasks . We leave for future work consideration of edges between entity candidates that incorporate relevant domain knowledge for these tasks. For SPIDER , results ablating relations between entities and tokens , and relations between entities , are shown in Table 5 . This demonstrates the importance of entity relations, as they include useful information for disambiguating entities such as which columns belong to which tables, and which columns have foreign key relations. Edge Representations Using additive edge vectors outperforms using learned edge matrix transformations for implementing f , across all tasks. While the vector formulation is less expressive, it also introduces far fewer parameters per edge type, which can be an important consideration given that our graph contains many similar edge labels, such as those representing similar relative positions between tokens. We leave further exploration of more expressive edge representations to future work. Another direction to explore is a heterogeneous formulation of the GNN sub-layer , that employs different formulations for different subsets of nodes , e.g . for tokens and entities . 6 Conclusions We have presented an architecture for semantic parsing that uses a Graph Neural Network ( GNN ) to condition on a graph of tokens , entities , and their relations . Experimental results have demonstrated that this approach can achieve competitive results across a diverse set of tasks, while also providing a conceptually simple way to incorporate entities and their relations during parsing. For future direction , we are interested in exploring constrained decoding , better incorporating pre-trained language representations within our architecture , conditioning on additional relations between entities , and different GNN formulations . More broadly, we have presented a flexible approach for conditioning on available knowledge in the form of entities and their relations, and demonstrated its effectiveness for semantic parsing. "}
  },
    {
    "id": "P19-1028",
    "result":     [
            {
        "value":         {
          "start": 1947,
          "end": 1969,
          "text": "Attention-driven models",
          "labels": ["Method"]
        },
        "id": 1490
      },
            {
        "value":         {
          "start": 1979,
          "end": 1983,
          "text": "BiDAF",
          "labels": ["Method"]
        },
        "id": 1495
      },
            {
        "value":         {
          "start": 2399,
          "end": 2408,
          "text": "ConceptNet",
          "labels": ["Dataset"]
        },
        "id": 1496
      },
            {
        "value":         {
          "start": 16996,
          "end": 17039,
          "text": "attention-based machine comprehension models",
          "labels": ["Method"]
        },
        "id": 1493
      },
            {
        "value":         {
          "start": 17044,
          "end": 17065,
          "text": "SQuAD ( v1.1 ) dataset",
          "labels": ["Dataset"]
        },
        "id": 1494
      },
            {
        "value":         {
          "start": 17164,
          "end": 17173,
          "text": "ConceptNet",
          "labels": ["Dataset"]
        },
        "id": 1496
      },
            {
        "value":         {
          "start": 17284,
          "end": 17288,
          "text": "BiDAF",
          "labels": ["Method"]
        },
        "id": 1495
      },
            {
        "value":         {
          "start": 17321,
          "end": 17341,
          "text": "ELMoaugmented variant",
          "labels": ["Method"]
        },
        "id": 1495
      },
            {
        "value":         {
          "start": 17879,
          "end": 17888,
          "text": "ConceptNet",
          "labels": ["Dataset"]
        },
        "id": 1496
      },
            {
        "value":         {
          "start": 19000,
          "end": 19009,
          "text": "ConceptNet",
          "labels": ["Dataset"]
        },
        "id": 1496
      },
            {
        "value":         {
          "start": 19685,
          "end": 19688,
          "text": "ELMo",
          "labels": ["Method"]
        },
        "id": 1497
      },
            {
        "value":         {
          "start": 19694,
          "end": 19697,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20025,
          "end": 20028,
          "text": "ELMo",
          "labels": ["Method"]
        },
        "id": 1497
      },
            {
        "value":         {
          "start": 20689,
          "end": 20700,
          "text": "SNLI dataset",
          "labels": ["Dataset"]
        },
        "id": 1501
      },
            {
        "value":         {
          "start": 20773,
          "end": 20794,
          "text": "decomposable attention",
          "labels": ["Method"]
        },
        "id": 1498
      },
            {
        "value":         {
          "start": 20894,
          "end": 20897,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20908,
          "end": 20913,
          "text": "L-DAtt",
          "labels": ["Method"]
        },
        "id": 1499
      },
            {
        "value":         {
          "start": 20955,
          "end": 20966,
          "text": "L-DAtt model",
          "labels": ["Method"]
        },
        "id": 1500
      },
            {
        "value":         {
          "start": 22044,
          "end": 22055,
          "text": "SNLI dataset",
          "labels": ["Dataset"]
        },
        "id": 1501
      },
            {
        "value":         {
          "start": 23887,
          "end": 23903,
          "text": "CoNLL2000 dataset",
          "labels": ["Dataset"]
        },
        "id": 1501
      },
            {
        "value":         {
          "start": 24021,
          "end": 24030,
          "text": "BiLSTM-CRF",
          "labels": ["Method"]
        },
        "id": 1505
      },
            {
        "value":         {
          "start": 24217,
          "end": 24219,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 24267,
          "end": 24279,
          "text": "BiLSTM tagger",
          "labels": ["Method"]
        },
        "id": 1503
      },
            {
        "value":         {
          "start": 24980,
          "end": 25003,
          "text": "first-order Markov model",
          "labels": ["Method"]
        },
        "id": 1504
      },
            {
        "value":         {
          "start": 25019,
          "end": 25028,
          "text": "BiLSTM-CRF",
          "labels": ["Method"]
        },
        "id": 1505
      },
            {
        "value":         {
          "start": 25156,
          "end": 25164,
          "text": "CRF model",
          "labels": ["Method"]
        },
        "id": 1505
      },
            {
        "value":         {
          "start": 25479,
          "end": 25481,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 25832,
          "end": 25836,
          "text": "KBANN",
          "labels": ["Method"]
        },
        "id": 1505
      },
            {
        "value":         {
          "start": 25999,
          "end": 26006,
          "text": "CILP + +",
          "labels": ["Method"]
        },
        "id": 1506
      },
            {
        "value":         {
          "start": 26246,
          "end": 26248,
          "text": "PSL",
          "labels": ["Method"]
        },
        "id": 1507
      },
            {
        "value":         {
          "start": 27357,
          "end": 27390,
          "text": "gradient-based learning algorithms",
          "labels": ["Method"]
        },
        "id": 1508
      },
            {
        "value":         {
          "start": 27759,
          "end": 27779,
          "text": "Markov Logic Networks",
          "labels": ["Dataset"]
        },
        "id": 1509
      },
            {
        "value":         {
          "start": 27960,
          "end": 27988,
          "text": "Constrained Conditional Model",
          "labels": ["Method"]
        },
        "id": 1510
      }
    ],
    "data": {"text": "Augmenting Neural Networks with First-order Logic Abstract Today, the dominant paradigm for training neural networks involves minimizing task loss on a large dataset. Using world knowledge to inform a model, and yet retain the ability to perform end-to-end training remains an open question. In this paper, we present a novel framework for introducing declarative knowledge to neural network architectures in order to guide training and prediction. Our framework systematically compiles logical statements into computation graphs that augment a neural network without extra learnable parameters or manual redesign. We evaluate our modeling strategy on three tasks: machine comprehension, natural language inference, and text chunking. Our experiments show that knowledge-augmented networks can strongly improve over baselines, especially in low-data regimes. 1 Introduction Neural models demonstrate remarkable predictive performance across a broad spectrum of NLP tasks: e.g., natural language inference ( Parikh et al., 2016 ), machine comprehension ( Seo et al., 2017 ), machine translation ( Bahdanau et al., 2015 ), and summarization ( Rush et al., 2015 ). These successes can be attributed to their ability to learn robust representations from data. However, such end-to-end training demands a large number of training examples; for example, training a typical network for machine translation may require millions of sentence pairs ( e.g. Luong et al., 2015 ). The difficulties and expense of curating large amounts of annotated data are well understood and, consequently, massive datasets may not be available for new tasks, domains or languages. In this paper, we argue that we can combat the data hungriness of neural networks by taking advantage of domain knowledge expressed as first-order logic. As an example, consider the task of reading comprehension, where the goal is to answer a question based on a paragraph of text ( Fig. 1 ). Attention-driven models such as BiDAF ( Seo et al . , 2017 ) learn to align words in the question with words in the text as an intermediate step towards identifying the answer . While alignments ( e.g . author to writing ) can be learned from data , we argue that models can reduce their data dependence if they were guided by easily stated rules such as : Prefer aligning phrases that are marked as similar according to an external resource , e.g . , ConceptNet ( Liu and Singh , 2004 ) . If such declaratively stated rules can be incorporated into training neural networks, then they can provide the inductive bias that can reduce data dependence for training. That general neural networks can represent such Boolean functions is known and has been studied both from the theoretical and empirical perspectives ( e.g. Maass et al., 1994; Anthony, 2003; Pan and Srikumar, 2016 ). Recently, Hu et al. ( 2016 ) exploit this property to train a neural network to mimic a teacher network that uses structured rules. In this paper, we seek to directly incorporate such structured knowledge into a neural network architecture without substantial changes to the training methods. We focus on three questions: 1. Can we integrate declarative rules with end-to-end neural network training? Can such rules help ease the need for data? How does incorporating domain expertise compare against large training resources powered by pre-trained representations? The first question poses the key technical challenge we address in this paper. On one hand, we wish to guide training and prediction with neural networks using logic, which is non-differentiable. On the other hand, we seek to retain the advantages of gradient-based learning without having to redesign the training scheme. To this end, we propose a framework that allows us to systematically augment an existing network architecture using constraints about its nodes by deterministically converting rules into differentiable computation graphs. To allow for the possibility of such rules being incorrect, our framework is designed to admit soft constraints from the ground up. Our framework is compatible with off-the-shelf neural networks without extensive redesign or any additional trainable parameters. To address the second and the third questions, we empirically evaluate our framework on three tasks: machine comprehension, natural language inference, and text chunking. In each case, we use a general off-the-shelf model for the task, and study the impact of simple logical constraints on observed neurons ( e.g., attention ) for different data sizes. We show that our framework can successfully improve an existing neural design, especially when the number of training examples is limited. In summary, our contributions are: 1. We introduce a new framework for incorporating first-order logic rules into neural network design in order to guide both training and prediction. We evaluate our approach on three different NLP tasks: machine comprehension, textual entailment, and text chunking. We show that augmented models lead to large performance gains in the low training data regimes.1 2 Problem Setup In this section, we will introduce the notation and assumptions that form the basis of our formalism for constraining neural networks. Neural networks are directed acyclic computation graphs G = ( V,E ), consisting of nodes ( i.e. neurons ) V and weighted directed edges E that represent information flow. Although not all neurons have explicitly grounded meanings, some nodes indeed can be endowed with semantics tied to the task. Node semantics may be assigned during model design ( e.g. attention ), or incidentally discovered in post hoc analysis ( e.g., Le et al., 2012; Radford et al., 2017, and others ). In either case, our goal is to augment a neural network with such named neurons using declarative rules. The use of logic to represent domain knowledge has a rich history in AI ( e.g. Russell and Norvig, 2016 ). In this work, to capture such knowledge, we will primarily focus on conditional statements of the form L → R, where the expression L is the antecedent ( or the left-hand side ) that can be conjunctions or disjunctions of literals, and R is the consequent ( or the right-hand side ) that consists of a single literal. Note that such rules include Horn clauses and their generalizations, which are well studied in the knowledge representation and logic programming communities ( e.g. Chandra and Harel, 1985 ). Integrating rules with neural networks presents three difficulties. First, we need a mapping between the predicates in the rules and nodes in the computation graph. Second, logic is not differentiable; we need an encoding of logic that admits training using gradient based methods. Finally, computation graphs are acyclic, but user-defined rules may introduce cyclic dependencies between the nodes. Let us look at these issues in order. As mentioned before, we will assume named neurons are given. And by associating predicates with such nodes that are endowed with symbolic meaning, we can introduce domain knowledge about a problem in terms of these predicates. In the rest of the paper, we will use lower cased letters ( e.g., ai, bj ) to denote nodes in a computation graph, and upper cased letters ( e.g., Ai, Bj ) for predicates associated with them. To deal with the non-differentiablity of logic, we will treat the post-activation value of a named neuron as the degree to which the associated predicate is true. In §3, we will look at methods for compiling conditional statements into differentiable statements that augment a given network. Cyclicity of Constraints. Since we will augment computation graphs with compiled conditional forms, we should be careful to avoid creating cycles. To formalize this, let us define cyclicity of conditional statements with respect to a neural network. Given two nodes a and b in a computation graph, we say that the node a is upstream of node b if there is a directed path from a to b in the graph. Definition 1. ( Cyclic and Acyclic Implications ). Let G be a computation graph. An implicative statement L → R is cyclic with respect to G if, for any literalRi ∈ R, the node ri associated with it is upstream of the node lj associated with some literal Lj ∈ L. An implicative statement is acyclic if it is not cyclic. Fig. 2 and its caption gives examples of cyclic and acyclic implications. A cyclic statement sometimes can be converted to an equivalent acyclic statement by constructing its contrapositive. For example, the constraint B1 → A1 is equivalent to ¬A1 → ¬B1. While the former is cyclic, the later is acyclic. Generally, we can assume that we have acyclic implications.2 3 A Framework for Augmenting Neural Networks with Constraints To create constraint-aware neural networks, we will extend the computation graph of an existing network with additional edges defined by constraints. In §3.1, we will focus on the case where the antecedent is conjunctive/disjunctive and the consequent is a single literal. In §3.2, we will cover more general antecedents. 3.1 Constraints Beget Distance Functions Given a computation graph, suppose we have a acyclic conditional statement: Z → Y , where Z is a conjunction or a disjunction of literals and Y is a single literal. We define the neuron associated with Y to be y = g ( Wx ), where g denotes an activation function, W are network parameters, x is the immediate input to y. Further, let the vector z represent the neurons associated with the predicates in Z. While the nodes z need to be named neurons, the immediate input x need not necessarily have symbolic meaning. Constrained Neural Layers. Our goal is to augment the computation of y so that whenever Z is true, the pre-activated value of y increases if the literal Y is not negated ( and decreases if it is ). To do so, we define a constrained neural layer as . Here, we will refer to the function d as the distance function that captures, in a differentiable way, whether the antecedent of the implication holds. The importance of the entire constraint is decided by a real-valued hyper-parameter ρ ≥ 0. The definition of the constrained neural layer says that, by compiling an implicative statement into a distance function, we can regulate the preactivation scores of the downstream neurons based on the states of upstream ones. Designing the distance function. The key consideration in the compilation step is the choice of an appropriate distance function for logical statements. The ideal distance function we seek is the indicator for the statement Z: . However, since the function dideal is not differentiable, we need smooth surrogates. In the rest of this paper, we will define and use distance functions that are inspired by probabilistic soft logic ( c.f. Klement et al., 2013 ) and its use of the Łukasiewicz T-norm and T-conorm to define a soft version of conjunctions and disjunctions.3 Table 1 summarizes distance functions corresponding to conjunctions and disjunctions. In all cases, recall that the zi’s are the states of neurons and are assumed to be in the range [0, 1]. Examining the table, we see that with a conjunctive antecedent ( first row ), the distance becomes zero if even one of the conjuncts is false. For a disjunctive antecedent ( second row ), the distance becomes zero only when all the disjuncts are false; otherwise, it increases as the disjuncts become more likely to be true. Negating Predicates. Both the antecedent ( the Z’s ) and the consequent ( Y  ) could contain negated predicates. We will consider these separately. For any negated antecedent predicate, we modify the distance function by substituting the corresponding zi with 1 − zi in Table 1. The last two rows of the table list out two special cases, where the entire antecedents are negated, and can be derived from the first two rows. To negate consequent Y , we need to reduce the pre-activation score of neuron y. To achieve this, we can simply negate the entire distance function. Scaling factor ρ. In Eq. 1, the distance function serves to promote or inhibit the value of downstream neuron. The extent is controlled by the scaling factor ρ. For instance, with ρ = +∞, the pre-activation score of the downstream neuron is dominated by the distance function. In this case, we have a hard constraint. In contrast, with a small ρ, the output state depends on both the Wx and the distance function. In this case, the soft constraint serves more as a suggestion. Ultimately, the network parameters might overrule the constraint. We will see an example in §4 where noisy constraint prefers small ρ. 3.2 General Boolean Antecedents So far, we exclusively focused on conditional statements with either conjunctive or disjunctive antecedents. In this section, we will consider general antecedents. As an illustrative example, suppose we have an antecedent ( ¬A ∨ B ) ∧ ( C ∨ D ). By introducing auxiliary variables, we can convert it into the conjunctive form P ∧ Q, where ( ¬A ∨ B ) ↔ P and ( C∨D )↔ Q. To perform such operation, we need to: ( 1 ) introduce auxiliary neurons associated with the auxiliary predicates P andQ, and, ( 2 ) define these neurons to be exclusively determined by the biconditional constraint. To be consistent in terminology, when considering biconditional statement ( ¬A ∨B )↔ P , we will call the auxiliary literal P the consequent, and the original literals A and B the antecedents. Because the implication is bidirectional in biconditional statement, it violates our acyclicity requirement in §3.1. However, since the auxiliary neuron state does not depend on any other nodes, we can still create an acyclic sub-graph by defining the new node to be the distance function itself. Constrained Auxiliary Layers. With a biconditional statement Z ↔ Y , where Y is an auxiliary literal, we define a constrained auxiliary layer as where d is the distance function for the statement, z are upstream neurons associated with Z, y is the downstream neuron associated with Y . Note that, compared to Eq. 1, we do not need activation function since the distance, which is in [0, 1], can be interpreted as producing normalized scores. Note that this construction only applies to auxiliary predicates in biconditional statements. The advantage of this layer definition is that we can use the same distance functions as before ( i.e., Table 1 ). Furthermore, the same design considerations in §3.1 still apply here, including how to negate the left and right hand sides. Constructing augmented networks. To complete the modeling framework, we summarize the workflow needed to construct an augmented neural network given a conditional statement and a computation graph: ( 1 ) Convert the antecedent into a conjunctive or a disjunctive normal form if necessary. ( 2 ) Convert the conjunctive/disjunctive antecedent into distance functions using Table 1 ( with appropriate corrections for negations ). ( 3 ) Use the distance functions to construct constrained layers and/or auxiliary layers to augment the computation graph by replacing the original layer with constrained one. ( 4 ) Finally, use the augmented network for end-to-end training and inference. We will see complete examples in §4. 3.3 Discussion Not only does our design not add any more trainable parameters to the existing network, it also admits efficient implementation with modern neural network libraries. When posing multiple constraints on the same downstream neuron, there could be combinatorial conflicts. In this case, our framework relies on the base network to handle the consistency issue. In practice, we found that summing the constrained pre-activation scores for a neuron is a good heuristic ( as we will see in §4.3 ). For a conjunctive consequent, we can decompose it into multiple individual constraints. That is equivalent to constraining downstream nodes independently. Handling more complex consequents is a direction of future research. 4 Experiments In this section, we will answer the research questions raised in §1 by focusing on the effectiveness of our augmentation framework. Specifically, we will explore three types of constraints by augmenting: 1 ) intermediate decisions ( i.e. attentions ); 2 ) output decisions constrained by intermediate states; 3 ) output decisions constrained using label dependencies. To this end, we instantiate our framework on three tasks: machine comprehension, natural language inference, and text chunking. Across all experiments, our goal is to study the modeling flexibility of our framework and its ability to improve performance, especially with decreasing amounts of training data. To study low data regimes, our augmented networks are trained using varying amounts of training data to see how performances vary from baselines. For detailed model setup, please refer to the appendices. 4.1 Machine Comprehension Attention is a widely used intermediate state in several recent neural models. To explore the augmentation over such neurons , we focus on attention-based machine comprehension models on SQuAD ( v1.1 ) dataset ( Rajpurkar et al . , 2016 ) . We seek to use word relatedness from external resources ( i.e . , ConceptNet ) to guide alignments , and thus to improve model performance . Model. We base our framework on two models : BiDAF ( Seo et al . , 2017 ) and its ELMoaugmented variant ( Peters et al . , 2018 ) . Here, we provide an abstraction of the two models which our framework will operate on: where p and q are the paragraph and query respectively, σ refers to the softmax activation, ←−a and −→a are the bidirectional attentions from q to p and vice versa, y and z are the probabilities of answer boundaries. All other aspects are abstracted as encoder and layers. Augmentation. By construction of the attention neurons, we expect that related words should be aligned. In a knowledge-driven approach , we can use ConceptNet to guide the attention values in the model in Eq . 4 . We consider two rules to illustrate the flexibility of our framework. Both statements are in firstorder logic that are dynamically grounded to the computation graph for a particular paragraph and query. First, we define the following predicates: Ki,j word pi is related to word qj in ConceptNet via edges {Synonym, DistinctFrom, IsA, Related}.←− A i,j unconstrained model decision that word qj best matches to word pi.←− A ′i,j constrained model decision for the above alignment. Using these predicates, we will study the impact of the following two rules, defined over a set C of content words in p and q: The rule R1 says that two words should be aligned if they are related. Interestingly, compiling this statement using the distance functions in Table 1 is essentially the same as adding word relatedness as a static feature. The ruleR2 is more conservative as it also depends on the unconstrained model decision. In both cases , since Ki , j does not map to a node in the network , we have to create a new node ki , j whose value is determined using ConceptNet , as illustrated in Fig . 3 . Can our framework use rules over named neurons to improve model performance? The answer is yes. We experiment with rules R1 and R2 on incrementally larger training data. Performances are reported in Table 2 with comparison with baselines. We see that our framework can indeed use logic to inform model learning and prediction without any extra trainable parameters needed. The improvement is particularly strong with small training sets. With more data, neural models are less reliant on external information. As a result, the improvement with larger datasets is smaller. How does it compare to pretrained encoders? Pretrained encoders ( e.g . ELMo and BERT ( Devlin et al . , 2018 ) ) improve neural models with improved representations , while our framework augments the graph using first-order logic . It is important to study the interplay of these two orthogonal directions. We can see in Table 2 , our augmented model consistently outperforms baseline even with the presence of ELMo embeddings . Does the conservative constraint R2 help? We explored two options to incorporate word relatedness; one is a straightforward constraint ( i.e. R1 ), another is its conservative variant ( i.e. R2 ). It is a design choice as to which to use. Clearly in Table 2, constraint R1 consistently outperforms its conservative alternativeR2, even thoughR2 is better than baseline. In the next task, we will see an example where a conservative constraint performs better with large training data. 4.2 Natural Language Inference Unlike in the machine comprehension task, here we explore logic rules that bridge attention neurons and output neurons. We use the SNLI dataset ( Bowman et al . , 2015 ) , and base our framework on a variant of the decomposable attention ( DAtt , Parikh et al . , 2016 ) model where we replace its projection encoder with bidirectional LSTM ( namely L-DAtt ) . Again , we abstract the pipeline of L-DAtt model , only focusing on layers which our framework works on . Given a premise p and a hypothesis h, we summarize the model as: Here, σ is the softmax activation, ←−a and −→a are bidirectional attentions, y are probabilities for labels Entailment, Contradiction, and Neutral. Augmentation. We will borrow the predicate notation defined in the machine comprehension task ( §4.1 ), and ground them on premise and hypothesis words, e.g. Ki,j now denotes the relatedness between premise word pi and hypothesis word hj . In addition, we define the predicate Yl to indicate that the label is l. As in §4.1, we define two rules governing attention: where C is the set of content words. Note that the two constraints apply to both attention directions. Intuitively, if a hypothesis content word is not aligned, then the prediction should not be Entailment. To use this knowledge, we define the following rule: where Z1 and Z2 are auxiliary predicates tied to the Y ′Entail predicate. The details of N3 are illustrated in Fig. 4. How does our framework perform with large training data? The SNLI dataset is a large dataset with over half-million examples . We train our models using incrementally larger percentages of data and report the average performance in Table 3. Similar to §4.1, we observe strong improvements from augmented models trained on small percentages ( ≤10% ) of data. The straightforward constraint N1 performs strongly with ≤2% data while its conservative alternative N2 works better with a larger set. However, with full dataset, our augmented models perform only on par with baseline even with lowered scaling factor ρ. These observations suggest that if a large dataset is available, it may be better to believe the data, but with smaller datasets, constraints can provide useful inductive bias for the models. Are noisy constraints helpful? It is not always easy to state a constraint that all examples satisfy. Comparing N2 and N3, we see that N3 performed even worse than baseline, which suggests it contains noise. In fact, we found a significant amount of counter examples to N3 during preliminary analysis. Yet, even a noisy rule can improve model performance with ≤10% data. The same observation holds for N1, which suggests conservative constraints could be a way to deal with noise. Finally, by comparingN2 andN2,3, we find that the good constraint N2 can not just augment the network, but also amplify the noise inN3 when they are combined. This results in degrading performance in the N2,3 column starting from 5% of the data, much earlier than using N3 alone. 4.3 Text Chunking Attention layers are a modeling choice that do not always exist in all networks. To illustrate that our framework is not necessarily grounded to attention, we turn to an application where we use knowledge about the output space to constrain predictions. We focus on the sequence labeling task of text chunking using the CoNLL2000 dataset ( Tjong Kim Sang and Buchholz , 2000 ) . In such sequence tagging tasks , global inference is widely used , e.g . , BiLSTM-CRF ( Huang et al . , 2015 ) . Our framework, on the other hand, aims to promote local decisions. To explore the interplay of global model and local decision augmentation , we will combine CRF with our framework . Model. Our baseline is a BiLSTM tagger : where x is the input sentence , σ is softmax , y are the output probabilities of BIO tags . Augmentation. We define the following predicates for input and output neurons: Then we can write rules for pairwise label dependency. For instance, if word t has B/I- tag for a certain label, word t+1 can not have an I- tag with a different label. Our second set of rules are also intuitive: A noun should not have non-NP label. While all above rules can be applied as hard constraints in the output space, our framework provides a differentiable way to inform the model during training and prediction. How does local augmentation compare with global inference? We report performances in Table 4. While a first-order Markov model ( e.g . , the BiLSTM-CRF ) can learn pairwise constraints such as C1 : 4 , we see that our framework can better inform the model . Interestingly , the CRF model performed even worse than the baseline with ≤ 40% data . This suggests that global inference relies on more training examples to learn its scoring function. In contrast, our constrained models performed strongly even with small training sets. And by combining these two orthogonal methods , our locally augmented CRF performed the best with full data . 5 Related Work and Discussion Artificial Neural Networks and Logic. Our work is related to neural-symbolic learning ( e.g. Besold et al., 2017 ) which seeks to integrate neural networks with symbolic knowledge. For example, Cingillioglu and Russo ( 2019 ) proposed neural models that multi-hop logical reasoning. KBANN ( Towell et al . , 1990 ) constructs artificial neural networks using connections expressed in propositional logic . Along these lines , França et al . ( 2014 , CILP + + ) build neural networks from a rule set for relation extraction . Our distinction is that we use first-order logic to augment a given architecture instead of designing a new one. Also , our framework is related to Kimmig et al . ( 2012 , PSL ) which uses a smooth extension of standard Boolean logic . Hu et al. ( 2016 ) introduced an imitation learning framework where a specialized teacher-student network is used to distill rules into network parameters. This work could be seen as an instance of knowledge distillation ( Hinton et al., 2015 ). Instead of such extensive changes to the learning procedure, our framework retains the original network design and augments existing interpretable layers. Regularization with Logic. Several recent lines of research seek to guide training neural networks by integrating logical rules in the form of additional terms in the loss functions ( e.g., Rocktäschel et al., 2015 ) that essentially promote constraints among output labels ( e.g., Du et al., 2019; Mehta et al., 2018 ), promote agreement ( Hsu et al., 2018 ) or reduce inconsistencies across predictions ( Minervini and Riedel, 2018 ). Furthermore, Xu et al. ( 2018 ) proposed a general design of loss functions using symbolic knowledge about the outputs. Fischer et al . ( 2019 ) described a method for for deriving losses that are friendly to gradient-based learning algorithms . Wang and Poon ( 2018 ) proposed a framework for integrating indirect supervision expressed via probabilistic logic into neural networks. Learning with Structures. Traditional structured prediction models ( e.g. Smith, 2011 ) naturally admit constraints of the kind described in this paper. Indeed , our approach for using logic as a template-language is similar to Markov Logic Networks ( Richardson and Domingos , 2006 ) , where logical forms are compiled into Markov networks . Our formulation augments model scores with constraint penalties is reminiscent of the Constrained Conditional Model of Chang et al . ( 2012 ) . Recently, we have seen some work that allows backpropagating through structures ( e.g. Huang et al., 2015; Kim et al., 2017; Yogatama et al., 2017; Niculae et al., 2018; Peng et al., 2018, and the references within ). Our framework differs from them in that structured inference is not mandantory here. We believe that there is room to study the interplay of these two approaches. Also related to our attention augmentation is using word relatedness as extra input feature to attention neurons ( e.g. Chen et al., 2018 ). 6 Conclusions In this paper, we presented a framework for introducing constraints in the form of logical statements to neural networks. We demonstrated the process of converting first-order logic into differentiable components of networks without extra learnable parameters and extensive redesign. Our experiments were designed to explore the flexibility of our framework with different constraints in diverse tasks. As our experiments showed, our framework allows neural models to benefit from external knowledge during learning and prediction, especially when training data is limited. "}
  },
    {
    "id": "P19-1087",
    "result":     [
            {
        "value":         {
          "start": 535,
          "end": 571,
          "text": "span-attribute tagging ( SA-T ) model",
          "labels": ["Method"]
        },
        "id": 1542
      },
            {
        "value":         {
          "start": 634,
          "end": 659,
          "text": "sequence-to-sequence model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 1197,
          "end": 1203,
          "text": "F-score",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 3713,
          "end": 3729,
          "text": "CRF-based systems",
          "labels": ["Method"]
        },
        "id": 1537
      },
            {
        "value":         {
          "start": 4853,
          "end": 4892,
          "text": "Unified Medical Language System ( UMLS )",
          "labels": ["Method"]
        },
        "id": 1538
      },
            {
        "value":         {
          "start": 7945,
          "end": 7953,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 7959,
          "end": 7964,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 8204,
          "end": 8212,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 8270,
          "end": 8275,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 8414,
          "end": 8433,
          "text": "span-attribute model",
          "labels": ["Method"]
        },
        "id": 1539
      },
            {
        "value":         {
          "start": 8532,
          "end": 8569,
          "text": "sequence-to-sequence ( Seq2Seq ) model",
          "labels": ["Method"]
        },
        "id": 1540
      },
            {
        "value":         {
          "start": 8988,
          "end": 9019,
          "text": "conditional random field ( CRF )",
          "labels": ["Method"]
        },
        "id": 1541
      },
            {
        "value":         {
          "start": 10400,
          "end": 10402,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 11147,
          "end": 11149,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 11467,
          "end": 11503,
          "text": "Span-Attribute Tagging ( SA-T ) model",
          "labels": ["Method"]
        },
        "id": 1542
      },
            {
        "value":         {
          "start": 11957,
          "end": 11974,
          "text": "bidirectional LSTM",
          "labels": ["Method"]
        },
        "id": 1542
      },
            {
        "value":         {
          "start": 12104,
          "end": 12123,
          "text": "feed-forward network",
          "labels": ["Method"]
        },
        "id": 1543
      },
            {
        "value":         {
          "start": 13185,
          "end": 13209,
          "text": "forwardbackward algorithm",
          "labels": ["Method"]
        },
        "id": 1543
      },
            {
        "value":         {
          "start": 13316,
          "end": 13332,
          "text": "Viterbi algorithm",
          "labels": ["Method"]
        },
        "id": 1543
      },
            {
        "value":         {
          "start": 13760,
          "end": 13765,
          "text": "BiLSTM",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 13769,
          "end": 13771,
          "text": "CNN",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 13776,
          "end": 13788,
          "text": "selfattention",
          "labels": ["Method"]
        },
        "id": 1544
      },
            {
        "value":         {
          "start": 15187,
          "end": 15196,
          "text": "SA-T model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 15332,
          "end": 15341,
          "text": "SA-T model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 16834,
          "end": 16865,
          "text": "sequence-to-sequence ( Seq2Seq )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 17198,
          "end": 17204,
          "text": "Seq2Seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 17243,
          "end": 17276,
          "text": "recurrent neural networks ( RNNs )",
          "labels": ["Method"]
        },
        "id": 1546
      },
            {
        "value":         {
          "start": 17539,
          "end": 17557,
          "text": "attention mechanism",
          "labels": ["Method"]
        },
        "id": 1547
      },
            {
        "value":         {
          "start": 17696,
          "end": 17708,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 18008,
          "end": 18021,
          "text": "Seq2Seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 18106,
          "end": 18133,
          "text": "span-attribute tagging model",
          "labels": ["Method"]
        },
        "id": 1554
      },
            {
        "value":         {
          "start": 18685,
          "end": 18698,
          "text": "Seq2Seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 19002,
          "end": 19005,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19024,
          "end": 19034,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 19117,
          "end": 19120,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19186,
          "end": 19196,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 19218,
          "end": 19236,
          "text": "attention mechanism",
          "labels": ["Method"]
        },
        "id": 1547
      },
            {
        "value":         {
          "start": 19326,
          "end": 19329,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19432,
          "end": 19435,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 19544,
          "end": 19574,
          "text": "LSTM-only encoder-decoder model",
          "labels": ["Method"]
        },
        "id": 1547
      },
            {
        "value":         {
          "start": 19847,
          "end": 19858,
          "text": "Skip Thought",
          "labels": ["Method"]
        },
        "id": 1548
      },
            {
        "value":         {
          "start": 20180,
          "end": 20183,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 20189,
          "end": 20199,
          "text": "Transformer",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 20236,
          "end": 20242,
          "text": "Seq2Seq",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 20252,
          "end": 20280,
          "text": "span-attribute tagging models",
          "labels": ["Method"]
        },
        "id": 1549
      },
            {
        "value":         {
          "start": 20349,
          "end": 20352,
          "text": "BERT",
          "labels": ["Method"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20632,
          "end": 20639,
          "text": "accuracy",
          "labels": ["Metric"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 20952,
          "end": 20960,
          "text": "i2b2 task",
          "labels": ["Dataset"]
        },
        "id": 1550
      },
            {
        "value":         {
          "start": 21610,
          "end": 21640,
          "text": "Span-Attribute tagging ( SA-T )",
          "labels": ["Method"]
        },
        "id": 1551
      },
            {
        "value":         {
          "start": 21650,
          "end": 21663,
          "text": "Seq2Seq models",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 21764,
          "end": 21777,
          "text": "Adam optimizer",
          "labels": ["Method"]
        },
        "id": 1552
      },
            {
        "value":         {
          "start": 21974,
          "end": 21977,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 21999,
          "end": 22011,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 22094,
          "end": 22097,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 22148,
          "end": 22160,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 22239,
          "end": 22242,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 22489,
          "end": 22500,
          "text": "LSTM-encoder",
          "labels": ["Method"]
        },
        "id": 1553
      },
            {
        "value":         {
          "start": 22518,
          "end": 22536,
          "text": "Transformer-encoder",
          "labels": ["Method"]
        },
        "id": 1553
      },
            {
        "value":         {
          "start": 22673,
          "end": 22684,
          "text": "LSTM-encoder",
          "labels": ["Method"]
        },
        "id": 1553
      },
            {
        "value":         {
          "start": 22913,
          "end": 22938,
          "text": "bidirectional LSTM-encoder",
          "labels": ["Method"]
        },
        "id": 1553
      },
            {
        "value":         {
          "start": 23232,
          "end": 23234,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23328,
          "end": 23355,
          "text": "span-attribute tagging model",
          "labels": ["Method"]
        },
        "id": 1554
      },
            {
        "value":         {
          "start": 23381,
          "end": 23393,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23669,
          "end": 23674,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23687,
          "end": 23695,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 23715,
          "end": 23727,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 23735,
          "end": 23756,
          "text": "Mann-Whitney rank test",
          "labels": ["Method"]
        },
        "id": 1554
      },
            {
        "value":         {
          "start": 23919,
          "end": 23928,
          "text": "F1 - score",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27417,
          "end": 27420,
          "text": "LSTM",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27436,
          "end": 27438,
          "text": "CRF",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 27957,
          "end": 27966,
          "text": "F1 - score",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 28095,
          "end": 28103,
          "text": "precision",
          "labels": ["Metric"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 28109,
          "end": 28114,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 29154,
          "end": 29155,
          "text": "F1",
          "labels": ["Tool"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 29320,
          "end": 29332,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 30446,
          "end": 30481,
          "text": "span-attribute tagging ( SAT ) model",
          "labels": ["Method"]
        },
        "id": 1555
      },
            {
        "value":         {
          "start": 30500,
          "end": 30525,
          "text": "sequence-to-sequence model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31110,
          "end": 31122,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31376,
          "end": 31382,
          "text": "F-score",
          "labels": ["Metric"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31741,
          "end": 31750,
          "text": "SA-T model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31779,
          "end": 31791,
          "text": "Seq2Seq model",
          "labels": ["Method"]
        },
        "id": 1556
      },
            {
        "value":         {
          "start": 31804,
          "end": 31809,
          "text": "recall",
          "labels": ["Metric"]
        },
        "id": 1556
      }
    ],
    "data": {"text": "Extracting Symptoms and their Status from Clinical Conversations Abstract This paper describes novel models tailored for a new application, that of extracting the symptoms mentioned in clinical conversations along with their status. Lack of any publicly available corpus in this privacy-sensitive domain led us to develop our own corpus, consisting of about 3K conversations annotated by professional medical scribes. We propose two novel deep learning approaches to infer the symptom names and their status : ( 1 ) a new hierarchical span-attribute tagging ( SA-T ) model , trained using curriculum learning , and ( 2 ) a variant of sequence-to-sequence model which decodes the symptoms and their status from a few speaker turns within a sliding window over the conversation . This task stems from a realistic application of assisting medical providers in capturing symptoms mentioned by patients from their clinical conversations. To reflect this application, we define multiple metrics. From inter-rater agreement, we find that the task is inherently difficult. We conduct comprehensive evaluations on several contrasting conditions and observe that the performance of the models range from an F-score of 0.5 to 0.8 depending on the condition . Our analysis not only reveals the inherent challenges of the task, but also provides useful directions to improve the models. 1 Introduction In recent years, hospitals and clinics across the United States have been coaxed and cajoled into adopting Electronic Health Records through public policies and insurance requirements. This has led to the unforeseen side-effect of placing a disproportionate burden of documentation on physicians, causing burnouts among them ( Wachter and Goldsmith, 2018; Xu, 2018 ). One study found that full-time primary care physicians spent about 4.5 hours of an 11-hour workday interacting with the clinical documentation systems, and yet were still unable to finish their documentations and had to spend an additional 1.4 hours after normal clinical hours ( Arndt et al., 2017 ). Speech and natural language processing are now sufficiently mature that there has been considerable interest, both in academia and industry, to investigate how these technologies can be exploited to simplify the task of documentation, and to allow physicians to dedicate more time to patients. While domain-specific ASR systems that allow doctors to dictate notes have been around for a while, recent work ( Patel et al., 2018; Finley et al., 2018a,b ) has begun to address more challenging tasks, such as extracting relevant information directly from doctor-patient conversations. In this work, we investigated the task of inferring symptoms mentioned in clinical conversations, along with whether patients have experienced them or not. Our contributions include: ( i ) defining the task, including the annotation scheme for labeling the clinical conversations and the evaluation metrics to measure model performance ( Section 3 ); ( ii ) two novel deep learning models to solve this task ( Section 4 ); ( iii ) comprehensive empirical evaluations in different contrasting conditions ( Section 5 ), and ( iv ) analysis of the performance of the models that provides meaningful insights for further improvements ( Section 6 ). 2 Related Work On the topic of information extraction from medical text, one of the earliest public-domain task is the i2b2 challenge, defined on a small corpus of written discharge summaries that consists of 394 reports for training, 477 for test, and 877 for evaluation ( Uzuner et al., 2011 ). Given the small amount of training data, not surprisingly, a disproportionately large number of teams fielded rule-based systems. CRF-based systems however did better even with the limited amount of training data . Being a written domain task, they benefited from section headings and other cues that are unavailable in doctor-patient conversations. For a wider survey of extracting clinical information from written clinical documents, see ( Liu et al., 2012 ). There are very few publications on processing clinical conversations. One noteworthy recent work extracts entities using a multi-stage approach ( Finley et al., 2018a ). They use two-level hierarchical model, modeling word sequences and sentence sequences, to classify sentences into the sections in a clinical note they belong to. The extracted sentences are then processed using a variety of heuristics such as partial string matching with an ontology, regular expressions, and other task-specific heuristics. One would imagine sentences taken out of context of a dialog are prone to misinterpretation and they do not elaborate on how that is overcome. Moreover, their system cannot be optimized end-to-end. Other related work includes normalizing the terms and mapping them to external databases such as Unified Medical Language System ( UMLS ) and specific sub-tasks such as negation detection , which are outside the scope of this work ( Happe et al . , 2003 ; Nvol et al . , 2014 ; Lowe and Huang , 2007 ) . 3 The Symptom Extraction Task We begin the description of our task by introducing the corpus, the annotation paradigm, and the evaluation metrics. 3.1 Corpus Description Our unlabeled corpus consists of 90k de-identified and manually transcribed audio recordings of clinical conversations between physicians and patients, typically about 10 minutes long. A few of the conversations also contain speech from nurses, caregivers, spouses and other attendees. The annotation guidelines were developed by a team of professional medical scribes, physicians and natural language processing experts. Two primary categories of labels were annotated: the symptoms being discussed and their status. An ontology of 186 symptoms were defined ( e.g., vomiting, nausea, diarrhea ), each belonging to one of 14 body systems ( e.g., gastrointestinal, musculoskeletal, cardiovascular ). For each symptom, annotators were instructed to associate a status that denotes whether the patient has experienced it or not. An additional catch-all category was defined to include symptoms whose status cannot be conclusively inferred from the conversation or which are not relevant to the clinical note. Thus, status may have one of the three values: experienced, not experienced, and other. In an utterance, “I have a back pain”, the underlined phrase will be assigned the tuple: ( sym:musculo-skeletal:pain, experienced ). The top three symptoms in the corpus are: musculo-skeletal pain, shortness of breath and cough. Of the 90K encounters, we chose to focus on primary care visits. A team of 18 professional scribes was trained on the guidelines. They labeled the manual transcripts of 2,950 conversations, which were partitioned into training ( 1,950 ), development ( 500 ) and test ( 500 ) sets. The entire labeled corpus contains 5M tokens in 615K sentences with 92K labels. To account for variation across scribes, we randomly assigned 3 scribes to label each of the conversations in the development ( 500 ) and test ( 500 ) sets. The inter-labeler agreement in terms of Cohen’s kappa is 0.4 on the development set. Further analyses showed that the low score was largely due to ( i ) the ambiguous and informal ways that patients and doctors discuss symptoms, ( ii ) that human scribes often disagree on which one of closely related labels to pick, and ( iii ) that human scribes often disagree on the span of text to label. 3.2 Evaluation Metrics In clinical conversations, the symptoms may be mentioned multiple times, paraphrased differently, but still may appear in the clinical notes only once. So, we chose to evaluate them at the conversation levels using two metrics. Unweighted metric: In this metric, we account only for the unique symptoms and ignore the number of times they were mentioned. The set of events in the inferred output was compared against the set in the reference to compute the precision and recall for each conversation before averaging across all conversations . Weighted metric: The symptoms that are mentioned more often in a conversation are likely to be more important. In this metric , each symptom is weighted by its frequency : precision is weighted by the frequency of the predictions , while recall is weighted by the frequency of the reference . 4 Models We developed two novel neural network model architectures for this task : 1 ) a span-attribute model that is similar in spirit to a tagging model but works well on our large label space , and 2 ) a sequence-to-sequence ( Seq2Seq ) model ( Sutskever et al . , 2014 ; Cho et al . , 2014 ) that is designed to infer symptoms that are described informally across a few conversation turns . 4.1 Span-Attribute Tagging ( SA-T ) Model A common solution for this task is a tagging model , where the word sequences are represented by word and / or character embeddings and fed into a sequence of layers consisting of a bidirectional layer , a softmax layer and a conditional random field ( CRF ) to predict the BIO-style tags ( Collobert et al . , 2011 ; Huang et al . , 2015 ; Ma and Hovy , 2016 ; Chiu and Nichols , 2016 ; Lample et al . , 2016 ; Peters et al . , 2017 ; Yang et al . , 2017 ; Changpinyo et al . , 2018 ) . However, in our task, the tags need to identify not only the symptom names associated with the words but also the status. This can be accomplished in a tagging model using a label space that is the Cartesian product of both the symptom names and their status. Unfortunately, this Cartesian space turns out to quite large in our task ( 186 x 3 ). Tagging models perform well when the set of tags is reasonably small ( e.g., named entity recognition and part of speech tagging ), but not so well when the set of tags is large. Moreover, in our case, given the limited corpus size, modeling the cross-product space leads to data sparsity. For tackling this challenge of data sparsity, we reformulate the problem from a novel hierarchical perspective. Unlike the conventional tagging model, where at each input token the model has to pick the best candidate label from the full label space, we break this into two stages. We first identify the span of interest using a generic tag set with a very small label set of just three elements, {sym B, sym I, O}. This simplifies the computational cost of inferring over sequence , which allows us to employ the CRF layer . Moreover, it alleviates the data sparsity problem by pooling all the labels to identify all spans of interest. In the second stage, we predict the attributes associated with the span using contextual features of arbitrary complexity without encumbering the inference over the entire sequence. In addition, since our label space can be partitioned easily, we use two separate predictors, one for symptom name and one for status. These two stages are trained jointly in an end-to-end fashion using multi-task learning, as described later. Figure 1 illustrates this hierarchical perspective for our task. The first stage , which is akin to a conventional tagging model , identifies the span of interest – back pain – at the output of the CRF layer . The second stage utilizes the latent representation from the span and employs two separate predictors to classify the symptom name as sym:msk:pain and the status as experienced. In principle, these predictors can be more complex than a simple soft-max that we have used. We refer to this architecture as the Span-Attribute Tagging ( SA-T ) model . The two stages of the model are described in more details below. Span Extraction Layer. As mentioned before, this layer employs a conventional tagging model whose output is constrained to be just three elements of E = {sym B , sym I ,O}. The model is briefly described as follows. Let x be the embedding vector sequence corresponding to the input word sequence. From this sequence , we compute a sequence of latent contextual representations using a bidirectional LSTM , h ′ = [ ~ h ( x | ~ ΘLSTM ) , ~ h ( x | ~ ΘLSTM ) ] . This latent contextual sequence is fed into a two-layer fully connected feed-forward network to obtain a final sequence of latent representation h ′ ′ = MLP ( h ′ | ΘFF ) . Given this feature representation h = ( h ′′ 1 , · · · ,h ′′ N  ) and the target tag sequence ye = ( yi | i = 1, . . . , N ; yi ∈ E ), the parameters of the model are learned by minimizing the negative log-likelihood − logP ( ye|h ). This is computed in terms of a compatibility function defined over any label sequence y and h. Of the two components, the first one estimates the probability of the label sequence in terms of the sum of first order Markov transition of the label sequence y, computed from a learned transition matrix A whose dimensions are |E| × |E|. The second component estimates the joint probability of the latent vector hi and the corresponding label embedding yi, specifically, in terms of similarity measure h>i yi. Using the compatibility function, the loss for the task of recognizing the spans is estimated as −S( ye,h ) + log∑y′ exp ( S( y′,h ) ), where y′ is any other possible sequence of labels. During training , logP ( ye | h ) is estimated using forwardbackward algorithm , and during inference , the most probable sequence y ∗ = arg maxy ′ P ( y ′ | h ) is computed using the Viterbi algorithm . Attribute Tagging Layer. Given the span, as mentioned before, we can potentially use a richer representation of the context to predict attributes than otherwise possible. A contextual representation is computed from the starting index i and ending index j of each span using a pooling function Aggregate( · ). The pooling function can be implemented as simple as mean or sum , or as the hidden state of another encoder like BiLSTM , CNN or selfattention ( Vaswani et al . , 2017 ) . Given the span representation hsij , we model the joint distribution of the symptom name and status as P ( ysx , yst |hsij ) = P ( ysx |hsij )P ( yst |hsij ) with the assumption that they are independent. Then, the distribution over the symptom name for each span is a multinomial distribution P ( ysx = k|hsij ) = Softmax( hsij |Θsx )k. Similarly, we can formulate the distribution over the symptom status as P ( yst = m|hsij ) = Softmax( hsij |Θst )m. Both Θsx and Θst are model parameters. Finally, we can train the model end-to-end by minimizing the following loss function for each conversation: where {( ysx , yst )} is the set of symptom names and associated status in a conversation, and α is the relative weight of the loss of the span extraction task and the attribute prediction task. During training, we are simultaneously attempting to detect the location of tags as well as classify the tags. Initially, our model for locating the tags is unlikely to be reliable, so we adopt a curriculum learning paradigm. Specifically, we provide the classification stage the reference location of the tag from the training data with probability p, and the inferred location of the tag with probability 1 − p. We start the joint multi-task training by setting this probability to 1 and decrease it as training progresses ( Bengio et al., 2015 ). Remarks. Although the SA-T model was developed to infer symptoms and status in the clinical domain , the formulation is general and can be applied to any domain . The SA-T model breaks up the task into identifying spans of interests and then classifying the span with richer contextual representations . The first stage alleviates data sparsity by pooling all spans of interest. When the label space naturally partitions into separate categories, the second stage can be broken up further into separate prediction tasks and reduces data splitting. 4.2 Sequence-to-sequence ( Seq2Seq ) Model As shown in Table 1, symptoms are sometimes not stated explicitly, but rather explained or described in informal language over several conversation turns. There may not even be a symptom entity that is explicitly mentioned; instead, the physician, as well as any symptom extraction model, must infer it from a description. To better capture symptoms that are not referred to by name, we explore an alternative formulation of the problem. In this formulation, the input to the model is a chunk of the conversation, consisting of multiple consecutive turns from the doctor-patient conversation, and the output is a list of symptoms mentioned as well as their statuses. The key difference between this formulation and the span-attribute tagging formulation is that the symptom entity is not assigned to a word or phrase in the input text. In this formulation, each input example consists of a segment of transcript, represented as a sequence of tokens x = ( x1, ..., xm ), and a list of symptoms and their corresponding status y = ( y1, ..., yn ). Hence , it is well-suited to the sequence-to-sequence ( Seq2Seq ) class of models ( Sutskever et al . , 2014 ; Cho et al . , 2014 ) which has been successful across a variety of language understanding tasks , including conversation modeling ( Vinyals and Le , 2015 ) , abstractive summarization ( Nallapati et al . , 2016 ) , and question answering ( Seo et al . , 2017 ) . Following the standard Seq2Seq setup , our model is composed of two recurrent neural networks ( RNNs ) , an encoder and a decoder . First, the encoder consumes x one token at a time, producing an encoding, h( xi ), for each token xi. Then the decoder estimates an output distribution over sequences of symptoms and their status y, conditional on the encodings. An attention mechanism ( Bahdanau et al . , 2015 ) allows the decoder to combine information from the encoded sequences differently at each decoding step . The Seq2Seq model is trained using a cross-entropy criterion to maximize P ( y | x ) – the likelihood of reference symptoms and their status given the conversation transcripts . At inference time, the most likely sequence of symptoms and their status is decoded one token a time using beam search. One challenge for Seq2Seq models is handling very long inputs ( Sutskever et al . , 2014 ) . Therefore , unlike the span-attribute tagging model where each input example may be a full transcript , we use transcript segments consisting of k consecutive turns . In practice we found a value of k = 5 to work well. A value of k that is too small won’t be enough to resolve symptoms like those in Table 1, while a value of k that is too large may degrade quality and make our model harder to train. At inference time, we use a sliding window of size k across the full conversation, and then aggregate the predictions from those windows. 4.3 Encoder Pre-training While the span-attribute tagging and Seq2Seq models have different output layers , they use a common input encoder architecture . At any given input time, the conversation up to that time is represented by the hidden state of the encoder, which is used for making output predictions. We investigated two variations of the encoder. First , we compare the LSTM encoder with the Transformer encoder ( Vaswani et al . , 2017 ) . The key difference between them is that the LSTM relies on latent variables to propagate state information while Transformer relies solely on an attention mechanism . In a machine translation benchmark , the Transformer has been shown to outperform the LSTM encoder ( Vaswani et al . , 2017 ) , and a hybrid model , consisting of a Transformer encoder and an LSTM decoder , performed even better ( Chen et al . , 2018 ) . We therefore compare the hybrid model , with the LSTM-only encoder-decoder model on our task . Second, we use a pre-training technique to leverage unlabeled data and improve the feature representation learned by the encoder ( Kannan et al., 2018 ). Given a short snippet of conversation , the model is tasked with predicting the next turn , similar to Skip Thought ( Kiros et al . , 2015 ) . Since this task requires no labeling, the model can be trained on the full corpus of 90K conversations. The resulting encoder is plugged into our model for the symptom prediction task, and the full model is trained on the subset that is labeled. The pre-training can be performed for both the LSTM and Transformer encoders , as well as for both the Seq2Seq and the span-attribute tagging models . We did not experiment with alternative pre-training loss such as BERT ( Devlin et al . , 2018 ) . 5 Empirical Evaluations Before creating dedicated models for this task, we investigated general purpose named-entity annotation tools akin to ( Momchev, 2010; Nothman et al., 2008 ). While a few of these tools can annotate symptom entities with some accuracy , they have no mechanism to infer the symptom status , which is required for clinical documentation . In all the experiments described below, our models were trained and evaluated on the corpus described in Section 3.1 using the metrics defined in Section 3.2. Since our ontology differs from the public domain i2b2 task , we could not evaluate our models on that task . For a robust estimate of the model performance, the model outputs were evaluated against a “voted” reference created using the labels from three independent scribes. This is the case for all the results reported in the experiments below, unless otherwise specified. While our application requires jointly inferring both the symptom and status ( Sx + Status ), for a better understanding of the model behavior we have also included the performance on inferring just the symptom names ( Sx ). These are reported in separate columns in the tables below. 5.1 Hyperparameters The hyperparameters of the Span-Attribute tagging ( SA-T ) and the Seq2Seq models were picked to maximize the performance on the development set . The models were trained using the Adam optimizer ( Kingma and Ba , 2015 ) and the selected parameters are reported in Table 2 . 5.2 Different Encoders and Pre-training To select the encoder , first we evaluate the impact of pre-training on the LSTM encoder , using the Seq2Seq model . The results are reported in Table 3. The results show that pre-training of the LSTM encoder consistently improves performance of the Seq2Seq model across all metrics . Next , the Transformer encoder was compared against the LSTM encoder , using pre-training in both cases . Based on the performance on the development set, the best encoder was chosen which consists of two layers, each with 1024 hidden dimension and 16 attention heads. The results in Table 4 show that the LSTM-encoder outperforms the Transformer-encoder consistently in this task , when both are pre-trained . Therefore , for the rest of the experiments , we only report results using the LSTM-encoder . 5.3 Manual Transcript Evaluation Next, we evaluate and compare the performance of the models when they are trained and tested on the manual transcripts. For comparison , we include a standard tagging baseline consisting of a bidirectional LSTM-encoder ( pre-trained as described in Section 4.3 ) , followed by two feed-forward layers and a softmax layer . The targets consisted of the cross product space of 186 symptom names and 3 status values. The model was trained using cross-entropy loss. Due to the large cross product label space , the CRF loss is infeasible in this setting . From the results reported in Table 5 , we see that the span-attribute tagging model performs as well as the Seq2Seq model . This is surprising since it is designed to not only predict the symptom name and status, but also to locate the words associated with them, a more demanding task. Another noteworthy difference between the two models is that the tagging model consistently trades off lower recall for higher precision , compared to the Seq2Seq model . The Mann-Whitney rank test indicates that improvements of both the models over the baseline are statistically significant under both metrics . In general , a gain of about 0.02 or more in F1 - score was found to be statistically significant in our experiments on this task . Knowing that the quality of the reference impacts the measured performance, we compared the model output to two versions of references in addition to the “voted” reference. In one version, we used a single reference for each conversation from a randomly chosen scribe. In another version, the model was given credit when the output matches “any” of the three scribes. This was motivated by the observation during adjudication that the symptom names may be annotated in more than one way, as illustrated in the example in Table 6. The model outputs were compared against the above mentioned variants of the reference and the results are reported in Table 7. The measured gap in performance between single reference and “voted” reference is small. The “voted” version corrects the reference, when one of the three scribes misses the annotation. However, when two scribes pick different valid labels and the third misses them, the “voted” reference is not better than the single reference. In such instances, allowing a model to match “any” of the references would be a reasonable solution. This may explain why the performance in that case is substantially better than the single or “voted” reference. 5.4 ASR vs. Manual Transcript Evaluation In clinical applications, manual transcripts will be unavailable and the model needs to infer symptom and status on transcripts obtained from an automatic speech recognition ( ASR ) system. We investigated the impact on performance when the test data is switched from manual to the corresponding ASR transcripts. Such a switch is expected to degrade the performance of models trained on manual transcripts and often this degradation can be alleviated by training the model on ASR transcripts. So, we measured performance using models trained on different combinations of manual and ASR transcripts. Recall, the symptom, as described in Section 3.1, were annotated on manual transcripts. These annotations were automatically transferred to the ASR transcripts by aligning the words in both transcripts for the same speaker turns and mapping the labels from manual transcripts to the corresponding words in the ASR transcripts. The word error rate of the ASR transcripts is about 20% ( Chiu et al., 2018 ). In the alignment process, a fraction of the labels ( 9.1% ) failed to alignment properly and were discarded. The results, reported in Table 8 with “voted” reference, show that the performance of the models trained on manual transcripts ( Manual Train ) degraded when tested on ASR transcripts ( ASR Test ), for both models, as expected. But, surprisingly, training models on ASR transcripts ( ASR Train ) or folding the ASR transcripts into the manual training data ( Combined ) did not improve the performance much. This maybe due to the fact that our performance metrics are evaluated at the conversation level and there is redundancy in clinical conversations, where the same symptom may be mentioned multiple times during the course of the conversation and each time in a different way. 5.5 Symptom Names vs. Body Systems One way to understand the confusion between symptom names is to measure the performance after projecting the inferred symptom names ( 186 types ) to their corresponding body systems ( 14 types ). For example, sym:musculo-skeletal:pain and sym:musculo-skeletal:swelling were collapsed to sym:musculo-skeletal. As a baseline , we trained an LSTM tagger with a CRF output layer to predict targets consisting of the simple Cartesian product of symptom body systems and their status . The performance of the baseline system and our models were evaluated on manual transcripts. Our models were trained to predict the symptom name and the predictions were projected to the system level. The results are reported in Table 9. When the symptom names are collapsed into broader body systems, the performance improves as expected. The gain in performance is surprisingly large at about 0.14 F1 - score . This suggests that a large fraction of confusion comes from names in the same body system. The baseline model has much lower precision and recall compared to our proposed models , even though it was trained on the body system labels directly , once again , demonstrating that the cross-product space is too sparse to be learned properly . 6 Analysis In this section, we conduct detailed comparisons among human scribes and our models. 6.1 Human Performance To understand the inherent difficulty of this task, we estimated the human performance on this task by comparing each scribe against the reference generated from the “voted” results of the three scribes. Even though this estimate is inflated, because each scribes’ annotation was counted towards the voted reference, it is a useful approximation. The results in Table 10 show two clear trends. First, even humans have difficulty identifying symptoms consistently. For example, “constitutional pain” ( non-specific ) and “musculoskeletal pain” were top confusions for our models as well as humans. Second , when status is considered , humans have less trouble inferring it from the context than our models , losing only 0.05 on F1 ( weighted ) , while our models dropped about 0.14 . Improving status classification remains one of our future work. 6.2 Attention Weights Next , we inspected the Seq2Seq model ’ s attention weights to see whether the evidence is scattered across words and turns in the dialog . Indeed, through manual inspection, we found this to be true qualitatively, as illustrated in Table 11. In this example, the symptom “sym:const:difficulty sleeping” is not mentioned directly but is implied from the evidence scattered in the context. Future work could use these weights to further investigate errors. 6.3 Error Analysis Grouping false negatives by their symptom name, we observed that both models struggled with the symptoms – pain, malaise, fatigue, difficult sleeping, weight loss/gain, and frequent urination. As illustrated in Table 12, these symptoms were often communicated through back-and-forth with the doctor and therefore may have required combining evidence from multiple turns, making the inference more difficult. 7 Conclusions This paper describes a novel information extraction task, that of extracting the symptoms mentioned in clinical conversations along with their status. We describe our corpus, the annotation paradigm, and tailored evaluation metrics. We proposed a novel span-attribute tagging ( SAT ) model and a variant of sequence-to-sequence model to solve the problem . The SA-T model breaks up the task into identifying spans of interests and then classifying the span with richer contextual representations. The first stage alleviates data sparsity by pooling all spans of interest. When the label space naturally partitions into separate categories, the second stage can be broken up further into separate prediction tasks and reduces data splitting. Although the SA-T model was developed to infer symptoms and status in the clinical domain, the formulation is general and can be applied to any domain. As an alternative , our Seq2Seq model is designed to infer symptom labels when the evidence is scattered across multiple turns in a dialog and is not easily associated with a specific word span . The performance of our models is significantly better than baseline systems and range from an F-score of 0.5 to 0.8 depending on the condition . When the models are trained on manual transcripts and applied on ASR transcripts, the performance degrades considerably compared to applying them on manual transcripts. Training the model on ASR transcripts or on both ASR and manual transcripts does not help bridge the performance gap. Our analysis show that the SA-T model has higher precision while Seq2Seq model has higher recall , thus the two models compliment each other . We plan to investigate the impact of combining the two models. "}
  }
]